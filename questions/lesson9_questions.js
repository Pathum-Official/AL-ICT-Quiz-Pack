export const originalQuestions = [
    {
        questionText: "ගැටලුවක් විසඳීමේ ක්‍රියාවලියේදී 'ගැටලුව හඳුනා ගැනීම' යන පියවරෙහි ප්‍රධාන අරමුණ කුමක්ද?",
        options: [
            "ගැටලුවේ මූලික ස්වභාවය හා බලපෑම නිවැරදිව වටහා ගැනීම.",
            "ගැටලුවට හැකි සෑම විසඳුමක්ම ලැයිස්තුගත කිරීම.",
            "ගැටලුව විසඳීමට අවශ්‍ය සම්පත් තීරණය කිරීම.",
            "විසඳුම ක්‍රියාත්මක කිරීමේ ක්‍රමවේදය තීරණය කිරීම.",
            "ගැටලුවේ සීමාවන් සහ විෂය පථය නිර්ණය කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "ගැටලුව හඳුනා ගැනීම යනු ගැටලුව කුමක්ද යන්න පැහැදිලිව හා නිවැරදිව තේරුම් ගැනීමයි. මෙය සමස්ත විසඳුම් ක්‍රියාවලියේ පදනම වන අතර, ගැටලුවේ සැබෑ මූලය සහ එහි බලපෑම වටහා ගැනීම මෙහිදී අත්‍යවශ්‍ය වේ. නිවැරදි ගැටලුව හඳුනා නොගතහොත්, වැරදි ගැටලුවකට නිවැරදි විසඳුමක් ලබා දිය හැක."
    },
    {
        questionText: "ගැටලු විසඳීමේ ක්‍රියාවලියේදී 'ගැටලුව හා එහි සීමාවන් අර්ථ දැක්වීම' (Defining the problem and its limitations) පියවරේ වැදගත්කම කුමක්ද?",
        options: [
            "විසඳුම නිර්මාණය කිරීමේදී මුහුණ දිය හැකි බාධක සහ සීමාවන් පැහැදිලිව හඳුනා ගැනීම.",
            "ගැටලුවට අදාළ දත්ත විශ්ලේෂණය කිරීමේ ක්‍රමවේදය තීරණය කිරීම.",
            "ගැටලුව විසඳීමට ගතවන කාලය හා සම්පත් තක්සේරු කිරීම.",
            "විසඳුමෙහි සාර්ථකත්වය මැනීමේ නිර්ණායක සකස් කිරීම.",
            "විසඳුමේ ක්‍රියාකාරීත්වය ඇගයීමට ලක් කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "'ගැටලුව හා එහි සීමාවන් අර්ථ දැක්වීම' යනු ගැටලුවේ විෂය පථය, පවතින සම්පත්, කාල සීමාවන් සහ ක්‍රියාත්මක කිරීමේදී ඇතිවිය හැකි බාධක පැහැදිලිව හඳුනා ගැනීමයි. මෙය විසඳුම සැලසුම් කිරීමට පෙර සිදු කිරීමෙන්, විසඳුමේ යථාර්ථවාදී බව සහ ප්‍රායෝගිකත්වය තහවුරු වේ."
    },
    {
        questionText: "පහත සඳහන් ගැටලු විසඳීමේ ක්‍රියාවලියේ පියවරයන්ගෙන් නිවැරදි අනුපිළිවෙල කුමක්ද?",
        options: [
            "ගැටලුව හඳුනා ගැනීම, ගැටලුව හා එහි සීමාවන් අර්ථ දැක්වීම, විසඳුම සැලසුම් කිරීම, විසඳුම ක්‍රියාත්මක කිරීම.",
            "ගැටලුව හඳුනා ගැනීම, විසඳුම සැලසුම් කිරීම, ගැටලුව හා එහි සීමාවන් අර්ථ දැක්වීම, විසඳුම ක්‍රියාත්මක කිරීම.",
            "විසඳුම සැලසුම් කිරීම, ගැටලුව හඳුනා ගැනීම, ගැටලුව හා එහි සීමාවන් අර්ථ දැක්වීම, විසඳුම ක්‍රියාත්මක කිරීම.",
            "විසඳුම ක්‍රියාත්මක කිරීම, ගැටලුව හඳුනා ගැනීම, ගැටලුව හා එහි සීමාවන් අර්ථ දැක්වීම, විසඳුම සැලසුම් කිරීම.",
            "ගැටලුව හා එහි සීමාවන් අර්ථ දැක්වීම, ගැටලුව හඳුනා ගැනීම, විසඳුම සැලසුම් කිරීම, විසඳුම ක්‍රියාත්මක කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "ගැටලු විසඳීමේ ක්‍රියාවලිය සාමාන්‍යයෙන් අනුගමනය කරන සම්මත පියවරයන් වන්නේ ගැටලුව හඳුනා ගැනීම (Identify), ගැටලුව හා එහි සීමාවන් අර්ථ දැක්වීම (Define), විසඳුම සැලසුම් කිරීම (Plan), සහ විසඳුම ක්‍රියාත්මක කිරීම (Implement) යනාදියයි. මෙය ගැටලුවක් කාර්යක්ෂමව විසඳීම සඳහා පදනම සපයයි."
    },
    {
        questionText: "ගැටලුවක් විසඳීමේ ක්‍රියාවලියේදී 'විසඳුම සැලසුම් කිරීම' (Planning the solution) යටතේ සිදු නොකරන කාර්යය කුමක්ද?",
        options: [
            "අවශ්‍ය දත්ත එක්රැස් කිරීම සහ ඒවා පිරිසිදු කිරීම.",
            "ඇල්ගොරිතම සහ ගැලීම් සටහන් නිර්මාණය කිරීම.",
            "දත්ත ව්‍යුහයන් තෝරා ගැනීම සහ සැලසුම් කිරීම.",
            "ක්‍රමලේඛන භාෂාව තෝරා ගැනීම.",
            "පරීක්ෂණ දත්ත සකස් කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "අවශ්‍ය දත්ත එක්රැස් කිරීම සහ ඒවා පිරිසිදු කිරීම යනු 'ගැටලුව හා එහි සීමාවන් අර්ථ දැක්වීම' යන පියවරේදී හෝ 'විසඳුම ක්‍රියාත්මක කිරීම' ආරම්භයේදී සිදුවිය හැකි කාර්යයකි. විසඳුම සැලසුම් කිරීමේ පියවර ප්‍රධාන වශයෙන් අවධානය යොමු කරන්නේ ඇල්ගොරිතම, දත්ත ව්‍යුහයන්, සහ ක්‍රියාත්මක කිරීමේ උපාය මාර්ග සැලසුම් කිරීම මතය."
    },
    {
        questionText: "ගැටලුවක් විසඳීමේදී 'විසඳුම ක්‍රියාත්මක කිරීම' (Implementing the solution) පියවරෙහිදී අත්‍යවශ්‍යයෙන්ම සිදු කළ යුත්තේ කුමක්ද?",
        options: [
            "සැලසුම් කළ විසඳුම ක්‍රමලේඛ කේතයක් බවට පත් කිරීම.",
            "ගැටලුවේ මූලික හේතුව විශ්ලේෂණය කිරීම.",
            "විසඳුමෙහි කාර්යක්ෂමතාව තක්සේරු කිරීම.",
            "පරිශීලක අවශ්‍යතා විස්තරාත්මකව සටහන් කිරීම.",
            "විසඳුමෙන් ඇතිවිය හැකි අනාගත ගැටලු හඳුනා ගැනීම."
        ],
        correctAnswerIndex: 0,
        explanation: "විසඳුම ක්‍රියාත්මක කිරීමේ පියවරෙහිදී ප්‍රධාන වශයෙන් සිදුවන්නේ පෙර සැලසුම් කරන ලද ඇල්ගොරිතම සහ දත්ත ව්‍යුහයන් භාවිතා කරමින්, තෝරාගත් ක්‍රමලේඛන භාෂාවකින් කේත ලිවීමයි. මෙය සැලසුම සැබෑ, ක්‍රියාත්මක කළ හැකි වැඩසටහනක් බවට පත් කරන අදියරයි."
    },
    {
        questionText: "ගැටලුවක් විසඳීමේ ක්‍රියාවලියේදී, 'ගැටලුව හඳුනා ගැනීම' මඟ හැරුනහොත් ඇතිවිය හැකි වඩාත් බරපතල ප්‍රතිවිපාකය කුමක්ද?",
        options: [
            "සම්පූර්ණයෙන්ම වැරදි ගැටලුවකට විසඳුමක් නිර්මාණය කිරීමේ අවදානම.",
            "විසඳුම ක්‍රියාත්මක කිරීමට වැඩි කාලයක් ගත වීම.",
            "විසඳුමෙහි කාර්යක්ෂමතාව අඩු වීම.",
            "පසුගාමී අනුකූලතා ගැටලු (backward compatibility issues) ඇති වීම.",
            "විසඳුමට අවශ්‍ය සම්පත් නිවැරදිව තක්සේරු කිරීමට නොහැකි වීම."
        ],
        correctAnswerIndex: 0,
        explanation: "ගැටලුව නිවැරදිව හඳුනා නොගැනීම යනු ඔබ විසඳීමට උත්සාහ කරන්නේ කුමන ගැටලුවද යන්න පිළිබඳව පැහැදිලි අවබෝධයක් නොමැති වීමයි. මෙය අවසානයේදී සැබෑ ගැටලුවට විසඳුමක් ලබා නොදී, වෙනත්, සමහරවිට නොපවතින ගැටලුවකට විසඳුමක් නිර්මාණය කිරීමට තුඩු දිය හැක. මෙය සමස්ත ව්‍යාපෘතියේම අසාර්ථකත්වයට හේතුවිය හැක."
    },
    {
        questionText: "ගැටලු විසඳීමේ ක්‍රියාවලියක 'විසඳුම සැලසුම් කිරීම' අදියරෙහිදී 'ගැටලු හඳුනා ගැනීම' සහ 'සීමාවන් අර්ථ දැක්වීම' යන පියවරයන්ගෙන් ලබාගන්නා තොරතුරු භාවිතා කරනු ලබන්නේ කුමන අරමුණක් සඳහාද?",
        options: [
            "ගැටලුවේ සංකීර්ණත්වය අවම කිරීම සඳහා වඩාත් සුදුසු ඇල්ගොරිතම හා දත්ත ව්‍යුහයන් තෝරා ගැනීමට.",
            "අනාගතයේදී ගැටලුවට බලපෑ හැකි බාහිර සාධක හඳුනා ගැනීමට.",
            "ක්‍රියාත්මක කිරීමේ පියවරේදී ඇතිවිය හැකි දෝෂ පුරෝකථනය කිරීමට.",
            "විසඳුම ක්‍රියාත්මක කිරීමට අවශ්‍ය මානව සම්පත තීරණය කිරීමට.",
            "ගැටලුව සඳහා විකල්ප විසඳුම් සංසන්දනය කිරීමේ නිර්ණායක සකස් කිරීමට."
        ],
        correctAnswerIndex: 0,
        explanation: "ගැටලු හඳුනා ගැනීමෙන් සහ සීමාවන් අර්ථ දැක්වීමෙන් ලැබෙන පැහැදිලි අවබෝධය, විසඳුම සැලසුම් කිරීමේදී කාර්යක්ෂම හා ඵලදායී ඇල්ගොරිතම, දත්ත ව්‍යුහයන් සහ ක්‍රියාත්මක කිරීමේ ක්‍රමවේද තෝරා ගැනීමට උපකාරී වේ. මෙම තොරතුරු මඟින් සැලසුම සැබෑ ගැටලුවට ගැළපෙන බව තහවුරු කරයි."
    },
    {
        questionText: "ගැටලු විසඳීමේ ක්‍රියාවලිය ක්‍රියාත්මක කිරීමේදී (Implement) සිදුවන වැදගත්ම අංගයක් වන්නේ කුමක්ද?",
        options: [
            "සැලසුම් කළ ඇල්ගොරිතමය පරිගණකයකට තේරුම් ගත හැකි ආකාරයට පරිවර්තනය කිරීම.",
            "අවශ්‍යතා විශ්ලේෂණය කිරීමේ වාර්තාව සකස් කිරීම.",
            "විසඳුමෙහි අවසන් පරිශීලක පුහුණුව සිදු කිරීම.",
            "ගැටලුවෙහි මුදල්මය වටිනාකම තක්සේරු කිරීම.",
            "විසඳුමෙහි ආයු කාලය පිළිබඳව පුරෝකථනය කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "ක්‍රියාත්මක කිරීමේ අදියරෙහිදී සිදුවන්නේ සැලසුම් කළ ඇල්ගොරිතම සහ දත්ත ව්‍යුහයන් තෝරාගත් ක්‍රමලේඛන භාෂාවක් භාවිතයෙන් සැබෑ කේතයක් බවට පත් කිරීමයි. මෙය පරිගණකයට ක්‍රියාත්මක කළ හැකි ආකාරයට සැලසුම පරිවර්තනය කරන ප්‍රධාන පියවරයි."
    },
    {
        questionText: "පහත සඳහන් ප්‍රකාශයන් අතුරින්, ගැටලු විසඳීමේ ක්‍රියාවලිය සම්බන්ධයෙන් සත්‍ය නොවන ප්‍රකාශය කුමක්ද?",
        options: [
            "මෙය රේඛීය ක්‍රියාවලියක් වන අතර, එක් පියවරක් අවසන් වන තුරු ඊළඟ පියවරට යා නොහැක.",
            "ගැටලුව හඳුනා ගැනීම යනු සැබෑ ගැටලුව කුමක්දැයි තේරුම් ගැනීමයි.",
            "සීමාවන් අර්ථ දැක්වීම විසඳුමෙහි විෂය පථය තීරණය කිරීමට උපකාරී වේ.",
            "විසඳුම සැලසුම් කිරීමේදී ඇල්ගොරිතම සහ ගැලීම් සටහන් භාවිතා වේ.",
            "විසඳුම ක්‍රියාත්මක කිරීම යනු සැලසුම කේත බවට පත් කිරීමයි."
        ],
        correctAnswerIndex: 0,
        explanation: "ගැටලු විසඳීමේ ක්‍රියාවලිය රේඛීය නොවේ. එය පුනරාවර්තන (iterative) ක්‍රියාවලියකි. එක් පියවරකදී ලැබෙන ප්‍රතිපෝෂණ මත පදනම්ව පෙර පියවරයන් වෙත ආපසු ගොස් අවශ්‍ය වෙනස්කම් සිදු කිරීමට සිදුවිය හැක. උදාහරණයක් ලෙස, ක්‍රියාත්මක කිරීමේදී ගැටලුවක් හඳුනාගතහොත් සැලසුම වෙනස් කිරීමට සිදුවිය හැක."
    },
    {
        questionText: "ගැටලුවක් විසඳීමේ ක්‍රියාවලියේදී, 'විසඳුම ක්‍රියාත්මක කිරීම' අවසන් වූ පසු ඊළඟට අත්‍යවශ්‍යයෙන්ම සිදු කළ යුතු පියවර කුමක්ද?",
        options: [
            "නිර්මාණය කළ විසඳුම පරීක්ෂා කිරීම සහ නිදොස් කිරීම.",
            "ගැටලුවෙහි මූලික හේතුව නැවත විශ්ලේෂණය කිරීම.",
            "නව ගැටලු හඳුනා ගැනීම සඳහා පරිසරය නිරීක්ෂණය කිරීම.",
            "මුල් ගැටලුවට අදාළ දත්ත ගබඩා කිරීම.",
            "විසඳුම භාවිතයට පෙර පුළුල් අලෙවිකරණ සැලසුමක් දියත් කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "විසඳුම ක්‍රියාත්මක කිරීමෙන් පසු, එය නිවැරදිව ක්‍රියාත්මක වේදැයි තහවුරු කර ගැනීමට සහ පවතින දෝෂ ඉවත් කර ගැනීමට එය පරීක්ෂා කිරීම (Testing) සහ නිදොස් කිරීම (Debugging) අත්‍යවශ්‍ය වේ. මෙම පියවර සාර්ථක විසඳුමකට මඟ පෙන්වයි."
    },
    {
        questionText: "ගැටලු විසඳීමේ ක්‍රියාවලියක් මඟින් අවසාන ප්‍රතිඵලය ලෙස අප බලාපොරොත්තු වන්නේ කුමක්ද?",
        options: [
            "සැබෑ ලෝකයේ ගැටලුවක් සඳහා කාර්යක්ෂම හා ඵලදායී විසඳුමක්.",
            "සංකීර්ණ දත්ත විශ්ලේෂණ වාර්තාවක්.",
            "නව පරිගණක දෘඪාංග පද්ධතියක්.",
            "පුළුල් වෙළඳපල සමීක්ෂණයක්.",
            "භාවිතා කළ සම්පත් පිළිබඳ සවිස්තරාත්මක වාර්තාවක්."
        ],
        correctAnswerIndex: 0,
        explanation: "ගැටලු විසඳීමේ ක්‍රියාවලියේ අවසාන ඉලක්කය වන්නේ, හඳුනාගත් ගැටලුවට, දී ඇති සීමාවන් තුළ, කාර්යක්ෂම හා ඵලදායී වන, ක්‍රියාත්මක කළ හැකි විසඳුමක් ලබා දීමයි. මෙය සැබෑ ලෝකයේ ගැටලු සඳහා ප්‍රායෝගික විසඳුම් නිර්මාණය කිරීමේ පදනම වේ."
    },
    {
        questionText: "ගැටලු විසඳීමේ ක්‍රියාවලියේදී, 'විසඳුම සැලසුම් කිරීම' සහ 'විසඳුම ක්‍රියාත්මක කිරීම' අතර ඇති ප්‍රධාන වෙනස කුමක්ද?",
        options: [
            "සැලසුම් කිරීම යනු වියුක්ත චින්තනය වන අතර, ක්‍රියාත්මක කිරීම යනු ප්‍රායෝගික කේතකරණයයි.",
            "සැලසුම් කිරීමේදී දෝෂ නිවැරදි වන අතර, ක්‍රියාත්මක කිරීමේදී නව දෝෂ හඳුනාගනු ලැබේ.",
            "සැලසුම් කිරීම යනු පරිශීලක අවශ්‍යතා එකතු කිරීම වන අතර, ක්‍රියාත්මක කිරීම යනු පද්ධතිය පරීක්ෂා කිරීමයි.",
            "සැලසුම් කිරීමේදී පමණක් සම්පත් තක්සේරු කරන අතර, ක්‍රියාත්මක කිරීමේදී සම්පත් භාවිතා වේ.",
            "සැලසුම් කිරීම යනු කණ්ඩායම් සාකච්ඡා වන අතර, ක්‍රියාත්මක කිරීම යනු තනි පුද්ගල කාර්යයකි."
        ],
        correctAnswerIndex: 0,
        explanation: "විසඳුම සැලසුම් කිරීම යනු ඇල්ගොරිතම, දත්ත ව්‍යුහයන්, සහ පද්ධතියේ සමස්ත ගෘහ නිර්මාණ ශිල්පය වැනි වියුක්ත සංකල්ප මට්ටමින් ගැටලුවට විසඳුම් සටහන් කිරීමයි. විසඳුම ක්‍රියාත්මක කිරීම යනු එම සැලසුම සැබෑ, ක්‍රියාත්මක කළ හැකි ක්‍රමලේඛ කේතයක් බවට පත් කිරීමේ ප්‍රායෝගික ක්‍රියාවලියයි."
    },
    {
        questionText: "ගැටලු විසඳීමේ ක්‍රියාවලියේදී 'විසඳුම සැලසුම් කිරීම' පියවරෙහිදී අත්‍යවශ්‍යයෙන්ම සලකා බැලිය යුතු සාධකයක් වන්නේ කුමක්ද?",
        options: [
            "විසඳුමෙහි පරිශීලක අත්දැකීම් (User Experience - UX) වැඩි දියුණු කරන්නේ කෙසේද යන්න.",
            "සැලසුම් කළ විසඳුම ක්‍රියාත්මක කිරීමට අවශ්‍ය පිරිවැය.",
            "ගැටලුවෙහි ඓතිහාසික පසුබිම සහ පෙර උත්සාහයන්.",
            "ගැටලුවට අදාළ සමාජීය හා සංස්කෘතික බලපෑම්.",
            "විසඳුමෙහි ආරක්ෂක අවදානම් විශ්ලේෂණය කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "විසඳුම සැලසුම් කිරීමේදී එහි ක්‍රියාකාරීත්වය, කාර්යක්ෂමතාව සහ පරිශීලක අත්දැකීම් වැඩිදියුණු කරන්නේ කෙසේද යන්න සලකා බැලීම අත්‍යවශ්‍ය වේ. සැලසුමක් සාර්ථක වීමට නම් එය ක්‍රියාකාරී මෙන්ම පරිශීලක-හිතකාමී විය යුතුය."
    },
    {
        questionText: "ගැටලු විසඳීමේ ක්‍රියාවලියේ එක් එක් පියවර අතර සම්බන්ධතාවය වඩාත් නිවැරදිව විස්තර කරන්නේ කෙසේද?",
        options: [
            "එක් පියවරක ප්‍රතිඵල ඊළඟ පියවරට ආදානය ලෙස ක්‍රියා කරන අතර, පසුපසට යාමද සිදුවිය හැක.",
            "එක් පියවරක් තවත් පියවරකින් සම්පූර්ණයෙන්ම ස්වායත්තව ක්‍රියා කරයි.",
            "සියලුම පියවර එකවරම සිදු කළ යුතු අතර, කිසිදු අනුපිළිවෙලක් නොමැත.",
            "පියවරයන්ගේ අනුපිළිවෙල ගැටලුවේ ස්වභාවය අනුව සම්පූර්ණයෙන්ම වෙනස් වේ.",
            "එක් පියවරක් සාර්ථකව අවසන් කළ පසු කිසිදු විටෙක පෙර පියවරකට ආපසු නොයයි."
        ],
        correctAnswerIndex: 0,
        explanation: "ගැටලු විසඳීමේ ක්‍රියාවලිය පුනරාවර්තන ස්වභාවයක් ගනී. එක් පියවරක ප්‍රතිඵල ඊළඟ පියවරට බලපාන අතර, යම් ගැටලුවක් හෝ වැඩිදියුණු කිරීමක් හඳුනාගතහොත් පෙර පියවරයන් වෙත ආපසු ගොස් වෙනස්කම් සිදු කිරීමට සිදු විය හැක. මෙය ක්‍රියාවලියෙහි නම්‍යශීලී බව සහ අනුවර්තනය වීමේ හැකියාව පෙන්නුම් කරයි."
    },
    {
        questionText: "ගැටලු විසඳීමේ ක්‍රියාවලිය භාවිතා කිරීමේ මූලික වාසිය කුමක්ද?",
        options: [
            "ගැටලුවලට ක්‍රමානුකූල හා සංවිධානාත්මක ප්‍රවේශයක් ලබා දීම.",
            "නව දෘඪාංග තාක්ෂණයන් හඳුන්වා දීමට පහසුකම් සැලසීම.",
            "ක්‍රමලේඛන භාෂා වල කාර්යක්ෂමතාව වැඩි දියුණු කිරීම.",
            "පරිගණක පද්ධති වල ආරක්ෂාව තහවුරු කිරීම.",
            "දත්ත ගබඩා කිරීමේ ක්‍රමවේද ප්‍රශස්තකරණය."
        ],
        correctAnswerIndex: 0,
        explanation: "ගැටලු විසඳීමේ ක්‍රියාවලිය මඟින් ඕනෑම සංකීර්ණ ගැටලුවකට ක්‍රමානුකූලව සහ සංවිධානාත්මකව ප්‍රවේශ වීමට හැකියාව ලැබේ. මෙය ගැටලුව පැහැදිලිව තේරුම් ගැනීමට, ඵලදායී විසඳුම් සැලසුම් කිරීමට, සහ ඒවා නිවැරදිව ක්‍රියාත්මක කිරීමට උපකාරී වේ."
    },
    {
        questionText: "ගැටලුවක් විසඳීමේ ක්‍රියාවලියේදී 'ක්‍රියාත්මක කිරීම' (Implementation) පියවරෙන් පසු 'පරීක්ෂා කිරීම' (Testing) පියවරේ වැදගත්කම කුමක්ද?",
        options: [
            "නිර්මාණය කරන ලද විසඳුම පරිශීලක අවශ්‍යතා සපුරාලන්නේද යන්න තහවුරු කර ගැනීම.",
            "සමස්ත ක්‍රියාවලියට ගත වූ කාලය මැන බැලීම.",
            "විසඳුමෙහි මූල්‍යමය වටිනාකම ගණනය කිරීම.",
            "අනාගත වැඩිදියුණු කිරීම් සඳහා සැලසුම් සකස් කිරීම.",
            "වෙනත් සමාන ගැටලු සඳහා භාවිතා කළ හැකි සාමාන්‍ය විසඳුමක් නිර්මාණය කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "විසඳුම ක්‍රියාත්මක කිරීමෙන් පසු එය පරීක්ෂා කිරීම අත්‍යවශ්‍ය වන්නේ, නිර්මාණය කරන ලද විසඳුම පරිශීලක අවශ්‍යතා නිවැරදිව සපුරාලන්නේද, එහි දෝෂ තිබේද, සහ අපේක්ෂිත පරිදි ක්‍රියාත්මක වේද යන්න තහවුරු කර ගැනීමටයි. මෙය විසඳුමෙහි ගුණාත්මකභාවය සහ විශ්වසනීයත්වය සහතික කරයි."
    },
    {
        questionText: "ගැටලු විසඳීමේ ක්‍රියාවලියේදී 'ගැටලුව හඳුනා ගැනීම' සහ 'ගැටලුව හා එහි සීමාවන් අර්ථ දැක්වීම' යන පියවර දෙක අතර ඇති ප්‍රධාන වෙනස කුමක්ද?",
        options: [
            "හඳුනා ගැනීම යනු ගැටලුව කුමක්දැයි සොයා බැලීම වන අතර, අර්ථ දැක්වීම යනු එහි විෂය පථය හා සීමාවන් පැහැදිලි කිරීමයි.",
            "හඳුනා ගැනීම යනු විසඳුම් සැලසුම් කිරීම වන අතර, අර්ථ දැක්වීම යනු කේත ලිවීමයි.",
            "හඳුනා ගැනීම යනු දත්ත විශ්ලේෂණය වන අතර, අර්ථ දැක්වීම යනු ඇල්ගොරිතම නිර්මාණය කිරීමයි.",
            "හඳුනා ගැනීම යනු දෝෂ නිවැරදි කිරීම වන අතර, අර්ථ දැක්වීම යනු පරිශීලක පුහුණුවයි.",
            "හඳුනා ගැනීම යනු විසඳුම ක්‍රියාත්මක කිරීම වන අතර, අර්ථ දැක්වීම යනු පද්ධතිය නඩත්තු කිරීමයි."
        ],
        correctAnswerIndex: 0,
        explanation: "ගැටලුව හඳුනා ගැනීම යනු සැබෑ ගැටලුව කුමක්ද යන්න මූලිකවම අවබෝධ කර ගැනීමයි. ගැටලුව හා එහි සීමාවන් අර්ථ දැක්වීම යනු එම හඳුනාගත් ගැටලුවේ විෂය පථය (Scope), සීමාවන් (Limitations), සහ අපේක්ෂිත ප්‍රතිඵල (Expected Outcomes) වැනි පැති පැහැදිලිව නිර්වචනය කිරීමයි. මෙය ගැටලුවට නිශ්චිත මායිම් නිර්මාණය කරයි."
    },
    {
        questionText: "සැලසුම් කළ විසඳුමක් ක්‍රියාත්මක කිරීමේදී (Implementation) ගැටලු ඇති වුවහොත්, ගැටලු විසඳීමේ ක්‍රියාවලියට අනුව ගත යුතු නිවැරදි පියවර කුමක්ද?",
        options: [
            "පෙර පියවරයන් (සැලසුම් කිරීම, ගැටලුව අර්ථ දැක්වීම) වෙත ආපසු ගොස් අවශ්‍ය වෙනස්කම් සිදු කිරීම.",
            "වහාම ක්‍රියාත්මක කිරීමේ ක්‍රියාවලිය නතර කර අලුත් ගැටලුවක් සෙවීම.",
            "ගැටලුව නොසලකා හැර ඉදිරියට වැඩ කිරීම.",
            "ගැටලුවට හේතුවූ පුද්ගලයන්ට දඬුවම් කිරීම.",
            "අලුත් ක්‍රමලේඛන භාෂාවක් තෝරා ගැනීම."
        ],
        correctAnswerIndex: 0,
        explanation: "ගැටලු විසඳීමේ ක්‍රියාවලිය පුනරාවර්තන ස්වභාවයක් ගනී. ක්‍රියාත්මක කිරීමේදී ගැටලු හටගතහොත්, එය සැලසුමෙහි හෝ මුල් ගැටලු අර්ථ දැක්වීමේ අඩුපාඩුවක් පෙන්නුම් කළ හැක. එබැවින්, පෙර පියවරයන් වෙත ආපසු ගොස් අවශ්‍ය විශ්ලේෂණ හා වෙනස්කම් සිදු කිරීම ඵලදායී විසඳුමක් කරා යාමට අත්‍යවශ්‍ය වේ."
    },
    {
        questionText: "ගැටලු විසඳීමේ ක්‍රියාවලියේදී 'ගැටලුව හඳුනා ගැනීම' සඳහා සාමාන්‍යයෙන් භාවිතා කරන ප්‍රධාන ක්‍රමවේදයක් නොවේ කුමක්ද?",
        options: [
            "පරිශීලක ප්‍රතිපෝෂණ විශ්ලේෂණය කිරීම.",
            "පවතින පද්ධති දත්ත විශ්ලේෂණය කිරීම.",
            "පාර්ශවකරුවන් සමඟ සම්මුඛ සාකච්ඡා පැවැත්වීම.",
            "වෙළඳපල සමීක්ෂණ සිදු කිරීම.",
            "ගැලීම් සටහන් සහ ව්‍යාජ කේත නිර්මාණය කිරීම."
        ],
        correctAnswerIndex: 4,
        explanation: "ගැලීම් සටහන් සහ ව්‍යාජ කේත නිර්මාණය කිරීම ගැටලු විසඳීමේ ක්‍රියාවලියේ 'විසඳුම සැලසුම් කිරීම' යන පියවරට අදාළ වන අතර, ගැටලුව හඳුනා ගැනීමට සෘජුවම සම්බන්ධ නොවේ. ගැටලුව හඳුනා ගැනීමට සාමාන්‍යයෙන් පරිශීලක ප්‍රතිපෝෂණ, දත්ත විශ්ලේෂණ, සහ සම්මුඛ සාකච්ඡා වැනි ක්‍රම භාවිතා කරයි."
    },
    {
        questionText: "විසඳුමක් සැලසුම් කිරීමේදී එහි 'නඩත්තු කිරීමේ හැකියාව' (Maintainability) සලකා බැලීම වැදගත් වන්නේ ඇයි?",
        options: [
            "අනාගතයේදී විසඳුමෙහි වැඩිදියුණු කිරීම් හෝ දෝෂ නිවැරදි කිරීම් පහසු කිරීම සඳහා.",
            "විසඳුමෙහි මුදල්මය වටිනාකම තීරණය කිරීම සඳහා.",
            "විසඳුම වෙළඳපොළට හඳුන්වා දීමට ගතවන කාලය අඩු කිරීම සඳහා.",
            "විසඳුමෙහි ආරම්භක සංවර්ධන පිරිවැය අවම කිරීම සඳහා.",
            "විසඳුමෙහි ක්‍රියාකාරීත්වයේ සංකීර්ණත්වය වැඩි කිරීම සඳහා."
        ],
        correctAnswerIndex: 0,
        explanation: "විසඳුමක් සැලසුම් කිරීමේදී එහි නඩත්තු කිරීමේ හැකියාව සලකා බැලීම ඉතා වැදගත් වේ. හොඳින් සැලසුම් කරන ලද විසඳුමක් අනාගතයේදී වෙනස්කම් කිරීමට, දෝෂ නිවැරදි කිරීමට, සහ නව විශේෂාංග එකතු කිරීමට පහසු වන අතර, එය දීර්ඝ කාලීනව පද්ධතියේ පිරිවැය සහ ක්‍රියාකාරීත්වය කෙරෙහි ධනාත්මක බලපෑමක් ඇති කරයි."
    },

    // 9.2 ගැටලු විසඳීම සඳහා ඉහළ පහළ පියවරාකාර (Top-Down Stepwise Refinement) ක්‍රමවේදය
    {
        questionText: "Top-Down Stepwise Refinement ක්‍රමවේදයේ මූලික අරමුණ කුමක්ද?",
        options: [
            "සංකීර්ණ ගැටලුවක් කුඩා, කළමනාකරණය කළ හැකි කොටස් වලට බෙදා විසඳීම.",
            "ගැටලුවට එක් වරම අවසාන විසඳුම ලබා දීම.",
            "ගැටලුවෙහි මූලික හේතු හඳුනා ගැනීම.",
            "විවිධ ක්‍රමලේඛන භාෂා සංසන්දනය කිරීම.",
            "දත්ත ගබඩා කිරීමේ කාර්යක්ෂමතාව වැඩි දියුණු කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "Top-Down Stepwise Refinement ක්‍රමවේදය යනු විශාල හා සංකීර්ණ ගැටලුවක් හෝ පද්ධතියක්, කුඩා, කළමනාකරණය කළ හැකි උප-ගැටලු (sub-problems) හෝ මොඩියුල (modules) වලට බෙදා වෙන් කිරීමයි. මෙය ගැටලුව අවබෝධ කර ගැනීමටත්, විසඳුම සැලසුම් කිරීමටත්, ක්‍රියාත්මක කිරීමටත් පහසු කරයි."
    },
    {
        questionText: "මොඩියුලකරණය (Modularization) යන්නෙන් අදහස් වන්නේ කුමක්ද?",
        options: [
            "පද්ධතියක් ස්වාධීන, වෙන වෙනම ක්‍රියාත්මක විය හැකි උප-කොටස් වලට වෙන් කිරීම.",
            "පද්ධතියක දත්ත සුරක්ෂිතව ගබඩා කිරීමේ ක්‍රමවේදය.",
            "පද්ධතියක ක්‍රියාකාරීත්වය සරල කේත බවට පරිවර්තනය කිරීම.",
            "පද්ධතියක පරිශීලක අතුරු මුහුණත නිර්මාණය කිරීමේ ක්‍රියාවලිය.",
            "පද්ධතියක් ජාලගත පරිසරයකට සම්බන්ධ කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "මොඩියුලකරණය යනු විශාල වැඩසටහනක් හෝ පද්ධතියක් ස්වාධීන, වෙන වෙනම නිර්මාණය කර පරීක්ෂා කළ හැකි කුඩා කොටස් හෙවත් මොඩියුල වලට වෙන් කිරීමයි. මෙය වැඩසටහනේ සංකීර්ණත්වය අඩු කරන අතර, නඩත්තුව සහ දෝෂ නිවැරදි කිරීම පහසු කරයි."
    },
    {
        questionText: "Top-Down සැලසුමක් (Top-Down Design) මඟින් සපයන ප්‍රධාන වාසිය කුමක්ද?",
        options: [
            "පද්ධතියක සමස්ත ව්‍යුහය පිළිබඳ පැහැදිලි අවබෝධයක් ලබා දීම.",
            "විසඳුමෙහි ක්‍රියාත්මක කිරීමේ වේගය වැඩි කිරීම.",
            "දෝෂ නිවැරදි කිරීමේ ක්‍රියාවලිය සංකීර්ණ කිරීම.",
            "පද්ධතියේ ආරක්ෂක අවදානම් වැඩි කිරීම.",
            "ක්‍රමලේඛන කේත ප්‍රමාණය සැලකිය යුතු ලෙස අඩු කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "Top-Down සැලසුම මඟින් පද්ධතියක සමස්ත ව්‍යුහය ඉහළ මට්ටමකින් ආරම්භ වී ක්‍රමයෙන් කුඩා උප-කොටස් දක්වා විස්තර කෙරේ. මෙය පද්ධතියේ ක්‍රියාකාරීත්වය සහ එහි කොටස් එකිනෙක සම්බන්ධ වන ආකාරය පිළිබඳව පැහැදිලි අවබෝධයක් ලබා දෙන අතර, සංවර්ධනය වඩාත් සංවිධානාත්මක කරයි."
    },
    {
        questionText: "Stepwise Refinement ක්‍රමවේදය යනු කුමක්ද?",
        options: [
            "සෑම පියවරකදීම ගැටලුවේ විස්තර ක්‍රමයෙන් වැඩි දියුණු කරමින්, අවසාන විසඳුම වෙත ළඟා වීම.",
            "සියලුම ගැටලු එකවර විසඳීම සඳහා විශාල කේත කොටස් ලිවීම.",
            "සෑම ගැටලුවක්ම ආරම්භයේ සිට අවසානය දක්වා වහාම විසඳීම.",
            "පවතින විසඳුම් නව අවශ්‍යතාවලට අනුවර්තනය කිරීම.",
            "ගැටලුවෙහි ඉතිහාසය විශ්ලේෂණය කර අනාගත ප්‍රවණතා පුරෝකථනය කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "Stepwise Refinement යනු ගැටලුවක් හෝ පද්ධතියක් මුලින්ම ඉහළ මට්ටමකින් විස්තර කර, පසුව එම එක් එක් කොටසෙහි විස්තර ක්‍රමයෙන් වැඩි දියුණු කරමින්, අවසානයේදී සවිස්තරාත්මක විසඳුමක් කරා ළඟා වීමයි. මෙය ගැටලුවේ සංකීර්ණත්වය පියවරෙන් පියවර කළමනාකරණය කිරීමට උපකාරී වේ."
    },
    {
        questionText: "ව්‍යුහ සටහන් (Structure Charts) භාවිතා කරන්නේ කුමන අරමුණක් සඳහාද?",
        options: [
            "වැඩසටහනක මොඩියුල අතර ඇති සම්බන්ධතා සහ දත්ත ප්‍රවාහය නිරූපණය කිරීමට.",
            "වැඩසටහනක කේත රේඛා ගණන ගණනය කිරීමට.",
            "පරිශීලක අතුරු මුහුණතේ සැලසුම විස්තර කිරීමට.",
            "දත්ත ගබඩාවක ව්‍යුහය පෙන්වීමට.",
            "පරිගණක ජාලයක සම්බන්ධතා පෙන්වීමට."
        ],
        correctAnswerIndex: 0,
        explanation: "ව්‍යුහ සටහන් (Structure Charts) යනු වැඩසටහනක මොඩියුල (functions/subroutines) අතර ඇති ධූරාවලි (hierarchical) සම්බන්ධතාවය සහ ඒවා අතර දත්ත ප්‍රවාහය (data flow) නිරූපණය කිරීමට භාවිතා කරන රූපමය නිරූපණයකි. මෙය Top-Down සැලසුම අවබෝධ කර ගැනීමට ඉතා ප්‍රයෝජනවත් වේ."
    },
    {
        questionText: "මොඩියුලකරණයේ ප්‍රතිලාභයක් නොවන කරුණ කුමක්ද?",
        options: [
            "වැඩසටහනක සමස්ත ක්‍රියාත්මක කිරීමේ වේගය සැලකිය යුතු ලෙස වැඩි කිරීම.",
            "වැඩසටහනක සංකීර්ණත්වය අඩු කිරීම.",
            "වැඩසටහන් නඩත්තුව පහසු කිරීම.",
            "දෝෂ නිවැරදි කිරීම පහසු කිරීම.",
            "කණ්ඩායම් වැඩ සඳහා පහසුකම් සැලසීම."
        ],
        correctAnswerIndex: 0,
        explanation: "මොඩියුලකරණය මඟින් වැඩසටහනක සංකීර්ණත්වය අඩු වන අතර, නඩත්තුව සහ දෝෂ නිවැරදි කිරීම පහසු වේ. නමුත් එය වැඩසටහනක සමස්ත ක්‍රියාත්මක කිරීමේ වේගය සෘජුවම සැලකිය යුතු ලෙස වැඩි නොකරයි. ඇතැම් විට මොඩියුල අතර ඇති සම්බන්ධතා හේතුවෙන් සුළු කාර්යසාධන පිරිවැයක් (overhead) පවා ඇති විය හැක."
    },
    {
        questionText: "Top-Down Design ක්‍රමවේදයේදී, වඩාත්ම වියුක්ත මට්ටමේ සිට වඩාත්ම සවිස්තරාත්මක මට්ටම දක්වා ගමන් කරන්නේ කුමක් මඟින්ද?",
        options: [
            "ක්‍රමලේඛ කේතය.",
            "සැලසුම් ලේඛන.",
            "ව්‍යුහ සටහන්.",
            "ගැලීම් සටහන්.",
            "ව්‍යාජ කේත."
        ],
        correctAnswerIndex: 2,
        explanation: "ව්‍යුහ සටහන් (Structure Charts) Top-Down Design ක්‍රමවේදයේ හරය නිරූපණය කරයි. එය වැඩසටහනක ඉහළ මට්ටමේ මොඩියුලයන්ගේ සිට, ඒවායේ උප-මොඩියුලයන් දක්වා, ක්‍රමයෙන් සවිස්තරාත්මක වෙමින්, සමස්ත ක්‍රියාකාරීත්ව ව්‍යුහය පෙන්වයි."
    },
    {
        questionText: "Stepwise Refinement මඟින් ගැටලුවකට විසඳුම් සකස් කිරීමේදී, එක් එක් පියවරේදී අවධානය යොමු කරන්නේ කුමක් කෙරෙහිද?",
        options: [
            "මුළු ගැටලුවේම නවතම කේත කොටස ලිවීම.",
            "එම පියවරට අදාළ උප-ගැටලුවෙහි විස්තර පැහැදිලි කිරීම සහ සංකීර්ණත්වය අවම කිරීම.",
            "ඊළඟ පියවරේදී ඇතිවිය හැකි දෝෂ පුරෝකථනය කිරීම.",
            "විසඳුමේ මූල්‍යමය වාසි තක්සේරු කිරීම.",
            "විසඳුමෙහි ආරක්ෂක පද්ධති සැලසුම් කිරීම."
        ],
        correctAnswerIndex: 1,
        explanation: "Stepwise Refinement හිදී, සෑම පියවරකදීම පෙර පියවරේදී නිර්වචනය කරන ලද එක් උප-ගැටලුවක් හෝ මොඩියුලයක් ගෙන, එය වඩාත් සවිස්තරාත්මකව විස්තර කරනු ලැබේ. මෙය මුළු ගැටලුවම එකවර විසඳීම වෙනුවට, පියවරෙන් පියවර සංකීර්ණත්වය අඩු කරමින් විසඳුම ගොඩනැගීමට උපකාරී වේ."
    },
    {
        questionText: "මොඩියුලකරණය හොඳින් ක්‍රියාත්මක වූ විට, එක් මොඩියුලයක් වෙනස් කිරීමෙන් අනෙක් මොඩියුල වලට ඇති වන බලපෑම කුමක්ද?",
        options: [
            "අවම බලපෑමක් හෝ කිසිදු බලපෑමක් නොමැති වීම.",
            "සියලුම මොඩියුලයන් නැවත ලිවීමට සිදුවීම.",
            "මුළු පද්ධතියම බිඳ වැටීම.",
            "වෙනස් කිරීම් කළ නොහැකි වීම.",
            "අලුත් දත්ත ගබඩාවක් නිර්මාණය කිරීමට සිදුවීම."
        ],
        correctAnswerIndex: 0,
        explanation: "හොඳින් මොඩියුලකරණය කරන ලද පද්ධතියක, එක් මොඩියුලයක වෙනස්කම් සිදු කිරීම අනෙක් මොඩියුල වලට අවම බලපෑමක් ඇති කරයි. මෙය මොඩියුලවල 'නිරවද්‍යතාවය' (cohesion) සහ 'යුග්මනය' (coupling) මත රඳා පවතී. අරමුණ වන්නේ ඉහළ නිරවද්‍යතාවයක් (මොඩියුලය තනි කාර්යයක් පමණක් ඉටු කිරීම) සහ අඩු යුග්මනයක් (මොඩියුල අතර අඩු පරායත්තතාවයක්) පවත්වා ගැනීමයි."
    },
    {
        questionText: "Top-Down Design ක්‍රමවේදය සංකීර්ණ මෘදුකාංග සංවර්ධන ව්‍යාපෘති සඳහා වඩාත් සුදුසු වන්නේ ඇයි?",
        options: [
            "එය සමස්ත ව්‍යාපෘතියෙහි අවදානම් කළමනාකරණය කිරීමට උපකාරී වන බැවින්.",
            "එය වැඩසටහන් කේත ලිවීමේ වේගය සැලකිය යුතු ලෙස වැඩි කරන බැවින්.",
            "එය කිසිදු සැලසුම් ලියකියවිලි අවශ්‍ය නොවන බැවින්.",
            "එය මෘදුකාංග සංවර්ධන කණ්ඩායමේ සාමාජිකයන් සංඛ්‍යාව අඩු කරන බැවින්.",
            "එය සෑම විටම පරිපූර්ණ, දෝෂ රහිත විසඳුම් ලබා දෙන බැවින්."
        ],
        correctAnswerIndex: 0,
        explanation: "Top-Down Design ක්‍රමවේදය මඟින් සංකීර්ණ ව්‍යාපෘතියක් කුඩා, කළමනාකරණය කළ හැකි කොටස් වලට බෙදා වෙන් කරයි. මෙය එක් එක් කොටස වෙන වෙනම සංවර්ධනය කිරීමට, පරීක්ෂා කිරීමට, සහ අවදානම් කළමනාකරණය කිරීමට පහසුකම් සලසයි. එමඟින් සමස්ත ව්‍යාපෘතියේ සාර්ථකත්වයේ සම්භාවිතාව වැඩි වේ."
    },
    {
        questionText: "ව්‍යුහ සටහනක, මොඩියුල අතර ඇති 'දත්ත ඊතල' (data arrows) මඟින් නිරූපණය කරන්නේ කුමක්ද?",
        options: [
            "මොඩියුල අතර හුවමාරු වන තොරතුරු වර්ගය සහ දිශාව.",
            "මොඩියුල ක්‍රියාත්මක වන අනුපිළිවෙල.",
            "මොඩියුල අතර ඇති පාලන ප්‍රවාහය (control flow).",
            "මොඩියුලවල කාර්ය සාධන මට්ටම.",
            "මොඩියුලයන්ට අවශ්‍ය මතක ප්‍රමාණය."
        ],
        correctAnswerIndex: 0,
        explanation: "ව්‍යුහ සටහන් වල (Structure Charts) දත්ත ඊතල (data arrows) මඟින් මොඩියුල අතර සිදුවන දත්ත හුවමාරුව පෙන්වයි. මෙම ඊතලවලට දත්තයේ නම ඇතුළත් වන අතර, දත්ත ගමන් කරන දිශාවද එයින් පෙන්නුම් කෙරේ. මෙය මොඩියුල අතර යුග්මනය (coupling) අවබෝධ කර ගැනීමට උපකාරී වේ."
    },
    {
        questionText: "Top-Down Stepwise Refinement ක්‍රමවේදයේදී, මුලින්ම අවධානය යොමු කරන්නේ කුමක් කෙරෙහිද?",
        options: [
            "පද්ධතියේ සමස්ත ක්‍රියාකාරීත්වය සහ එහි ප්‍රධාන කාර්යයන්.",
            "කුඩාම, සවිස්තරාත්මක කේත කොටස් ලිවීම.",
            "දත්ත ගබඩාවේ ව්‍යුහය නිර්මාණය කිරීම.",
            "පරිශීලක අතුරු මුහුණතේ වර්ණ සහ අකුරු තෝරා ගැනීම.",
            "පද්ධතියේ ආරක්ෂක ස්ථර (security layers) සැලසුම් කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "Top-Down Stepwise Refinement ක්‍රමවේදයේදී, මුලින්ම අවධානය යොමු කරන්නේ පද්ධතියේ සමස්ත ක්‍රියාකාරීත්වය (overall functionality) සහ එහි ප්‍රධාන කාර්යයන් (major functions) ඉහළ මට්ටමකින් නිර්වචනය කිරීමයි. පසුව, එම ප්‍රධාන කාර්යයන් කුඩා උප-කාර්යයන් වලට බෙදා, ක්‍රමයෙන් සවිස්තරාත්මක කරයි."
    },
    {
        questionText: "ව්‍යුහ සටහනක, මොඩියුලයක් සෘජුවම වෙනත් මොඩියුලයකට දත්ත යවන විට, එයින් නිරූපණය වන්නේ කුමක්ද?",
        options: [
            "එම මොඩියුල දෙක අතර දත්ත යුග්මනය (data coupling) පවතින බව.",
            "එම මොඩියුල දෙක අතර පාලන යුග්මනය (control coupling) පවතින බව.",
            "එම මොඩියුල දෙක සම්පූර්ණයෙන්ම ස්වාධීන බව.",
            "එම මොඩියුල දෙකම එකම විධාන කට්ටලයක් භාවිතා කරන බව.",
            "එම මොඩියුල දෙකම එකම දත්ත ගබඩාවකට ප්‍රවේශ වන බව."
        ],
        correctAnswerIndex: 0,
        explanation: "ව්‍යුහ සටහනක මොඩියුල දෙකක් අතර දත්ත ඊතලයක් තිබීමෙන් දැක්වෙන්නේ එම මොඩියුල අතර දත්ත යුග්මනය (data coupling) පවතින බවයි. දත්ත යුග්මනය යනු මොඩියුලයක් තවත් මොඩියුලයකට අවශ්‍ය දත්ත සෘජුවම ලබා දීමයි. සාමාන්‍යයෙන් මෙය යෝග්‍ය යුග්මන ආකාරයක් ලෙස සැලකේ."
    },
    {
        questionText: "Stepwise Refinement මඟින් සංකීර්ණ ගැටලුවක් සරල ගැටලුවලට බෙදීමෙන් ලැබෙන ප්‍රධාන වාසිය කුමක්ද?",
        options: [
            "සෑම කුඩා ගැටලුවක්ම ස්වාධීනව විසඳීමට සහ පරීක්ෂා කිරීමට හැකි වීම.",
            "අවසාන විසඳුම සඳහා අවශ්‍ය කේත ප්‍රමාණය අඩු කිරීම.",
            "විසඳුමෙහි ආරක්ෂක අවදානම් සම්පූර්ණයෙන්ම ඉවත් කිරීම.",
            "සෑම විටම වඩාත් කාර්යක්ෂම ඇල්ගොරිතම තෝරා ගැනීමට හැකි වීම.",
            "විසඳුමෙහි සංවර්ධන කාලය සැලකිය යුතු ලෙස අඩු කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "Stepwise Refinement හි ප්‍රධාන වාසියක් වන්නේ සංකීර්ණ ගැටලුව සරල උප-ගැටලුවලට බෙදීමෙන්, එම එක් එක් උප-ගැටලුව වෙන වෙනම විශ්ලේෂණය කිරීමට, සැලසුම් කිරීමට, ක්‍රියාත්මක කිරීමට, සහ පරීක්ෂා කිරීමට හැකි වීමයි. මෙය සමස්ත ක්‍රියාවලිය වඩාත් කළමනාකරණය කළ හැකි සහ පාලනය කළ හැකි එකක් බවට පත් කරයි."
    },
    {
        questionText: "Top-Down සැලසුම සහ Bottom-Up සැලසුම අතර ප්‍රධාන වෙනස කුමක්ද?",
        options: [
            "Top-Down සැලසුම සමස්ත පද්ධතියෙන් ආරම්භ වන අතර, Bottom-Up සැලසුම කුඩාම මොඩියුලවලින් ආරම්භ වේ.",
            "Top-Down සැලසුම කේත ලිවීමට පෙර දෝෂ නිවැරදි කරයි, Bottom-Up සැලසුම කේත ලිවීමෙන් පසු දෝෂ නිවැරදි කරයි.",
            "Top-Down සැලසුම සරල ගැටලු සඳහා භාවිතා කරන අතර, Bottom-Up සැලසුම සංකීර්ණ ගැටලු සඳහා භාවිතා කරයි.",
            "Top-Down සැලසුම දෘඪාංග සංවර්ධනයට අදාළ වන අතර, Bottom-Up සැලසුම මෘදුකාංග සංවර්ධනයට අදාළ වේ.",
            "Top-Down සැලසුම සීමිත සම්පත් සහිත ව්‍යාපෘති සඳහා සුදුසු වන අතර, Bottom-Up සැලසුම අසීමිත සම්පත් සහිත ව්‍යාපෘති සඳහා සුදුසු වේ."
        ],
        correctAnswerIndex: 0,
        explanation: "Top-Down සැලසුම යනු පද්ධතියේ සමස්ත ක්‍රියාකාරීත්වය සහ එහි ප්‍රධාන කොටස් ඉහළ මට්ටමකින් නිර්වචනය කර, ක්‍රමයෙන් කුඩා, සවිස්තරාත්මක උප-කොටස් දක්වා ගමන් කිරීමයි. Bottom-Up සැලසුම යනු කුඩාම, තනි කාර්යයන් ඉටු කරන මොඩියුල නිර්මාණය කර, ඒවා එකට එකතු කරමින් විශාල පද්ධතියක් ගොඩනැගීමයි."
    },
    {
        questionText: "ව්‍යුහ සටහනක, පාලන ඊතලයක් (control arrow) මඟින් නිරූපණය කරන්නේ කුමක්ද?",
        options: [
            "එක් මොඩියුලයක් තවත් මොඩියුලයක ක්‍රියාකාරීත්වය පාලනය කරන ආකාරය.",
            "මොඩියුල අතර දත්ත ප්‍රවාහය.",
            "මොඩියුලයක ක්‍රියාත්මක කිරීමේ වේගය.",
            "මොඩියුලයකට අවශ්‍ය මතක ප්‍රමාණය.",
            "මොඩියුලයක් විසින් ජනනය කරන ලද දෝෂ වාර්තා."
        ],
        correctAnswerIndex: 0,
        explanation: "ව්‍යුහ සටහනක පාලන ඊතලයක් (control arrow), බොහෝ විට කොන්දේසි සහිත තීරණයක් (conditional decision) හෝ පුනරාවර්තනයක් (iteration) වැනි පාලන තොරතුරු එක් මොඩියුලයකින් තවත් මොඩියුලයකට යන ආකාරය නිරූපණය කරයි. මෙය සාමාන්‍යයෙන් දත්ත ඊතල තරම් යෝග්‍ය නොවන යුග්මන ආකාරයක් (control coupling) ලෙස සැලකේ."
    },
    {
        questionText: "මොඩියුලකරණයේ ප්‍රතිඵලයක් ලෙස 'කේත නැවත භාවිතා කිරීමේ හැකියාව' (Code Reusability) වැඩි දියුණු වන්නේ කෙසේද?",
        options: [
            "පෙර නිර්මාණය කරන ලද මොඩියුලයන් වෙනත් වැඩසටහන් වල හෝ එකම වැඩසටහනෙහි විවිධ ස්ථානවල භාවිතා කිරීමට හැකි වන බැවින්.",
            "වැඩසටහනට අවශ්‍ය කේත ප්‍රමාණය සම්පූර්ණයෙන්ම ඉවත් කරන බැවින්.",
            "කේතය කියවීමට මිනිසුන්ට පහසු වන බැවින්.",
            "කේතය ස්වයංක්‍රීයව දෝෂ රහිත වන බැවින්.",
            "අලුත් දෘඪාංග මිලදී ගැනීමේ අවශ්‍යතාවය අඩු කරන බැවින්."
        ],
        correctAnswerIndex: 0,
        explanation: "මොඩියුලකරණය මඟින් තනි තනි කාර්යයන් ඉටු කරන ස්වාධීන කොටස් නිර්මාණය වේ. මෙම මොඩියුලයන් හොඳින් සැලසුම් කර ඇත්නම්, ඒවා වෙනත් වැඩසටහන් වලට හෝ එකම වැඩසටහනෙහි විවිධ කොටස් වලට පහසුවෙන් ඇතුළත් කර නැවත භාවිතා කළ හැක. මෙය සංවර්ධන කාලය අඩු කරන අතර, කේතයේ ගුණාත්මකභාවය වැඩි දියුණු කරයි."
    },
    {
        questionText: "Top-Down Design ක්‍රමවේදයේදී, 'පිරිපහදු කිරීම' (Refinement) යන්නෙන් අදහස් වන්නේ කුමක්ද?",
        options: [
            "ඉහළ මට්ටමේ සංකල්ප ක්‍රමයෙන් වඩාත් සවිස්තරාත්මක හා නිශ්චිත අංග බවට වෙන් කිරීම.",
            "අවසන් කේතය ලිවීමට පෙර සියලුම දෝෂ නිවැරදි කිරීම.",
            "වැඩසටහනක ක්‍රියාත්මක කිරීමේ වේගය ප්‍රශස්තකරණය කිරීම.",
            "විසඳුමෙහි පරිශීලක අතුරු මුහුණතේ සැලසුම වෙනස් කිරීම.",
            "දත්ත ගබඩාවක් නිර්මාණය කිරීමේ ක්‍රියාවලිය."
        ],
        correctAnswerIndex: 0,
        explanation: "Top-Down Design හි 'පිරිපහදු කිරීම' (Refinement) යනු ඉහළ මට්ටමේ, වියුක්ත සංකල්ප හෝ කාර්යයන් ගෙන, ඒවා ක්‍රමයෙන් කුඩා, වඩාත් සවිස්තරාත්මක, සහ ක්‍රියාත්මක කළ හැකි උප-කොටස් වලට (මොඩියුල) වෙන් කිරීමයි. මෙය ගැටලුවේ සංකීර්ණත්වය ක්‍රමානුකූලව අඩු කරන ක්‍රියාවලියකි."
    },
    {
        questionText: "ව්‍යුහ සටහනක, මොඩියුලයක් නිරූපණය කිරීමට භාවිතා කරන සම්මත සංකේතය කුමක්ද?",
        options: [
            "සෘජුකෝණාස්‍රයක් (Rectangle).",
            "ඕවලාකාරයක් (Oval).",
            "දියමන්තියක් (Diamond).",
            "සමාන්තර චතුරස්‍රයක් (Parallelogram).",
            "කවයක් (Circle)."
        ],
        correctAnswerIndex: 0,
        explanation: "ව්‍යුහ සටහන් වල (Structure Charts), වැඩසටහන් මොඩියුලයක් (function, subroutine, procedure) නිරූපණය කිරීම සඳහා සාමාන්‍යයෙන් සෘජුකෝණාස්‍රයක් භාවිතා කරයි. මෙම සෘජුකෝණාස්‍රය තුළ මොඩියුලයේ නම ලියා ඇත."
    },
    {
        questionText: "Top-Down Stepwise Refinement ක්‍රමවේදයේදී, ප්‍රධාන කාර්යය කුඩා උප-කාර්යයන් වලට බෙදීමේදී සලකා බැලිය යුතු වැදගත්ම නිර්ණායකය කුමක්ද?",
        options: [
            "එක් එක් උප-කාර්යය තනි, හොඳින් අර්ථ දක්වන ලද කාර්යයක් ඉටු කළ යුතු වීම.",
            "සෑම උප-කාර්යයකම කේත රේඛා සමාන සංඛ්‍යාවක් තිබිය යුතු වීම.",
            "සියලුම උප-කාර්යයන් එකවර ක්‍රියාත්මක විය යුතු වීම.",
            "උප-කාර්යයන් අතර හැකි තරම් දත්ත හුවමාරුවක් තිබිය යුතු වීම.",
            "සෑම උප-කාර්යයක්ම වෙනස් ක්‍රමලේඛන භාෂාවකින් ලිවිය යුතු වීම."
        ],
        correctAnswerIndex: 0,
        explanation: "Top-Down Stepwise Refinement ක්‍රමවේදයේදී, ප්‍රධාන කාර්යයක් උප-කාර්යයන් වලට බෙදීමේදී, එක් එක් උප-කාර්යය තනි, හොඳින් අර්ථ දක්වන ලද (well-defined) කාර්යයක් ඉටු කිරීම ඉතා වැදගත් වේ. මෙය මොඩියුලවල නිරවද්‍යතාවය (cohesion) වැඩි කරන අතර, වැඩසටහනේ පැහැදිලිකම සහ නඩත්තු කිරීමේ හැකියාව වැඩි කරයි."
    },
    {
        questionText: "මොඩියුලකරණය මෘදුකාංග සංවර්ධන ක්‍රියාවලියට දායක වන ආකාරය කුමක්ද?",
        options: [
            "සංකීර්ණ ව්‍යාපෘති කළමනාකරණය පහසු කරමින් සහ නැවත භාවිතා කළ හැකි කේත කොටස් නිර්මාණය කිරීමෙන්.",
            "මෘදුකාංගය සඳහා අවශ්‍ය දෘඪාංග සම්පත් ප්‍රමාණය අඩු කිරීමෙන්.",
            "සියලුම වැඩසටහන් ස්වයංක්‍රීයව ක්‍රියාත්මක කිරීමෙන්.",
            "වැඩසටහන් කේත ලිවීමේ අවශ්‍යතාවය සම්පූර්ණයෙන්ම ඉවත් කිරීමෙන්.",
            "මෘදුකාංගයේ බලශක්ති පරිභෝජනය අඩු කිරීමෙන්."
        ],
        correctAnswerIndex: 0,
        explanation: "මොඩියුලකරණය මඟින් සංකීර්ණ මෘදුකාංග ව්‍යාපෘති කුඩා, කළමනාකරණය කළ හැකි කොටස් වලට බෙදා, ඒවා වෙන වෙනම සංවර්ධනය කිරීමට සහ පරීක්ෂා කිරීමට පහසුකම් සලසයි. එමෙන්ම, හොඳින් සැලසුම් කළ මොඩියුල නැවත භාවිතා කළ හැකි බැවින්, සංවර්ධන කාලය හා පිරිවැය අඩු වේ."
    },
    {
        questionText: "ව්‍යුහ සටහනක, මොඩියුලයක් ඇතුළත තීරණ ගැනීමක් සිදුවන බව පෙන්වීමට, නමුත් එය බාහිර මොඩියුලයකට බලපෑමක් නොකරන විට එය නිරූපණය කරන්නේ කෙසේද?",
        options: [
            "මොඩියුලයේ නමට යාබදව කුඩා දියමන්තියක් (diamond) හෝ ධජයක් (flag) තැබීමෙන්.",
            "මොඩියුලයේ වර්ණය වෙනස් කිරීමෙන්.",
            "මොඩියුලයට දත්ත ඊතලයක් පමණක් ඇඳීමෙන්.",
            "කිසිදු විශේෂ සංකේතයක් නොමැතිව තැබීමෙන්.",
            "මොඩියුලයේ ප්‍රමාණය වැඩි කිරීමෙන්."
        ],
        correctAnswerIndex: 0,
        explanation: "ව්‍යුහ සටහන් වල, මොඩියුලයක් තුළ තීරණයක් ගෙන, එහි ප්‍රතිඵලයක් ලෙස උප-මොඩියුල කැඳවන්නේ නම්, මෙය පාලන ධජයක් (control flag) හෝ කුඩා දියමන්ති සංකේතයක් මඟින් නිරූපණය කළ හැක. මෙය පාලන යුග්මනය (control coupling) නිරූපණය කරන ආකාරයකි."
    },
    {
        questionText: "Top-Down Stepwise Refinement ක්‍රමවේදයේ එක් අදියරකදී, වැඩසටහනක ප්‍රධාන 'input' සහ 'output' කාර්යයන් හඳුනා ගන්නේ නම්, මෙය ප්‍රධාන වශයෙන් කුමන පියවරට අදාළ වේද?",
        options: [
            "ඉහළම මට්ටමේ සැලසුම් කිරීමේ (high-level design) පියවරට.",
            "කේතකරණයේ (coding) පියවරට.",
            "දෝෂ නිවැරදි කිරීමේ (debugging) පියවරට.",
            "පද්ධති පරීක්ෂණයේ (system testing) පියවරට.",
            "නඩත්තු කිරීමේ (maintenance) පියවරට."
        ],
        correctAnswerIndex: 0,
        explanation: "Top-Down Stepwise Refinement හිදී, ඉහළම මට්ටමේ සැලසුම් කිරීමේ පියවරෙහිදී පද්ධතියේ සමස්ත ක්‍රියාකාරීත්වය, ප්‍රධාන ආදාන (inputs) සහ ප්‍රතිදාන (outputs) හඳුනා ගනු ලැබේ. මෙහිදී තවමත් කේතකරණය හෝ සවිස්තරාත්මක ඇල්ගොරිතම සැලසුම් කිරීම සිදු නොවේ."
    },
    {
        questionText: "මොඩියුලකරණය මඟින් කණ්ඩායම් වැඩ සඳහා පහසුකම් සලසන්නේ කෙසේද?",
        options: [
            "සෑම කණ්ඩායම් සාමාජිකයෙකුටම වෙනස් මොඩියුලයක් මත ස්වාධීනව වැඩ කිරීමට හැකි වන බැවින්.",
            "එකම කණ්ඩායම් සාමාජිකයෙකුට මුළු වැඩසටහනම තනිවම ලිවීමට සිදුවන බැවින්.",
            "සියලුම කණ්ඩායම් සාමාජිකයන් එකම වේලාවක එකම කේත කොටස මත වැඩ කළ යුතු බැවින්.",
            "කණ්ඩායම් සාමාජිකයන් අතර තරඟකාරිත්වය වැඩි කරන බැවින්.",
            "කණ්ඩායම් සාමාජිකයන් අතර සන්නිවේදනය සම්පූර්ණයෙන්ම ඉවත් කරන බැවින්."
        ],
        correctAnswerIndex: 0,
        explanation: "මොඩියුලකරණය මඟින් මුළු පද්ධතියම කුඩා, ස්වාධීන මොඩියුල වලට වෙන් කරයි. මෙය සංවර්ධන කණ්ඩායමකට එක් එක් මොඩියුලය වෙන වෙනම සාමාජිකයන්ට පැවරීමට ඉඩ සලසයි. එමඟින් සමාන්තර සංවර්ධනයට (parallel development) අවස්ථාව ලැබෙන අතර, කණ්ඩායම් වැඩ වඩාත් කාර්යක්ෂම වේ."
    },
    {
        questionText: "Top-Down Stepwise Refinement ක්‍රමවේදයේදී 'abstract' මට්ටමේ සිට 'concrete' මට්ටම දක්වා ගමන් කිරීම යන්නෙන් අදහස් කරන්නේ කුමක්ද?",
        options: [
            "සාමාන්‍ය, ඉහළ මට්ටමේ අදහස් වලින් ආරම්භ වී ක්‍රමයෙන් සවිස්තරාත්මක, ක්‍රියාත්මක කළ හැකි විසඳුම් වෙත ගමන් කිරීම.",
            "කිසිදු දත්තයක් නොමැතිව කේත ලිවීමෙන් ආරම්භ වී ක්‍රමයෙන් දත්ත එකතු කිරීම.",
            "විසඳුමෙහි ආරක්ෂක පද්ධති පමණක් සැලසුම් කර, පසුව අනෙකුත් අංග එකතු කිරීම.",
            "දෘඪාංග පිළිබඳ සැලසුම් කිරීමෙන් ආරම්භ වී, පසුව මෘදුකාංග වෙත ගමන් කිරීම.",
            "විසඳුමෙහි පිරිවැය තක්සේරු කිරීමෙන් ආරම්භ වී, පසුව තාක්ෂණික විස්තර වෙත ගමන් කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "Top-Down Stepwise Refinement ක්‍රමවේදය abstract (වියුක්ත) මට්ටමේ සිට concrete (සවිස්තරාත්මක) මට්ටම දක්වා ගමන් කරයි. එය පද්ධතියක සමස්ත ක්‍රියාකාරීත්වය වැනි ඉහළ මට්ටමේ, සාමාන්‍ය අදහස් වලින් ආරම්භ වී, ක්‍රමයෙන් එම අදහස් කුඩා, වඩාත් සවිස්තරාත්මක සහ ක්‍රියාත්මක කළ හැකි කොටස් වලට (මොඩියුල) වෙන් කරයි."
    },
    {
        questionText: "Top-Down Design හි එක් අදියරකදී ගැටලුව 'ඉහළ මට්ටමේ සාරාංශයක්' (high-level summary) ලෙස නිරූපණය කරන්නේ නම්, ඊළඟ පියවරේදී සිදුවිය යුත්තේ කුමක්ද?",
        options: [
            "සාරාංශයේ එක් එක් කොටස වඩාත් සවිස්තරාත්මක උප-සාරාංශ (sub-summaries) බවට පිරිපහදු කිරීම.",
            "සාරාංශය සම්පූර්ණයෙන්ම ප්‍රතික්ෂේප කර නව ගැටලුවක් සෙවීම.",
            "සාරාංශය සැබෑ කේත බවට පරිවර්තනය කිරීම.",
            "සාරාංශයට අදාළ දත්ත විශ්ලේෂණය ආරම්භ කිරීම.",
            "සාරාංශයේ නිරවද්‍යතාවය පිළිබඳව පරිශීලක අදහස් ලබා ගැනීම."
        ],
        correctAnswerIndex: 0,
        explanation: "Top-Down Design ක්‍රමවේදයේදී, ගැටලුවක් ඉහළ මට්ටමේ සාරාංශයක් ලෙස නිරූපණය කිරීමෙන් පසු, ඊළඟ පියවර වන්නේ එම සාරාංශයේ එක් එක් ප්‍රධාන කොටස (මොඩියුලය) වඩාත් සවිස්තරාත්මක උප-සාරාංශ හෝ උප-මොඩියුල බවට 'පිරිපහදු කිරීම'යි. මෙය ක්‍රමයෙන් ගැටලුවේ ගැඹුරට ගමන් කිරීමේ ක්‍රියාවලියයි."
    },
    {
        questionText: "මොඩියුලකරණය සහ Stepwise Refinement යන සංකල්ප දෙකම මෘදුකාංග සංවර්ධනයේදී වැදගත් වන්නේ ඇයි?",
        options: [
            "සංකීර්ණත්වය කළමනාකරණය කිරීමට සහ පද්ධතිමය සැලසුම් හැකියාව වැඩි දියුණු කිරීමට.",
            "කේතකරණයට කිසිදු සැලසුමක් අවශ්‍ය නොවන බවට සහතික වීමට.",
            "විසඳුමක් සඳහා අවශ්‍ය සියලුම සම්පත් එකවර සපයා ගැනීමට.",
            "වැඩසටහන් කේතය ස්වයංක්‍රීයව දෝෂ රහිත බවට පත් කිරීමට.",
            "පරිගණක පද්ධති වල මතක පරිභෝජනය අඩු කිරීමට."
        ],
        correctAnswerIndex: 0,
        explanation: "මොඩියුලකරණය (Modularization) සහ Stepwise Refinement යන දෙකම මෘදුකාංග සංවර්ධනයේදී සංකීර්ණත්වය කළමනාකරණය කිරීම සඳහා අත්‍යවශ්‍ය සංකල්ප වේ. මොඩියුලකරණය මඟින් පද්ධතිය කොටස් වලට බෙදන අතර, Stepwise Refinement මඟින් එම කොටස් ක්‍රමයෙන් සවිස්තරාත්මක කරයි. මේ දෙකම එක්ව පද්ධතිමය සැලසුම් හැකියාව වැඩි දියුණු කරයි."
    },
    {
        questionText: "ව්‍යුහ සටහන් (Structure Charts) භාවිතා කිරීමේදී, එක් මොඩියුලයකින් තවත් මොඩියුලයකට දත්ත ගලා යාම පෙන්වීමෙන් ලැබෙන ප්‍රධාන වාසිය කුමක්ද?",
        options: [
            "මොඩියුල අතර පරායත්තතාවයේ මට්ටම අවබෝධ කර ගැනීමට උපකාරී වීම.",
            "වැඩසටහනෙහි ක්‍රියාත්මක කිරීමේ වේගය ගණනය කිරීමට හැකි වීම.",
            "වැඩසටහනේ අවසන් කේත ප්‍රමාණය තීරණය කිරීමට හැකි වීම.",
            "පරිශීලක අතුරු මුහුණතේ සැලසුම වඩාත් ආකර්ශනීය කිරීමට හැකි වීම.",
            "මොඩියුලයන්ට අවශ්‍ය දෘඪාංග සම්පත් තක්සේරු කිරීමට හැකි වීම."
        ],
        correctAnswerIndex: 0,
        explanation: "ව්‍යුහ සටහන් වල දත්ත ප්‍රවාහය (data flow) පෙන්වීමෙන්, මොඩියුල අතර ඇති පරායත්තතාවයේ මට්ටම හෙවත් යුග්මනය (coupling) අවබෝධ කර ගැනීමට උපකාරී වේ. හොඳ සැලසුමක් යනු අඩු යුග්මනයක් සහිත (low coupling) මොඩියුල වන අතර, එමඟින් වැඩසටහන වඩාත් නම්‍යශීලී සහ නඩත්තු කිරීමට පහසු වේ."
    },

    // 9.3 ගැටලු විසඳීම සඳහා ඇල්ගෝරිතමික ප්‍රවේශය යොදා ගනී (Algorithmic Approach)
    {
        questionText: "ඇල්ගොරිතමයක් (Algorithm) යනු කුමක්ද?",
        options: [
            "යම්කිසි ගැටලුවක් විසඳීම සඳහා පියවරෙන් පියවර විස්තර කරන ලද ක්‍රමවේද මාලාවක්.",
            "පරිගණක භාෂාවකින් ලියා ඇති කේත කොටසක්.",
            "දත්ත ගබඩාවක් නිර්මාණය කිරීම සඳහා වන සැලසුමක්.",
            "පරිශීලක අතුරු මුහුණතක් සැලසුම් කිරීම සඳහා වන උපදෙස් මාලාවක්.",
            "පරිගණක ජාලයක දත්ත සංකේතනය කිරීමේ ක්‍රමවේදයක්."
        ],
        correctAnswerIndex: 0,
        explanation: "ඇල්ගොරිතමයක් යනු යම්කිසි ගැටලුවක් විසඳීම සඳහා හෝ යම් කාර්යයක් ඉටු කිරීම සඳහා පියවරෙන් පියවර විස්තර කරන ලද, පැහැදිලි, නිශ්චිත සහ සීමිත පියවර මාලාවකි. එය ක්‍රමලේඛන භාෂාවකින් ස්වාධීන වන අතර, ඕනෑම භාෂාවකින් ක්‍රියාත්මක කළ හැක."
    },
    {
        questionText: "ගැලීම් සටහනක් (Flowchart) ඇඳීමට භාවිතා කරන 'දියමන්ති' (Diamond) හැඩයේ සංකේතය මඟින් නිරූපණය කරන්නේ කුමක්ද?",
        options: [
            "තීරණයක් ගැනීම හෝ කොන්දේසියක් පරීක්ෂා කිරීම.",
            "ක්‍රියාවලියක ආරම්භය හෝ අවසානය.",
            "දත්ත ආදානය හෝ ප්‍රතිදානය.",
            "ක්‍රියාවලියක් හෝ ගණනය කිරීමක්.",
            "නැවත නැවත සිදුවන ක්‍රියාවලියක්."
        ],
        correctAnswerIndex: 0,
        explanation: "ගැලීම් සටහනක දියමන්ති (Diamond) හැඩයේ සංකේතය මඟින් තීරණ ගැනීමේ ලක්ෂ්‍යයක් (Decision Point) හෝ කොන්දේසියක් (Condition) පරීක්ෂා කිරීමක් නිරූපණය කරයි. මෙම ලක්ෂ්‍යයෙන් විකල්ප මාර්ග දෙකක් හෝ වැඩි ගණනක් බිහි විය හැක."
    },
    {
        questionText: "ව්‍යාජ කේතයක් (Pseudo Code) ලිවීමේ ප්‍රධාන වාසිය කුමක්ද?",
        options: [
            "කිසිදු විශේෂිත ක්‍රමලේඛන භාෂාවක් භාවිතා නොකර, ඇල්ගොරිතමයක් සරලව හා පැහැදිලිව විස්තර කිරීමට හැකි වීම.",
            "පරිගණකයක ස්වයංක්‍රීයව ක්‍රියාත්මක කළ හැකි කේතයක් නිර්මාණය කිරීම.",
            "දත්ත ගබඩාවක සංකීර්ණ විමසුම් ලිවීම.",
            "ජාල ප්‍රොටෝකෝල (network protocols) සැලසුම් කිරීම.",
            "ග්‍රැෆික් පරිශීලක අතුරු මුහුණත් (GUI) නිර්මාණය කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "ව්‍යාජ කේතය යනු ඇල්ගොරිතමයක් විස්තර කිරීම සඳහා භාවිතා කරන සරල, ස්වාභාවික භාෂාවට සමාන, නමුත් ක්‍රමලේඛන ව්‍යුහයන් (if-else, loops) අඩංගු නිරූපණයකි. එහි ප්‍රධාන වාසිය වන්නේ කිසිදු විශේෂිත ක්‍රමලේඛන භාෂාවක් පිළිබඳ දැනුමක් නොමැතිව වුවද ඇල්ගොරිතමයක් පැහැදිලිව ඉදිරිපත් කිරීමට හැකි වීමයි."
    },
    {
        questionText: "හස්තානුලේඛනයක් (Hand Trace) භාවිතා කරන්නේ කුමන අරමුණක් සඳහාද?",
        options: [
            "ඇල්ගොරිතමයක් හෝ කේත කොටසක් නිවැරදිව ක්‍රියාත්මක වේදැයි අතින් පරීක්ෂා කිරීම සඳහා.",
            "වැඩසටහනකට අවශ්‍ය දෘඪාංග සම්පත් ප්‍රමාණය ගණනය කිරීම සඳහා.",
            "පරිශීලක අතුරු මුහුණතේ සැලසුම ඇගයීම සඳහා.",
            "දත්ත ගබඩාවක කාර්ය සාධනය විශ්ලේෂණය කිරීම සඳහා.",
            "අනාගත මෘදුකාංග සංවර්ධන ප්‍රවණතා පුරෝකථනය කිරීම සඳහා."
        ],
        correctAnswerIndex: 0,
        explanation: "හස්තානුලේඛනය (Hand Trace) යනු ඇල්ගොරිතමයක් හෝ කුඩා කේත කොටසක්, විවිධ විචල්‍යයන්ගේ (variables) අගයන් පියවරෙන් පියවර වෙනස් වන ආකාරය සටහන් කරමින්, අතින් ක්‍රියාත්මක කර පරීක්ෂා කිරීමේ ක්‍රමවේදයකි. මෙය ඇල්ගොරිතමයක තර්කනය තේරුම් ගැනීමට සහ දෝෂ හඳුනා ගැනීමට උපකාරී වේ."
    },
    {
        questionText: "ගැලීම් සටහනක 'සමාන්තර චතුරස්‍රය' (Parallelogram) මඟින් නිරූපණය කරන සම්මත සංකේතය කුමක් සඳහාද?",
        options: [
            "දත්ත ආදානය (Input) හෝ ප්‍රතිදානය (Output).",
            "ක්‍රියාවලියක ආරම්භය හෝ අවසානය.",
            "තීරණයක් ගැනීම හෝ කොන්දේසියක් පරීක්ෂා කිරීම.",
            "ක්‍රියාවලියක් හෝ ගණනය කිරීමක්.",
            "වෙනත් ගැලීම් සටහනකට සම්බන්ධ වීම."
        ],
        correctAnswerIndex: 0,
        explanation: "ගැලීම් සටහනක සමාන්තර චතුරස්‍රය (Parallelogram) ආදාන (Input) හෝ ප්‍රතිදාන (Output) මෙහෙයුම් නිරූපණය කිරීමට භාවිතා කරයි. උදාහරණයක් ලෙස, යතුරු පුවරුවෙන් දත්ත ලබා ගැනීම හෝ තිරය මත ප්‍රතිඵල පෙන්වීම මෙයින් නිරූපණය කළ හැක."
    },
    {
        questionText: "ඇල්ගොරිතමයක් සඳහා තිබිය යුතු අත්‍යවශ්‍ය ලක්ෂණයක් නොවන කරුණ කුමක්ද?",
        options: [
            "යම්කිසි ක්‍රමලේඛන භාෂාවකින් ලියා තිබීම.",
            "නිශ්චිත භාවය (Definiteness): සෑම පියවරක්ම පැහැදිලි විය යුතුයි.",
            "සීමිත භාවය (Finiteness): සීමිත පියවර ගණනකින් අවසන් විය යුතුයි.",
            "ආදානය (Input): බිංදුවක් හෝ වැඩි ගණනක් තිබිය හැක.",
            "ප්‍රතිදානය (Output): අවම වශයෙන් එක් ප්‍රතිදානයක් හෝ තිබිය යුතුයි."
        ],
        correctAnswerIndex: 0,
        explanation: "ඇල්ගොරිතමයක් යනු ක්‍රමලේඛන භාෂාවකින් ස්වාධීන සංකල්පයකි. එය කේතයක් ලෙස ලිවීමට පෙර ගැටලුවට විසඳුම සටහන් කිරීමකි. එම නිසා, යම්කිසි ක්‍රමලේඛන භාෂාවකින් ලියා තිබීම ඇල්ගොරිතමයක අත්‍යවශ්‍ය ලක්ෂණයක් නොවේ."
    },
    {
        questionText: "ව්‍යාජ කේතයක් (Pseudo Code) භාවිතා කිරීමෙන් වැඩසටහන් සංවර්ධන ක්‍රියාවලියට ලැබෙන ප්‍රධාන වාසිය කුමක්ද?",
        options: [
            "ක්‍රමලේඛකයන්ට ඇල්ගොරිතමය කේත බවට පරිවර්තනය කිරීමට පෙර එහි තර්කනය පහසුවෙන් තේරුම් ගැනීමට ඉඩ සැලසීම.",
            "වැඩසටහනෙහි දෝෂ ස්වයංක්‍රීයව නිවැරදි කිරීම.",
            "වැඩසටහනෙහි ක්‍රියාත්මක කිරීමේ වේගය වැඩි කිරීම.",
            "පරිගණක පද්ධතියක දෘඪාංග අවශ්‍යතා අවම කිරීම.",
            "වැඩසටහනට අවශ්‍ය මතක ප්‍රමාණය ගණනය කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "ව්‍යාජ කේතය (Pseudo Code) ක්‍රමලේඛන භාෂාවකට පෙර ඇල්ගොරිතමයක තර්කනය පැහැදිලිව විස්තර කිරීමට උපකාරී වේ. මෙය ක්‍රමලේඛකයන්ට කේතකරණය ආරම්භ කිරීමට පෙර ඇල්ගොරිතමය නිවැරදිව තේරුම් ගැනීමට සහ එහි ඇති දෝෂ හඳුනා ගැනීමට අවස්ථාවක් සපයයි."
    },
    {
        questionText: "ගැලීම් සටහනක 'ඕවලාකාර' (Oval) හැඩයේ සංකේතය මඟින් නිරූපණය කරන්නේ කුමක්ද?",
        options: [
            "ක්‍රියාවලියක ආරම්භය (Start) හෝ අවසානය (End).",
            "දත්ත ආදානය හෝ ප්‍රතිදානය.",
            "තීරණයක් ගැනීම හෝ කොන්දේසියක් පරීක්ෂා කිරීම.",
            "ක්‍රියාවලියක් හෝ ගණනය කිරීමක්.",
            "වෙනත් ගැලීම් සටහනකට සම්බන්ධ වීම."
        ],
        correctAnswerIndex: 0,
        explanation: "ගැලීම් සටහනක ඕවලාකාර (Oval) හැඩයේ සංකේතය මඟින් ක්‍රියාවලියක ආරම්භය (Start) හෝ අවසානය (End) නිරූපණය කරයි. මෙය 'Terminator' සංකේතය ලෙසද හඳුන්වනු ලැබේ."
    },
    {
        questionText: "පහත සඳහන් දේවලින් හස්තානුලේඛනයක් (Hand Trace) සඳහා අත්‍යවශ්‍ය නොවන කරුණ කුමක්ද?",
        options: [
            "සැබෑ පරිගණකයක් හෝ IDE එකක්.",
            "ඇල්ගොරිතමය හෝ කේතය.",
            "විචල්‍යයන්ගේ අගයන් සටහන් කිරීමට වගුවක්.",
            "පරීක්ෂණ දත්ත (test data).",
            "ඇල්ගොරිතමය ක්‍රියාත්මක වන ආකාරය පිළිබඳ අවබෝධය."
        ],
        correctAnswerIndex: 0,
        explanation: "හස්තානුලේඛනයක් යනු ඇල්ගොරිතමයක් අතින් පරීක්ෂා කිරීමේ ක්‍රමවේදයකි. එයට සැබෑ පරිගණකයක් හෝ Integrated Development Environment (IDE) එකක් අවශ්‍ය නොවේ. එය සිදු කරනු ලබන්නේ කඩදාසි සහ පැන්සලක් වැනි සරල මෙවලම් භාවිතා කරමිනි."
    },
    {
        questionText: "ඇල්ගොරිතමයක් සැලසුම් කිරීමේදී, 'තීරණ' (Decisions) සහ 'පුනරාවර්තන' (Iterations/Loops) වැනි පාලන ව්‍යුහයන් (Control Structures) ඇතුළත් කිරීමේ අරමුණ කුමක්ද?",
        options: [
            "ගැටලුවට නිශ්චිත කොන්දේසි මත පදනම්ව විවිධ මාර්ග ඔස්සේ විසඳුම් ලබා දීම සහ ක්‍රියාවලීන් නැවත නැවත සිදු කිරීමට හැකි කිරීම.",
            "ඇල්ගොරිතමයේ කේත ප්‍රමාණය අවම කිරීම.",
            "ඇල්ගොරිතමය පරිගණකයක ස්වයංක්‍රීයව ක්‍රියාත්මක කිරීම.",
            "දත්ත ගබඩාවක් සමඟ ඇල්ගොරිතමය සම්බන්ධ කිරීම.",
            "ඇල්ගොරිතමය සඳහා අවශ්‍ය මතක ප්‍රමාණය අඩු කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "තීරණ (Decisions) ව්‍යුහයන් (උදා: if-else) මඟින් ඇල්ගොරිතමයකට කොන්දේසි මත පදනම්ව විවිධ ක්‍රියාමාර්ග ගැනීමට ඉඩ සලසයි. පුනරාවර්තන (Iterations/Loops) ව්‍යුහයන් (උදා: for, while) මඟින් යම් ක්‍රියාවලියක් නිශ්චිත වාර ගණනක් හෝ කොන්දේසියක් සපුරන තුරු නැවත නැවත සිදු කිරීමට හැකි කරයි. මේවා ඇල්ගොරිතමවල කාර්යක්ෂමතාව සහ නම්‍යශීලී බව වැඩි දියුණු කරයි."
    },
    {
        questionText: "දෙන ලද ගැටලුවකට විසඳුම් පැහැදිලි කිරීමට ගැලීම් සටහන් ඇඳීමෙන් ලැබෙන ප්‍රධාන වාසිය කුමක්ද?",
        options: [
            "ඇල්ගොරිතමය දෘශ්‍යමය (visual) ආකාරයකින් පැහැදිලිව නිරූපණය කිරීමට හැකි වීම.",
            "ගැටලුව සඳහා අවශ්‍ය කේත ප්‍රමාණය අඩු කිරීම.",
            "විසඳුමේ ආරක්ෂක අවදානම් හඳුනා ගැනීම.",
            "වැඩසටහනෙහි වේගය වැඩි කිරීම.",
            "දත්ත ගබඩාවේ ව්‍යුහය නිර්මාණය කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "ගැලීම් සටහන් (Flowcharts) ඇල්ගොරිතමයක තර්කනය සහ පාලන ප්‍රවාහය (control flow) දෘශ්‍යමය වශයෙන් පැහැදිලිව නිරූපණය කරයි. මෙය ඇල්ගොරිතමය තේරුම් ගැනීමට සහ එහි ඇති දෝෂ හඳුනා ගැනීමට ක්‍රමලේඛකයන්ට සහ අනෙකුත් පාර්ශවකරුවන්ට පහසුකම් සලසයි."
    },
    {
        questionText: "ඇල්ගොරිතමයක් ලිවීමේදී 'පැහැදිලි භාවය' (Clarity) යන්නෙන් අදහස් කරන්නේ කුමක්ද?",
        options: [
            "සෑම පියවරක්ම අපැහැදිලි නොවන පරිදි, එක් අර්ථයක් පමණක් දෙන ආකාරයට පැහැදිලිව අර්ථ දක්වා තිබීම.",
            "ඇල්ගොරිතමය කෙටි හා සරල වචන වලින් ලියා තිබීම.",
            "ඇල්ගොරිතමය පරිගණකයක ස්වයංක්‍රීයව ක්‍රියාත්මක විය හැකි වීම.",
            "ඇල්ගොරිතමයට කිසිදු ආදානයක් අවශ්‍ය නොවීම.",
            "ඇල්ගොරිතමය ලිවීම සඳහා කිසිදු ක්‍රමලේඛන භාෂාවක් භාවිතා නොකිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "ඇල්ගොරිතමයක 'පැහැදිලි භාවය' (Clarity) යනු එහි සෑම පියවරක්ම පැහැදිලිව, අපැහැදිලි නොවන පරිදි, සහ එක් අර්ථයක් පමණක් දෙන ආකාරයට අර්ථ දක්වා තිබීමයි. මෙය ඇල්ගොරිතමය කියවන ඕනෑම කෙනෙකුට එය නිවැරදිව තේරුම් ගැනීමට සහ ක්‍රියාත්මක කිරීමට උපකාරී වේ."
    },
    {
        questionText: "ගැලීම් සටහනක 'සෘජුකෝණාස්‍රය' (Rectangle) හැඩයේ සංකේතය මඟින් නිරූපණය කරන්නේ කුමක්ද?",
        options: [
            "ක්‍රියාවලියක් (Process) හෝ ගණනය කිරීමක් (Calculation).",
            "ක්‍රියාවලියක ආරම්භය හෝ අවසානය.",
            "දත්ත ආදානය හෝ ප්‍රතිදානය.",
            "තීරණයක් ගැනීම හෝ කොන්දේසියක් පරීක්ෂා කිරීම.",
            "ක්‍රියාවලියක් තුළ පුනරාවර්තනයක්."
        ],
        correctAnswerIndex: 0,
        explanation: "ගැලීම් සටහනක සෘජුකෝණාස්‍රය (Rectangle) හැඩයේ සංකේතය මඟින් ක්‍රියාවලියක් (Process) හෝ ගණනය කිරීමක් (Calculation) නිරූපණය කරයි. උදාහරණයක් ලෙස, විචල්‍යයකට අගයක් පැවරීම, ගණිතමය ක්‍රියාවක් සිදු කිරීම, හෝ දත්ත සැකසීමක් මෙයින් නිරූපණය කළ හැක."
    },
    {
        questionText: "ව්‍යාජ කේතය (Pseudo Code) සහ සැබෑ ක්‍රමලේඛන භාෂාවක් අතර ඇති ප්‍රධාන වෙනස කුමක්ද?",
        options: [
            "ව්‍යාජ කේතය පරිගණකයක ක්‍රියාත්මක කළ නොහැකි අතර, සැබෑ ක්‍රමලේඛන භාෂාවක් ක්‍රියාත්මක කළ හැක.",
            "ව්‍යාජ කේතය දෝෂ රහිත වන අතර, සැබෑ ක්‍රමලේඛන භාෂාවක දෝෂ තිබිය හැක.",
            "ව්‍යාජ කේතය අමාරු වන අතර, සැබෑ ක්‍රමලේඛන භාෂාවක් පහසුය.",
            "ව්‍යාජ කේතය ග්‍රැෆික් පරිශීලක අතුරු මුහුණත් නිර්මාණයට භාවිතා කරන අතර, සැබෑ භාෂා එසේ නොවේ.",
            "ව්‍යාජ කේතය දත්ත ගබඩා කළමනාකරණයට භාවිතා කරන අතර, සැබෑ භාෂා එසේ නොවේ."
        ],
        correctAnswerIndex: 0,
        explanation: "ව්‍යාජ කේතය යනු ඇල්ගොරිතමයක තර්කනය විස්තර කිරීම සඳහා භාවිතා කරන මිනිසුන්ට තේරුම් ගත හැකි, ක්‍රමලේඛන භාෂාවකින් ස්වාධීන නිරූපණයකි. එය පරිගණකයක සෘජුවම ක්‍රියාත්මක කළ නොහැක. සැබෑ ක්‍රමලේඛන භාෂාවක් යනු පරිගණකයක ක්‍රියාත්මක කළ හැකි, නිශ්චිත ව්‍යාකරණ රීති (syntax) සහිත කේතයකි."
    },
    {
        questionText: "හස්තානුලේඛනයක් සිදු කිරීමෙන් ලැබෙන මූලික වාසියක් වන්නේ කුමක්ද?",
        options: [
            "ඇල්ගොරිතමයක තර්කනය ක්‍රියාත්මක වන ආකාරය පිළිබඳව ගැඹුරු අවබෝධයක් ලබා ගැනීම.",
            "වැඩසටහනක අවසාන ප්‍රතිඵලය ස්වයංක්‍රීයව ගණනය කිරීම.",
            "වැඩසටහනට අවශ්‍ය මතක ප්‍රමාණය ප්‍රශස්තකරණය කිරීම.",
            "වැඩසටහනෙහි වේගය වැඩි දියුණු කිරීම.",
            "දත්ත ගබඩාවක දත්ත ආකෘතිය නිර්මාණය කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "හස්තානුලේඛනයක් (Hand Trace) සිදු කිරීමෙන් ඇල්ගොරිතමයක පියවරෙන් පියවර ක්‍රියාත්මක වන ආකාරය සහ විචල්‍යයන්ගේ අගයන් වෙනස් වන ආකාරය පැහැදිලිව දැකගත හැක. මෙය ඇල්ගොරිතමයේ තර්කනය පිළිබඳව ගැඹුරු අවබෝධයක් ලබා ගැනීමටත්, එහි ඇති තාර්කික දෝෂ (logical errors) හඳුනා ගැනීමටත් උපකාරී වේ."
    },
    {
        questionText: "ගැලීම් සටහනක විවිධ කොටස් අතර සම්බන්ධතා පෙන්වීමට භාවිතා කරන්නේ කුමක්ද?",
        options: [
            "ඊතල සහිත රේඛා (Arrows/Flowlines).",
            "ඝන කව (Solid circles).",
            "තරු ලකුණු (Asterisks).",
            "පෙළ විවරණ (Text annotations).",
            "චතුරස්‍රාකාර කොටු (Square boxes)."
        ],
        correctAnswerIndex: 0,
        explanation: "ගැලීම් සටහනක විවිධ සංකේත (ක්‍රියාවලීන්, තීරණ, ආදාන/ප්‍රතිදාන) අතර සම්බන්ධතා සහ පාලන ප්‍රවාහය (control flow) පෙන්වීම සඳහා ඊතල සහිත රේඛා (Flowlines) භාවිතා කරයි. මෙම ඊතල මඟින් ක්‍රියාවලිය ගලා යන දිශාව පෙන්නුම් කරයි."
    },
    {
        questionText: "ඇල්ගොරිතමයක් සරලව හා කෙටියෙන් පැහැදිලි කිරීමේ ප්‍රධාන අරමුණ කුමක්ද?",
        options: [
            "ගැටලුවට විසඳුම කේත බවට පරිවර්තනය කිරීමට පෙර එහි මූලික තර්කනය පහසුවෙන් සන්නිවේදනය කිරීමට.",
            "ඇල්ගොරිතමය පරිගණකයක වේගයෙන් ක්‍රියාත්මක කිරීමට හැකි වීම.",
            "ඇල්ගොරිතමයට කිසිදු ආදානයක් අවශ්‍ය නොවන බවට සහතික වීම.",
            "ඇල්ගොරිතමය නිර්මාණය කිරීමේ පිරිවැය අඩු කිරීම.",
            "ඇල්ගොරිතමය සඳහා අනුමත මතක ප්‍රමාණය තීරණය කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "ඇල්ගොරිතමයක් සරලව හා කෙටියෙන් පැහැදිලි කිරීමේ ප්‍රධාන අරමුණ වන්නේ කේතකරණය ආරම්භ කිරීමට පෙර, එහි මූලික තර්කනය සහ ක්‍රියාකාරීත්වය, ක්‍රමලේඛකයන්ට සහ අනෙකුත් පාර්ශවකරුවන්ට පහසුවෙන් තේරුම් ගැනීමට සහ සන්නිවේදනය කිරීමට හැකි කිරීමයි."
    },
    {
        questionText: "හස්තානුලේඛනයක් (Hand Trace) භාවිතා කිරීමෙන් දෝෂ නිවැරදි කිරීමේ ක්‍රියාවලියට ලැබෙන ප්‍රධාන වාසිය කුමක්ද?",
        options: [
            "තාර්කික දෝෂ (logical errors) හඳුනා ගැනීමට සහ ඒවා නිවැරදි කිරීමට පෙර අවබෝධ කර ගැනීමට හැකි වීම.",
            "ව්‍යාකරණ දෝෂ (syntax errors) ස්වයංක්‍රීයව නිවැරදි කිරීම.",
            "වැඩසටහනේ ක්‍රියාත්මක කිරීමේ වේගය මැන බැලීම.",
            "වැඩසටහනට අවශ්‍ය මතක ප්‍රමාණය අඩු කිරීම.",
            "වැඩසටහනක් පරිවර්තනය කිරීමට අවශ්‍ය කාලය ගණනය කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "හස්තානුලේඛනය මඟින් වැඩසටහනක් පියවරෙන් පියවර අතින් ක්‍රියාත්මක කරන බැවින්, එය තාර්කික දෝෂ (logical errors) හඳුනා ගැනීමට ඉතා ප්‍රයෝජනවත් වේ. ව්‍යාකරණ දෝෂ (syntax errors) සාමාන්‍යයෙන් පරිවර්තකයන් (compilers/interpreters) මඟින් හඳුනා ගන්නා අතර, තාර්කික දෝෂයන් වැඩසටහනේ අපේක්ෂිත හැසිරීම සහ සැබෑ හැසිරීම අතර වෙනස හඳුනා ගැනීමෙන් සොයා ගනු ලැබේ."
    },
    {
        questionText: "ගැලීම් සටහනක් (Flowchart) ඇඳීමේදී, පුනරාවර්තනයක් (Loop) නිරූපණය කිරීම සඳහා සාමාන්‍යයෙන් භාවිතා කරන සංකේත මොනවාද?",
        options: [
            "දියමන්තියක් (Decision) සහ ක්‍රියාවලියක් (Process) ඒකාබද්ධව.",
            "ඕවලාකාරයක් (Terminator) පමණක්.",
            "සමාන්තර චතුරස්‍රයක් (Input/Output) පමණක්.",
            "ව්‍යුහ සටහනක (Structure Chart) සංකේත.",
            "ව්‍යාජ කේත (Pseudo Code) ව්‍යුහයන්."
        ],
        correctAnswerIndex: 0,
        explanation: "ගැලීම් සටහනක පුනරාවර්තනයක් (Loop) නිරූපණය කිරීමට, කොන්දේසියක් පරීක්ෂා කිරීම සඳහා දියමන්ති සංකේතයක් (Decision) සහ එම කොන්දේසිය සත්‍ය වන විට නැවත නැවත ක්‍රියාත්මක වන පියවරයන් (Process) සඳහා සෘජුකෝණාස්‍ර සංකේත භාවිතා කරන අතර, ප්‍රවාහ රේඛා (Flowlines) මඟින් පුනරාවර්තන චක්‍රය පෙන්වයි."
    },
    {
        questionText: "ඇල්ගොරිතමයක් සැලසුම් කිරීමේදී 'දත්ත ව්‍යුහයන්' (Data Structures) තෝරා ගැනීම වැදගත් වන්නේ ඇයි?",
        options: [
            "ඇල්ගොරිතමයේ කාර්යක්ෂමතාවයට හා මතක පරිභෝජනයට සෘජුවම බලපාන බැවින්.",
            "ඇල්ගොරිතමය ක්‍රියාත්මක කිරීමට අවශ්‍ය දෘඪාංග වර්ගය තීරණය කරන බැවින්.",
            "ඇල්ගොරිතමය සඳහා අවශ්‍ය පිරිවැය තීරණය කරන බැවින්.",
            "ඇල්ගොරිතමය පරිගණකයක ස්වයංක්‍රීයව ක්‍රියාත්මක කරන බැවින්.",
            "ඇල්ගොරිතමයට කිසිදු ආදානයක් අවශ්‍ය නොවන බවට සහතික වන බැවින්."
        ],
        correctAnswerIndex: 0,
        explanation: "දත්ත ව්‍යුහයන් (Data Structures) තෝරා ගැනීම ඇල්ගොරිතමයක කාර්යක්ෂමතාවයට (Efficiency) සහ මතක පරිභෝජනයට (Memory Usage) සෘජුවම බලපායි. නිවැරදි දත්ත ව්‍යුහය තෝරා ගැනීමෙන් ඇල්ගොරිතමය වඩාත් වේගවත් හා සම්පත් කාර්යක්ෂම කළ හැක."
    },

    // 9.4 ක්‍රමලේඛ පරිවර්තනය කිරීමේ අවශ්‍යතාව සහ ක්‍රමලේඛ පරිවර්තක වර්ග ගවේෂණය කරයි (Programming Paradigms)
    {
        questionText: "පරිගණක භාෂාවන්ගේ පරිණාමය 'පරම්පරාව' (Generation) පදනම් කරගෙන විස්තර කිරීමේදී, පස්වන පරම්පරාවේ (Fifth Generation) ප්‍රධාන ලක්ෂණය කුමක්ද?",
        options: [
            "කෘතිම බුද්ධිය (Artificial Intelligence) සහ ස්වභාවික භාෂා සැකසීම (Natural Language Processing) කෙරෙහි අවධානය යොමු කිරීම.",
            "යන්ත්‍ර භාෂාව (Machine Language) භාවිතය.",
            "එක් එක් උපදෙස් සඳහා mnemonic codes භාවිතය.",
            "ඉහළ මට්ටමේ ක්‍රමලේඛන භාෂා (High-Level Languages) භාවිතය.",
            "වස්තු-නැඹුරු ක්‍රමලේඛනය (Object-Oriented Programming) හඳුන්වා දීම."
        ],
        correctAnswerIndex: 0,
        explanation: "පස්වන පරම්පරාවේ පරිගණක භාෂා (5GL) ප්‍රධාන වශයෙන් කෘතිම බුද්ධිය (AI) සහ ස්වභාවික භාෂා සැකසීම (NLP) කෙරෙහි අවධානය යොමු කරයි. මෙම භාෂා පරිශීලකයාට ගැටලුව කුමක්දැයි විස්තර කිරීමට ඉඩ සලසන අතර, පරිගණකය විසින්ම විසඳුම සොයා ගනී."
    },
    {
        questionText: "ආඥාත්මක (Imperative) ක්‍රමලේඛන භාෂාවක ප්‍රධාන ලක්ෂණය කුමක්ද?",
        options: [
            "පරිගණකය විසින් අනුගමනය කළ යුතු පියවරෙන් පියවර උපදෙස් පැහැදිලිව සඳහන් කිරීම.",
            "පද්ධතිය කුමක් කළ යුතුද යන්න පමණක් සඳහන් කිරීම, එය කරන්නේ කෙසේදැයි නොවේ.",
            "දත්ත සහ ඒවා මත ක්‍රියා කරන මෙහෙයුම් වස්තු ලෙස සංවිධානය කිරීම.",
            "ගණිතමය තර්කනය සහ ශ්‍රිත (functions) භාවිතය අවධාරණය කිරීම.",
            "ජාල සන්නිවේදන ප්‍රොටෝකෝල සැලසුම් කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "ආඥාත්මක (Imperative) ක්‍රමලේඛන භාෂා පරිගණකය විසින් අනුගමනය කළ යුතු පියවරෙන් පියවර උපදෙස් (algorithms) පැහැදිලිව සඳහන් කරයි. මෙහිදී වැඩසටහනේ තත්ත්වය (state) වෙනස් කිරීම් කෙරෙහි අවධානය යොමු කෙරේ. C, C++, Java, Python (බොහෝ දුරට) වැනි භාෂා ආඥාත්මක භාෂා වේ."
    },
    {
        questionText: "ප්‍රකාශාත්මක (Declarative) ක්‍රමලේඛන භාෂාවක ප්‍රධාන ලක්ෂණය කුමක්ද?",
        options: [
            "පද්ධතිය කුමක් කළ යුතුද යන්න පමණක් සඳහන් කිරීම, එය කරන්නේ කෙසේදැයි නොවේ.",
            "පරිගණකය විසින් අනුගමනය කළ යුතු පියවරෙන් පියවර උපදෙස් පැහැදිලිව සඳහන් කිරීම.",
            "දත්ත සහ ඒවා මත ක්‍රියා කරන මෙහෙයුම් වස්තු ලෙස සංවිධානය කිරීම.",
            "මතක කළමනාකරණය සඳහා සෘජු පාලනයක් ලබා දීම.",
            "දෘඪාංග මට්ටමේ උපදෙස් ලිවීම."
        ],
        correctAnswerIndex: 0,
        explanation: "ප්‍රකාශාත්මක (Declarative) ක්‍රමලේඛන භාෂා පද්ධතිය කුමක් කළ යුතුද යන්න (What to do) විස්තර කරයි, නමුත් එය කරන්නේ කෙසේද (How to do it) යන්න පිළිබඳව උපදෙස් ලබා නොදේ. SQL, HTML, Prolog, Haskell වැනි භාෂා මේ ගණයට අයත් වේ."
    },
    {
        questionText: "වස්තු නැඹුරු (Object-Oriented) ක්‍රමලේඛන භාෂාවක ප්‍රධාන ලක්ෂණය කුමක්ද?",
        options: [
            "දත්ත (data) සහ එම දත්ත මත ක්‍රියා කරන මෙහෙයුම් (operations) 'වස්තු' (objects) ලෙස සංවිධානය කිරීම.",
            "පියවරෙන් පියවර උපදෙස් පමණක් භාවිතා කිරීම.",
            "පරිගණක දෘඪාංග සමඟ සෘජුවම අන්තර් ක්‍රියා කිරීම.",
            "ගණිතමය ශ්‍රිත පමණක් භාවිතා කිරීම.",
            "අන්තර්ජාල ප්‍රොටෝකෝල සැලසුම් කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "වස්තු නැඹුරු (Object-Oriented) ක්‍රමලේඛන භාෂා දත්ත (attributes) සහ එම දත්ත මත ක්‍රියා කරන මෙහෙයුම් (methods) 'වස්තු' (objects) ලෙස සංවිධානය කරයි. මෙය කේත නැවත භාවිතා කිරීම, නඩත්තු කිරීම සහ සංකීර්ණ පද්ධති සැලසුම් කිරීම පහසු කරයි. Java, C++, Python, C# වැනි භාෂා වස්තු නැඹුරු වේ."
    },
    {
        questionText: "පරිගණක භාෂාවන්ගේ පරිණාමයේදී, පළමු පරම්පරාවේ (First Generation) භාෂාවන් ලෙස සලකනු ලබන්නේ කුමන ඒවාද?",
        options: [
            "යන්ත්‍ර භාෂාව (Machine Language).",
            "එකලස් කිරීමේ භාෂාව (Assembly Language).",
            "ඉහළ මට්ටමේ භාෂා (High-Level Languages).",
            "වස්තු නැඹුරු භාෂා (Object-Oriented Languages).",
            "ස්වභාවික භාෂා (Natural Languages)."
        ],
        correctAnswerIndex: 0,
        explanation: "පළමු පරම්පරාවේ භාෂා (1GL) යනු පරිගණකයට සෘජුවම තේරුම් ගත හැකි ද්විමය කේත (binary code) වලින් ලියන ලද යන්ත්‍ර භාෂාවයි (Machine Language). මෙය වැඩසටහන්කරණයට ඉතා අපහසු වූ අතර දෝෂ නිවැරදි කිරීමද අසීරු විය."
    },
    {
        questionText: "ආඥාත්මක ක්‍රමලේඛනය (Imperative Programming) සඳහා හොඳම උදාහරණයක් ලෙස සැලකිය හැක්කේ කුමක්ද?",
        options: [
            "ගණක යන්ත්‍රයක (calculator) පියවරෙන් පියවර ගණනය කිරීම් සිදු කිරීම.",
            "දත්ත ගබඩාවකින් නිශ්චිත දත්ත ලබා ගැනීමට SQL විමසුමක් ලිවීම.",
            "වෙබ් පිටුවක අන්තර්ගතය විස්තර කිරීමට HTML භාවිතය.",
            "යම් යම් තත්ත්වයන් මත පදනම්ව ස්වයංක්‍රීයව තීරණ ගන්නා කෘතිම බුද්ධි පද්ධතියක්.",
            "මූල්‍ය වෙළඳපොළේ ප්‍රවණතා පුරෝකථනය කරන ස්වයං-ඉගෙනුම් ඇල්ගොරිතමයක්."
        ],
        correctAnswerIndex: 0,
        explanation: "ගණක යන්ත්‍රයක ගණනය කිරීම් සිදු කිරීම යනු ආඥාත්මක ක්‍රමලේඛනයට හොඳම උදාහරණයකි. මෙහිදී ක්‍රියාවලිය සඳහා (උදා: අංකයක් ඇතුල් කරන්න, එකතු කිරීමේ බොත්තම ඔබන්න, ප්‍රතිඵලය පෙන්වන්න) පියවරෙන් පියවර උපදෙස් පැහැදිලිව ලබා දිය යුතුය. පරිගණකයේ තත්වය (වත්මන් අගය) මෙම උපදෙස් මඟින් වෙනස් වේ."
    },
    {
        questionText: "ප්‍රකාශාත්මක ක්‍රමලේඛනය (Declarative Programming) සඳහා හොඳම උදාහරණයක් ලෙස සැලකිය හැක්කේ කුමක්ද?",
        options: [
            "දත්ත ගබඩාවකින් නිශ්චිත දත්ත ලබා ගැනීමට SQL විමසුමක් ලිවීම.",
            "යම් කාර්යයක් ඉටු කිරීමට C භාෂාවෙන් ශ්‍රිතයක් ලිවීම.",
            "පරිගණකයේ මතක ලිපින සෘජුවම පාලනය කිරීමට Assembly භාෂාව භාවිතා කිරීම.",
            "සූදු යන්ත්‍රයක (slot machine) පියවරෙන් පියවර ක්‍රියාකාරීත්වය සැලසුම් කිරීම.",
            "ජාල රවුටරයක (router) ක්‍රියාකාරීත්වය පියවරෙන් පියවර වැඩසටහන් කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "SQL (Structured Query Language) යනු ප්‍රකාශාත්මක භාෂාවකි. SQL විමසුමකදී අපට අවශ්‍ය දත්ත කුමක්දැයි (What to get) සඳහන් කරනවා මිස, දත්ත ගබඩාව එම දත්ත සොයා ගන්නේ කෙසේද (How to get it) යන්න පිළිබඳව පියවරෙන් පියවර උපදෙස් ලබා දෙන්නේ නැත."
    },
    {
        questionText: "වස්තු-නැඹුරු ක්‍රමලේඛනයේ (Object-Oriented Programming) 'උරුමය' (Inheritance) සංකල්පයේ ප්‍රධාන අරමුණ කුමක්ද?",
        options: [
            "කිසියම් පන්තියක (Class) ගුණාංග සහ ක්‍රමවේද (methods) වෙනත් පන්තියකට නැවත භාවිතා කිරීමට ඉඩ සැලසීම.",
            "වස්තූන් අතර දත්ත සෘජුවම හුවමාරු කිරීම.",
            "වස්තූන් එකවර විවිධ හැඩතල ගැනීමට හැකි කිරීම.",
            "වස්තූන් අභ්‍යන්තර දත්ත බාහිර ප්‍රවේශයෙන් ආරක්ෂා කිරීම.",
            "වස්තූන්ගේ ක්‍රියාත්මක කිරීමේ වේගය වැඩි කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "වස්තු නැඹුරු ක්‍රමලේඛනයේ 'උරුමය' (Inheritance) යනු පන්තියකට (Class) තවත් පන්තියක (Superclass/Parent Class) ගුණාංග (attributes) සහ ක්‍රමවේද (methods) උරුම කර ගැනීමට ඉඩ සලසන යාන්ත්‍රණයකි. මෙය කේත නැවත භාවිතා කිරීම (Code Reusability) සහ පද්ධතියේ ව්‍යුහය වඩාත් සංවිධානාත්මක කිරීම පහසු කරයි."
    },
    {
        questionText: "පරිගණක භාෂාවන්ගේ පරිණාමයේදී, දෙවන පරම්පරාවේ (Second Generation) භාෂාවන් ලෙස සලකනු ලබන්නේ කුමන ඒවාද?",
        options: [
            "එකලස් කිරීමේ භාෂාව (Assembly Language).",
            "යන්ත්‍ර භාෂාව (Machine Language).",
            "ඉහළ මට්ටමේ භාෂා (High-Level Languages).",
            "ස්වභාවික භාෂා (Natural Languages).",
            "වස්තු නැඹුරු භාෂා (Object-Oriented Languages)."
        ],
        correctAnswerIndex: 0,
        explanation: "දෙවන පරම්පරාවේ භාෂා (2GL) යනු එකලස් කිරීමේ භාෂා (Assembly Languages) වේ. මේවා යන්ත්‍ර භාෂාවේ ද්විමය කේත වෙනුවට mnemonic codes (උදා: ADD, MOV, JMP) භාවිතා කරන අතර, එය වැඩසටහන්කරණය යන්ත්‍ර භාෂාවට වඩා පහසු කරයි. කෙසේ වෙතත්, තවමත් දෘඪාංග මත දැඩිව රඳා පවතී."
    },
    {
        questionText: "ආඥාත්මක භාෂා සහ ප්‍රකාශාත්මක භාෂා අතර ඇති ප්‍රධාන වෙනස වඩාත් නිවැරදිව විස්තර කරන්නේ කුමන ප්‍රකාශයද?",
        options: [
            "ආඥාත්මක භාෂා 'කෙසේද' (How) යන්න කෙරෙහි අවධානය යොමු කරන අතර, ප්‍රකාශාත්මක භාෂා 'කුමක්ද' (What) යන්න කෙරෙහි අවධානය යොමු කරයි.",
            "ආඥාත්මක භාෂා සංකීර්ණ ගැටලු සඳහා භාවිතා කරන අතර, ප්‍රකාශාත්මක භාෂා සරල ගැටලු සඳහා භාවිතා කරයි.",
            "ආඥාත්මක භාෂා පරිගණකයේ මතකය පාලනය කරන අතර, ප්‍රකාශාත්මක භාෂා දත්ත ගබඩා පාලනය කරයි.",
            "ආඥාත්මක භාෂා දෘඪාංග මත රඳා පවතින අතර, ප්‍රකාශාත්මක භාෂා එසේ නොවේ.",
            "ආඥාත්මක භාෂා දෝෂ නිවැරදි කිරීමට පහසු වන අතර, ප්‍රකාශාත්මක භාෂා එසේ නොවේ."
        ],
        correctAnswerIndex: 0,
        explanation: "ආඥාත්මක භාෂා පරිගණකය විසින් යම් කාර්යයක් ඉටු කරන ආකාරය (How to do it) පියවරෙන් පියවර විස්තර කරයි. ප්‍රකාශාත්මක භාෂා යනු අපට අවශ්‍ය ප්‍රතිඵලය කුමක්ද (What to do) යන්න ප්‍රකාශ කිරීමයි. ක්‍රියාත්මක කිරීමේ විස්තර භාෂාව හෝ පද්ධතිය විසින්ම කළමනාකරණය කරනු ලැබේ."
    },
    {
        questionText: "පරිගණක භාෂාවන්ගේ පරිණාමයේදී, තුන්වන පරම්පරාවේ (Third Generation) භාෂාවන්ගේ ප්‍රධාන ලක්ෂණය කුමක්ද?",
        options: [
            "මිනිස් භාෂාවට සමීප ඉහළ මට්ටමේ භාෂා (High-Level Languages) හඳුන්වා දීම.",
            "යන්ත්‍ර භාෂාවේ ද්විමය කේත භාවිතය.",
            "mnemonic codes භාවිතය.",
            "කෘතිම බුද්ධිය සහ ස්වභාවික භාෂා සැකසීම.",
            "වස්තු නැඹුරු ක්‍රමලේඛනයේ සංකල්ප හඳුන්වා දීම."
        ],
        correctAnswerIndex: 0,
        explanation: "තුන්වන පරම්පරාවේ භාෂා (3GL) යනු Fortran, COBOL, C, Pascal වැනි ඉහළ මට්ටමේ භාෂා වේ. මේවා මිනිස් භාෂාවට සමීප වන අතර, යන්ත්‍ර භාෂාවට වඩා කියවීමට, ලිවීමට සහ තේරුම් ගැනීමට පහසුය. එමෙන්ම මේවා දෘඪාංග මත අඩු වශයෙන් රඳා පවතී."
    },
    {
        questionText: "වස්තු-නැඹුරු ක්‍රමලේඛනයේ 'බහුරූපීත්වය' (Polymorphism) යන්නෙන් අදහස් කරන්නේ කුමක්ද?",
        options: [
            "එකම මෙහෙයුම් නමක් (method name) විවිධ පන්තිවලට හෝ විවිධ සන්දර්භවලට අනුව වෙනස් අර්ථයක් දීම.",
            "වස්තූන් අතර දත්ත සඟවා තැබීම.",
            "පන්තියක ගුණාංග වෙනත් පන්තියකට උරුම කර දීම.",
            "විවිධ වස්තූන් එකම දත්ත ව්‍යුහයක් භාවිතා කිරීම.",
            "වැඩසටහනක් එකවර පරිගණක කිහිපයක ක්‍රියාත්මක කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "බහුරූපීත්වය (Polymorphism) යනු වස්තු නැඹුරු ක්‍රමලේඛනයේ වැදගත් සංකල්පයකි. එයින් අදහස් වන්නේ එකම මෙහෙයුම් නමක් (method name) විවිධ පන්තිවලට (classes) හෝ විවිධ සන්දර්භවලට අනුව වෙනස් අර්ථයක් දිය හැකි වීමයි. මෙය කේතයේ නම්‍යශීලී බව සහ ව්‍යාප්ත කිරීමේ හැකියාව වැඩි දියුණු කරයි."
    },
    {
        questionText: "පරිගණක භාෂාවන්ගේ පරිණාමයේදී, සිව්වන පරම්පරාවේ (Fourth Generation) භාෂාවන්ගේ ප්‍රධාන අවධානය කුමක්ද?",
        options: [
            "දත්ත ගබඩා කළමනාකරණය (Database Management), වාර්තාකරණය (Reporting) සහ පරිශීලක අතුරු මුහුණත් නිර්මාණය (GUI Development) සරල කිරීම.",
            "යන්ත්‍ර භාෂාවෙන් සෘජුවම කේත ලිවීම.",
            "දෘඪාංග මට්ටමේ ක්‍රියාකාරීත්වයන් පාලනය කිරීම.",
            "සංකීර්ණ ගණිතමය ගණනය කිරීම් සිදු කිරීම.",
            "ජාල සන්නිවේදනය ප්‍රශස්තකරණය කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "සිව්වන පරම්පරාවේ භාෂා (4GL) ප්‍රධාන වශයෙන් දත්ත ගබඩා කළමනාකරණය, වාර්තාකරණය, සහ පරිශීලක අතුරු මුහුණත් නිර්මාණය වැනි යෙදුම් සංවර්ධන කටයුතු සරල කිරීම කෙරෙහි අවධානය යොමු කරයි. මේවා 3GL වලට වඩා ඉහළ වියුක්ත මට්ටමකින් ක්‍රියාත්මක වන අතර, සංවර්ධන වේගය වැඩි කරයි. උදාහරණ: SQL, Focus, SAS."
    },
    {
        questionText: "වස්තු-නැඹුරු ක්‍රමලේඛනයේ 'එන්කැප්සුලේෂන්' (Encapsulation) යන්නෙන් අදහස් කරන්නේ කුමක්ද?",
        options: [
            "දත්ත සහ එම දත්ත මත ක්‍රියා කරන මෙහෙයුම් එකම 'වස්තුවක්' තුළ එකට බැඳ තබා, බාහිර ප්‍රවේශයෙන් ඒවා ආරක්ෂා කිරීම.",
            "පන්ති අතර දත්ත සෘජුවම හුවමාරු කිරීම.",
            "එකම ක්‍රමලේඛය විවිධ පරිගණක පද්ධති මත ක්‍රියාත්මක කිරීමට හැකි වීම.",
            "වැඩසටහනක් තුළ දෝෂ ස්වයංක්‍රීයව නිවැරදි කිරීම.",
            "දත්ත ගබඩාවක ව්‍යුහය ස්වයංක්‍රීයව නිර්මාණය කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "එන්කැප්සුලේෂන් (Encapsulation) යනු දත්ත (attributes) සහ එම දත්ත මත ක්‍රියා කරන මෙහෙයුම් (methods) එකම වස්තුවක් (object) තුළ එකට බැඳ තබා, එම වස්තුවේ අභ්‍යන්තර ක්‍රියාකාරීත්ව විස්තර බාහිර ලෝකයෙන් සඟවා තැබීමයි. මෙය දත්ත ආරක්ෂා කිරීමට සහ වැඩසටහනේ මොඩියුලරත්වය වැඩි කිරීමට උපකාරී වේ."
    },
    {
        questionText: "පරිගණක භාෂාවන්ගේ පරිණාමයේදී, පස්වන පරම්පරාවේ (Fifth Generation) භාෂාවන්හි ප්‍රධාන අරමුණ කුමක්ද?",
        options: [
            "පරිගණකය මිනිසුන්ට සමීප වන ආකාරයෙන් ගැටලු විසඳීමට හැකි කිරීම.",
            "පරිගණකයේ ක්‍රියාත්මක කිරීමේ වේගය වැඩි කිරීම.",
            "දෘඪාංග සංවර්ධන ක්‍රියාවලිය සරල කිරීම.",
            "අන්තර්ජාලය හරහා දත්ත හුවමාරුව ප්‍රශස්තකරණය කිරීම.",
            "මෘදුකාංග සඳහා බලපත්‍ර ලබා දීමේ ක්‍රියාවලිය සරල කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "පස්වන පරම්පරාවේ භාෂා (5GL) වල ප්‍රධාන අරමුණ වන්නේ පරිගණකයට මිනිසුන්ට සමීප වන ආකාරයෙන් ගැටලු විසඳීමට හැකි කිරීමයි, විශේෂයෙන් කෘතිම බුද්ධිය සහ දැනුම මත පදනම් වූ පද්ධති හරහා. මේවා ස්වභාවික භාෂා ආදාන තේරුම් ගැනීමට සහ තර්ක කිරීමට හැකියාව ඇත."
    },
    {
        questionText: "ආඥාත්මක, ප්‍රකාශාත්මක, සහ වස්තු නැඹුරු භාෂා අතරින් 'රටා හඳුනා ගැනීම' (Pattern Recognition) සහ 'තාර්කික අනුමාන කිරීම්' (Logical Inference) වැනි කාර්යයන් සඳහා වඩාත් සුදුසු ක්‍රමලේඛන සුසමාදර්ශය කුමක්ද?",
        options: [
            "ප්‍රකාශාත්මක ක්‍රමලේඛනය (Declarative Programming) විශේෂයෙන්ම Logic Programming.",
            "ආඥාත්මක ක්‍රමලේඛනය (Imperative Programming).",
            "වස්තු නැඹුරු ක්‍රමලේඛනය (Object-Oriented Programming).",
            "එකලස් කිරීමේ භාෂාව (Assembly Language).",
            "යන්ත්‍ර භාෂාව (Machine Language)."
        ],
        correctAnswerIndex: 0,
        explanation: "ප්‍රකාශාත්මක ක්‍රමලේඛනය යටතේ එන Logic Programming (උදා: Prolog) වැනි සුසමාදර්ශයන්, රටා හඳුනා ගැනීම, තාර්කික අනුමාන කිරීම් සහ දැනුම මත පදනම් වූ පද්ධති සංවර්ධනය සඳහා ඉතා සුදුසු වේ. මේවායේදී ගැටලුව කුමක්දැයි විස්තර කරන අතර, විසඳුම සොයා ගැනීම සඳහා තර්ක කිරීමේ එන්ජිමක් භාවිතා කරයි."
    },
    {
        questionText: "වස්තු-නැඹුරු ක්‍රමලේඛනයේ 'වියුක්තකරණය' (Abstraction) යන්නෙන් අදහස් කරන්නේ කුමක්ද?",
        options: [
            "අත්‍යවශ්‍ය තොරතුරු පමණක් පෙන්වා, අනවශ්‍ය විස්තර සඟවා තැබීම.",
            "දත්ත සහ ක්‍රමවේද වස්තුවක් තුළ එකට බැඳ තැබීම.",
            "පන්තියක ගුණාංග වෙනත් පන්තියකට උරුම කර දීම.",
            "එකම මෙහෙයුම් නමක් විවිධ ආකාරවලින් ක්‍රියාත්මක වීමට හැකි කිරීම.",
            "වැඩසටහනක දෝෂ ස්වයංක්‍රීයව නිවැරදි කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "වියුක්තකරණය (Abstraction) යනු වස්තු-නැඹුරු ක්‍රමලේඛනයේ මූලික සංකල්පයකි. එයින් අදහස් වන්නේ පරිශීලකයාට අදාළ අත්‍යවශ්‍ය තොරතුරු පමණක් පෙන්වා, අභ්‍යන්තර ක්‍රියාකාරීත්ව විස්තර (implementation details) සඟවා තැබීමයි. මෙය සංකීර්ණත්වය අඩු කරන අතර, පද්ධතිය භාවිතා කිරීම පහසු කරයි."
    },
    {
        questionText: "පරිගණක භාෂාවන්ගේ පරිණාමයේදී, කේතකරණය වඩාත් 'මානව-හිතකාමී' (human-friendly) බවට පත් කළ ප්‍රධාන පරම්පරාව කුමක්ද?",
        options: [
            "තුන්වන පරම්පරාව (Third Generation).",
            "පළමු පරම්පරාව (First Generation).",
            "දෙවන පරම්පරාව (Second Generation).",
            "සිව්වන පරම්පරාව (Fourth Generation).",
            "පස්වන පරම්පරාව (Fifth Generation)."
        ],
        correctAnswerIndex: 0,
        explanation: "තුන්වන පරම්පරාවේ භාෂා (3GL) වන C, Pascal, Fortran වැනි ඉහළ මට්ටමේ භාෂා හඳුන්වා දීමත් සමඟ, කේතකරණය මිනිස් භාෂාවට වඩාත් සමීප වී, කියවීමට, ලිවීමට සහ තේරුම් ගැනීමට පහසු විය. මෙය වැඩසටහන්කරණය වඩාත් ප්‍රවේශ විය හැකි ක්ෂේත්‍රයක් බවට පත් කළේය."
    },
    {
        questionText: "පහත සඳහන් ක්‍රමලේඛන සුසමාදර්ශයන්ගෙන්, 'පාලන ප්‍රවාහය' (control flow) මත දැඩි අවධානයක් යොමු කරන්නේ කුමන සුසමාදර්ශයද?",
        options: [
            "ආඥාත්මක (Imperative).",
            "ප්‍රකාශාත්මක (Declarative).",
            "වස්තු නැඹුරු (Object-Oriented).",
            "ක්‍රියාකාරී (Functional).",
            "තාර්කික (Logic)."
        ],
        correctAnswerIndex: 0,
        explanation: "ආඥාත්මක ක්‍රමලේඛනය (Imperative Programming) යනු පරිගණකය විසින් උපදෙස් ක්‍රියාත්මක කරන අනුපිළිවෙල (control flow) මත දැඩි අවධානයක් යොමු කරයි. වැඩසටහනේ තත්ත්වය (state) පියවරෙන් පියවර වෙනස් වන ආකාරය මෙහිදී පැහැදිලිව සඳහන් කෙරේ."
    },

    // 9.5 ක්‍රමලේඛ පරිවර්තනය කිරීමේ අවශ්‍යතාව සහ ක්‍රමලේඛ පරිවර්තක වර්ග ගවේෂණය කරයි (Program Translators)
    {
        questionText: "ක්‍රමලේඛ පරිවර්තනය කිරීමේ (Program Translation) ප්‍රධාන අවශ්‍යතාව කුමක්ද?",
        options: [
            "මිනිසුන් විසින් ලියන ලද ඉහළ මට්ටමේ ක්‍රමලේඛ කේතයන් පරිගණකයට තේරුම් ගත හැකි යන්ත්‍ර කේත බවට පරිවර්තනය කිරීම.",
            "වැඩසටහන්වල දෝෂ ස්වයංක්‍රීයව නිවැරදි කිරීම.",
            "වැඩසටහන්වල ක්‍රියාත්මක කිරීමේ වේගය වැඩි කිරීම.",
            "විවිධ ක්‍රමලේඛන භාෂා අතර සන්නිවේදනය ඇති කිරීම.",
            "දත්ත ගබඩාවක දත්ත සුරක්ෂිතභාවය තහවුරු කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "පරිගණක ක්‍රියාත්මක වන්නේ යන්ත්‍ර භාෂාවෙන් (Machine Language) පමණි. මිනිසුන් විසින් ලියන ලද ඉහළ මට්ටමේ ක්‍රමලේඛ කේතයන් (High-Level Language Code) පරිගණකයට තේරුම් ගත නොහැක. එම නිසා, මෙම ඉහළ මට්ටමේ කේත යන්ත්‍ර කේත බවට පරිවර්තනය කිරීම අත්‍යවශ්‍ය වේ. මෙම ක්‍රියාවලිය ක්‍රමලේඛ පරිවර්තනය ලෙස හැඳින්වේ."
    },
    {
        questionText: "ප්‍රභව ක්‍රමලේඛය (Source Program) යනු කුමක්ද?",
        options: [
            "ක්‍රමලේඛකයෙකු විසින් ඉහළ මට්ටමේ ක්‍රමලේඛන භාෂාවකින් ලියන ලද මුල් කේතය.",
            "පරිගණකයකට සෘජුවම ක්‍රියාත්මක කළ හැකි යන්ත්‍ර කේතය.",
            "දත්ත ගබඩාවක ගබඩා කර ඇති දත්ත.",
            "ක්‍රමලේඛයක් ක්‍රියාත්මක කිරීමෙන් පසු ලැබෙන ප්‍රතිදානය.",
            "ජාල සන්නිවේදන ප්‍රොටෝකෝලයක නිර්වචනය."
        ],
        correctAnswerIndex: 0,
        explanation: "ප්‍රභව ක්‍රමලේඛය (Source Program) යනු ක්‍රමලේඛකයෙකු විසින් C, Java, Python වැනි ඉහළ මට්ටමේ ක්‍රමලේඛන භාෂාවකින් ලියන ලද මුල් කේතයයි. මෙය පරිගණක පරිවර්තකයක් මඟින් වස්තු ක්‍රමලේඛයක් බවට පරිවර්තනය කිරීමට පෙර පවතී."
    },
    {
        questionText: "වස්තු ක්‍රමලේඛය (Object Program) යනු කුමක්ද?",
        options: [
            "ක්‍රමලේඛ පරිවර්තකයක් මඟින් ප්‍රභව ක්‍රමලේඛයක් යන්ත්‍ර භාෂාවට හෝ මධ්‍යස්ථ කේතයට (intermediate code) පරිවර්තනය කිරීමෙන් පසු ජනනය වන කේතය.",
            "ක්‍රමලේඛකයෙකු විසින් ඉහළ මට්ටමේ ක්‍රමලේඛන භාෂාවකින් ලියන ලද මුල් කේතය.",
            "වැඩසටහනක් ක්‍රියාත්මක කිරීමට පෙර දෝෂ නිවැරදි කිරීම සඳහා භාවිතා කරන කේතය.",
            "ක්‍රමලේඛයක් සඳහා පරිශීලක අතුරු මුහුණතේ කේතය.",
            "දත්ත ගබඩාවක් කළමනාකරණය කිරීමට භාවිතා කරන කේතය."
        ],
        correctAnswerIndex: 0,
        explanation: "වස්තු ක්‍රමලේඛය (Object Program) යනු පරිවර්තකයක් (Compiler) මඟින් ප්‍රභව ක්‍රමලේඛයක් යන්ත්‍ර භාෂාවට හෝ මධ්‍යස්ථ කේතයට පරිවර්තනය කිරීමෙන් පසු ජනනය වන කේතයයි. මෙය පරිගණකයට සෘජුවම ක්‍රියාත්මක කිරීමට හැකි හෝ linker එකක් මඟින් ක්‍රියාත්මක කළ හැකි ගොනුවක් බවට පත් කළ හැකි කේතයකි."
    },
    {
        questionText: "අර්ථනාසකයක් (Interpreter) ක්‍රමලේඛයක් පරිවර්තනය කරන්නේ කෙසේද?",
        options: [
            "පියවරෙන් පියවර, එකවර එක් කේත රේඛාවක් කියවා ක්‍රියාත්මක කිරීමෙන්.",
            "මුළු ප්‍රභව ක්‍රමලේඛයම එකවර යන්ත්‍ර කේත බවට පරිවර්තනය කිරීමෙන්.",
            "ප්‍රභව ක්‍රමලේඛය දත්ත ගබඩාවක ගබඩා කිරීමෙන්.",
            "ප්‍රභව ක්‍රමලේඛය ග්‍රැෆික් පරිශීලක අතුරු මුහුණතක් බවට පරිවර්තනය කිරීමෙන්.",
            "ප්‍රභව ක්‍රමලේඛය තුළ ඇති දෝෂ ස්වයංක්‍රීයව නිවැරදි කිරීමෙන්."
        ],
        correctAnswerIndex: 0,
        explanation: "අර්ථනාසකයක් (Interpreter) ප්‍රභව ක්‍රමලේඛයක් පරිවර්තනය කරන්නේ පියවරෙන් පියවර, එක් කේත රේඛාවක් කියවා එය වහාම ක්‍රියාත්මක කිරීමෙනි. මෙය දෝෂ නිවැරදි කිරීමට පහසු වන නමුත්, සම්පාදකයක් (Compiler) මඟින් පරිවර්තනය කරන ලද වැඩසටහනකට වඩා මන්දගාමී විය හැක. Python, JavaScript, PHP වැනි භාෂා interpreters භාවිතා කරයි."
    },
    {
        questionText: "සම්පාදකයක් (Compiler) ක්‍රමලේඛයක් පරිවර්තනය කරන්නේ කෙසේද?",
        options: [
            "මුළු ප්‍රභව ක්‍රමලේඛයම එකවර යන්ත්‍ර කේත බවට පරිවර්තනය කිරීමෙන්, ක්‍රියාත්මක කළ හැකි ගොනුවක් ජනනය කිරීමෙන්.",
            "පියවරෙන් පියවර, එකවර එක් කේත රේඛාවක් කියවා ක්‍රියාත්මක කිරීමෙන්.",
            "ප්‍රභව ක්‍රමලේඛය දත්ත ගබඩාවක ගබඩා කිරීමෙන්.",
            "ප්‍රභව ක්‍රමලේඛය ග්‍රැෆික් පරිශීලක අතුරු මුහුණතක් බවට පරිවර්තනය කිරීමෙන්.",
            "ප්‍රභව ක්‍රමලේඛය තුළ ඇති දෝෂ ස්වයංක්‍රීයව නිවැරදි කිරීමෙන්."
        ],
        correctAnswerIndex: 0,
        explanation: "සම්පාදකයක් (Compiler) මුළු ප්‍රභව ක්‍රමලේඛයම එකවර කියවා, එය සම්පූර්ණයෙන්ම යන්ත්‍ර කේත බවට පරිවර්තනය කරයි. මෙම පරිවර්තනයෙන් පසුව ක්‍රියාත්මක කළ හැකි (executable) ගොනුවක් ජනනය වේ. සම්පාදනය කරන ලද වැඩසටහන් සාමාන්‍යයෙන් අර්ථනාසක මඟින් ක්‍රියාත්මක කරන ලද වැඩසටහන් වලට වඩා වේගවත් වේ. C, C++, Java වැනි භාෂා Compilers භාවිතා කරයි."
    },
    {
        questionText: "දෙමුහුන් ප්‍රවේශයක් (Hybrid Approach) භාවිතා කරන ක්‍රමලේඛ පරිවර්තකයක් යනු කුමක්ද?",
        options: [
            "සම්පාදකයක් සහ අර්ථනාසකයක් යන දෙකෙහිම ලක්ෂණ භාවිතා කරමින්, ප්‍රභව කේතය මධ්‍යස්ථ කේතයකට (intermediate code) පරිවර්තනය කර පසුව එය ක්‍රියාත්මක කිරීම.",
            "ප්‍රභව කේතය සෘජුවම යන්ත්‍ර කේතයට පරිවර්තනය කිරීම.",
            "ප්‍රභව කේතය පියවරෙන් පියවර ක්‍රියාත්මක කිරීම.",
            "විවිධ ක්‍රමලේඛන භාෂා එකට මිශ්‍ර කිරීම.",
            "ක්‍රමලේඛයක් සඳහා දෘඪාංග හා මෘදුකාංග යන දෙකම සැලසුම් කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "දෙමුහුන් ප්‍රවේශයක් (Hybrid Approach) භාවිතා කරන පරිවර්තකයන් (උදා: Java) මුලින්ම සම්පාදකයක් මඟින් ප්‍රභව කේතය 'byte code' වැනි මධ්‍යස්ථ කේතයකට පරිවර්තනය කරයි. පසුව, අර්ථනාසකයක් (JVM - Java Virtual Machine) මඟින් එම මධ්‍යස්ථ කේතය පියවරෙන් පියවර ක්‍රියාත්මක කරයි. මෙය වේගය සහ නම්‍යශීලී බව යන දෙකම ලබා දෙයි."
    },
    {
        questionText: "සන්ධාරකයක (Linker) ප්‍රධාන කාර්යය කුමක්ද?",
        options: [
            "වස්තු ක්‍රමලේඛ ගොනු (object files) සහ පුස්තකාල (libraries) ඒකාබද්ධ කර ක්‍රියාත්මක කළ හැකි ගොනුවක් (executable file) නිර්මාණය කිරීම.",
            "ඉහළ මට්ටමේ ක්‍රමලේඛ කේතයන් යන්ත්‍ර කේත බවට පරිවර්තනය කිරීම.",
            "පියවරෙන් පියවර කේත ක්‍රියාත්මක කිරීම.",
            "ක්‍රමලේඛයක් තුළ ඇති දෝෂ හඳුනා ගැනීම.",
            "පරිශීලක අතුරු මුහුණත් සැලසුම් කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "සන්ධාරකයක් (Linker) යනු සම්පාදනය කරන ලද වස්තු ක්‍රමලේඛ ගොනු (object files) සහ වැඩසටහනට අවශ්‍ය වන පුස්තකාල (libraries - pre-compiled code) එකට සම්බන්ධ කර, පරිගණකයක ක්‍රියාත්මක කළ හැකි අවසාන ගොනුවක් (executable file) නිර්මාණය කරන මෘදුකාංගයකි."
    },
    {
        questionText: "ප්‍රභව ක්‍රමලේඛයක් (Source Program) සහ වස්තු ක්‍රමලේඛයක් (Object Program) අතර ඇති ප්‍රධාන වෙනස කුමක්ද?",
        options: [
            "ප්‍රභව ක්‍රමලේඛය මිනිසුන්ට තේරුම් ගත හැකි ඉහළ මට්ටමේ කේත වන අතර, වස්තු ක්‍රමලේඛය පරිගණකයට තේරුම් ගත හැකි යන්ත්‍ර කේත හෝ මධ්‍යස්ථ කේත වේ.",
            "ප්‍රභව ක්‍රමලේඛය දෝෂ රහිත වන අතර, වස්තු ක්‍රමලේඛය තුළ දෝෂ තිබිය හැක.",
            "ප්‍රභව ක්‍රමලේඛය ක්‍රියාත්මක කළ හැකි අතර, වස්තු ක්‍රමලේඛය එසේ නොවේ.",
            "ප්‍රභව ක්‍රමලේඛය දෘඪාංග මත රඳා පවතින අතර, වස්තු ක්‍රමලේඛය එසේ නොවේ.",
            "ප්‍රභව ක්‍රමලේඛය තනි ගොනුවක් වන අතර, වස්තු ක්‍රමලේඛය ගොනු කිහිපයක එකතුවකි."
        ],
        correctAnswerIndex: 0,
        explanation: "ප්‍රභව ක්‍රමලේඛය යනු ක්‍රමලේඛකයන් විසින් ලියන ලද, කියවීමට පහසු ඉහළ මට්ටමේ කේතයයි. වස්තු ක්‍රමලේඛය යනු එම ප්‍රභව කේතය පරිවර්තකයක් මඟින් යන්ත්‍ර භාෂාවට හෝ මධ්‍යස්ථ කේතයට පරිවර්තනය කිරීමෙන් පසු ලැබෙන, පරිගණකයට තේරුම් ගත හැකි ආකාරයේ කේතයයි."
    },
    {
        questionText: "සම්පාදකයක් (Compiler) භාවිතා කිරීමෙන් ලැබෙන ප්‍රධාන වාසිය කුමක්ද?",
        options: [
            "පරිවර්තනය කරන ලද වැඩසටහන වේගවත්ව ක්‍රියාත්මක වීම.",
            "වැඩසටහන දෝෂ නිවැරදි කිරීමට පහසු වීම.",
            "කේතය ලිවීමේ ක්‍රියාවලිය සරල කිරීම.",
            "වැඩසටහනට අඩු මතක ප්‍රමාණයක් අවශ්‍ය වීම.",
            "වැඩසටහන විවිධ මෙහෙයුම් පද්ධති මත ක්‍රියාත්මක වීම."
        ],
        correctAnswerIndex: 0,
        explanation: "සම්පාදකයක් මඟින් මුළු වැඩසටහනම එකවර යන්ත්‍ර කේත බවට පරිවර්තනය කරන බැවින්, සම්පාදනය කරන ලද වැඩසටහන වේගවත්ව ක්‍රියාත්මක වේ. අර්ථනාසක මඟින් පියවරෙන් පියවර ක්‍රියාත්මක කරන බැවින්, එය මන්දගාමී විය හැක."
    },
    {
        questionText: "අර්ථනාසකයක් (Interpreter) භාවිතා කිරීමෙන් ලැබෙන ප්‍රධාන වාසිය කුමක්ද?",
        options: [
            "වැඩසටහන දෝෂ නිවැරදි කිරීමට පහසු වීම සහ සංවර්ධන ක්‍රියාවලිය වේගවත් වීම.",
            "පරිවර්තනය කරන ලද වැඩසටහන වේගවත්ව ක්‍රියාත්මක වීම.",
            "මුළු වැඩසටහනම එකවර යන්ත්‍ර කේත බවට පරිවර්තනය කිරීම.",
            "ක්‍රියාත්මක කළ හැකි ස්වාධීන ගොනුවක් ජනනය කිරීම.",
            "වැඩසටහනට වැඩි මතක ප්‍රමාණයක් අවශ්‍ය වීම."
        ],
        correctAnswerIndex: 0,
        explanation: "අර්ථනාසකයක් පියවරෙන් පියවර කේත ක්‍රියාත්මක කරන බැවින්, දෝෂ හඳුනා ගැනීම සහ නිවැරදි කිරීම පහසු වේ. මෙය සංවර්ධන ක්‍රියාවලිය වේගවත් කරයි, මන්ද සෑම වරම මුළු වැඩසටහනම සම්පාදනය කිරීමට අවශ්‍ය නොවන බැවිනි."
    },
    {
        questionText: "දෙමුහුන් ප්‍රවේශයක් (Hybrid Approach) භාවිතා කරන ක්‍රමලේඛ පරිවර්තකයක ප්‍රධාන වාසිය කුමක්ද?",
        options: [
            "සම්පාදනයේ වේගය සහ අර්ථනාසනයේ නම්‍යශීලී බව යන දෙකම ලබා දීම.",
            "කිසිදු දෝෂයකින් තොරව වැඩසටහන් ලිවීමට හැකි වීම.",
            "සම්පූර්ණයෙන්ම යන්ත්‍ර කේත බවට පරිවර්තනය වීම.",
            "විවිධ දෘඪාංග පද්ධති මත පමණක් ක්‍රියාත්මක වීම.",
            "ක්‍රමලේඛයක් ලිවීමට අවශ්‍ය කාලය සැලකිය යුතු ලෙස අඩු කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "දෙමුහුන් ප්‍රවේශය (Hybrid Approach) සම්පාදකයක වේගය (byte code වැනි මධ්‍යස්ථ කේතයක් නිර්මාණය කිරීමෙන්) සහ අර්ථනාසකයක නම්‍යශීලී බව (ප්ලැට්ෆෝම් ස්වාධීනත්වය සහ පහසු දෝෂ නිවැරදි කිරීම) යන දෙකෙහිම වාසි ලබා දෙයි. Java වැනි භාෂා මෙම ප්‍රවේශය භාවිතා කරයි."
    },
    {
        questionText: "සන්ධාරකයක් (Linker) අවශ්‍ය වන්නේ කුමන අවස්ථාවකදීද?",
        options: [
            "වැඩසටහනක් බාහිර පුස්තකාල (external libraries) හෝ වෙනත් වස්තු ගොනු (object files) සමඟ සම්බන්ධ කළ යුතු විට.",
            "ප්‍රභව කේතයක් යන්ත්‍ර කේත බවට පරිවර්තනය කරන විට.",
            "වැඩසටහනක් පියවරෙන් පියවර ක්‍රියාත්මක කරන විට.",
            "වැඩසටහනක් තුළ ඇති දෝෂ හඳුනා ගන්නා විට.",
            "පරිශීලක අතුරු මුහුණතක් නිර්මාණය කරන විට."
        ],
        correctAnswerIndex: 0,
        explanation: "සන්ධාරකයක් (Linker) අවශ්‍ය වන්නේ වැඩසටහනක් සඳහා සම්පාදනය කරන ලද විවිධ වස්තු ගොනු (object files) සහ වැඩසටහනට අවශ්‍ය වන පුස්තකාල (libraries) එකට සම්බන්ධ කර, පරිගණකයකට ක්‍රියාත්මක කළ හැකි තනි ගොනුවක් (executable file) නිර්මාණය කිරීමටයි."
    },
    {
        questionText: "යම්කිසි වැඩසටහනක් සම්පාදනය කිරීමේදී (Compiling) සිදුවිය හැකි 'වැරදි' (errors) වර්ගයක් නොවේ කුමක්ද?",
        options: [
            "දත්ත පදනම් දෝෂ (Database errors) - (උදා: දත්ත ගබඩාවක් සමඟ සම්බන්ධ වීමේ ගැටලු).",
            "සංරචක දෝෂ (Syntax errors) - (උදා: ක්‍රමලේඛයේ වැරදි ව්‍යුහය).",
            "අර්ථ දෝෂ (Semantic errors) - (උදා: ක්‍රමලේඛයේ තර්කය වැරදි වීම).",
            "ලොජික් දෝෂ (Logic errors) - (උදා: ක්‍රමලේඛයේ නිවැරදි ප්‍රතිදානයක් නොලැබීම).",
            "අවසාන ප්‍රතිදාන දෝෂ (Final output errors) - (උදා: වැඩසටහන ක්‍රියාත්මක වීමෙන් පසු ලැබෙන ප්‍රතිදානය වැරදි වීම)."
        ],
        correctAnswerIndex: 0,
        explanation: "සම්පාදනයේදී සිදුවිය හැකි වැරදි වර්ගයන්හිදී, දත්ත පදනම් දෝෂ (Database errors) යනු සම්පාදනයේදී නොමැතිව, වැඩසටහන ක්‍රියාත්මක කිරීමේදී පමණක් හටගන්නා ගැටලුවකි. අනෙක් සියලු දෝෂ වර්ග (Syntax, Semantic, Logic) සම්පාදනයේදී හඳුනා ගත හැක."
    },
    // 9.8: ක්‍රමලේඛ සංවර්ධනයේ පාලන ව්‍යුහ භාවිත කරයි. (Control Structures)
    {
        questionText: "ක්‍රමලේඛනයකදී 'තේරීම (selection)' පාලන ව්‍යුහය ප්‍රධාන වශයෙන් භාවිතා කරන්නේ කුමන අරමුණක් සඳහාද?",
        options: [
            "ක්‍රමලේඛයේ ප්‍රකාශන ස්ථාවර අනුපිළිවෙලකට ක්‍රියාත්මක කිරීමට",
            "යම් කොන්දේසියක් සත්‍ය නම් හෝ අසත්‍ය නම් වෙනස් කේත කොටස් ක්‍රියාත්මක කිරීමට",
            "යම් කේත කොටසක් නියමිත වාර ගණනක් හෝ කොන්දේසියක් සත්‍ය වන තුරු නැවත නැවත ක්‍රියාත්මක කිරීමට",
            "ක්‍රමලේඛය කුඩා, කළමනාකරණය කළ හැකි කොටස් වලට බෙදීමට",
            "දත්ත කාර්යක්ෂමව ගබඩා කිරීමට සහ හැසිරවීමට"
        ],
        correctAnswerIndex: 1,
        explanation: "තේරීම (selection) පාලන ව්‍යුහය (උදා: if, if-else, switch) මූලිකවම භාවිතා කරන්නේ යම් කොන්දේසියක් මත පදනම්ව ක්‍රමලේඛයේ ක්‍රියාත්මක වන මාර්ගය තීරණය කිරීමටයි. කොන්දේසියක් සත්‍ය වූ විට එක් ක්‍රියාදාමයක් ද, අසත්‍ය වූ විට තවත් ක්‍රියාදාමයක් ද සිදු කිරීමට මෙය ඉඩ සලසයි. මෙය ක්‍රමලේඛයක තීරණ ගැනීමේ හැකියාවට අත්‍යවශ්‍ය වේ."
    },
    {
        questionText: "පහත සඳහන් කේත කොටසෙහි ප්‍රතිඵලය කුමක්ද? x = 15; y = 10; if (x > y) { print('පළමු'); } else { print('දෙවන'); }",
        options: [
            "පළමු",
            "දෙවන",
            "දෝෂයක්",
            "කිසිවක් මුද්‍රණය නොවේ",
            "x සහ y හි අගයන්"
        ],
        correctAnswerIndex: 0,
        explanation: "මෙම කේත කොටසෙහි, x (15) y (10) ට වඩා වැඩි බැවින් `x > y` යන කොන්දේසිය සත්‍ය වේ. එබැවින්, `if` කොටස ක්‍රියාත්මක වන අතර 'පළමු' යන පාඨය මුද්‍රණය වේ. `else` කොටස ක්‍රියාත්මක නොවේ."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී 'පුනරාවෘත්තිය (repetition)' පාලන ව්‍යුහයක් (loop) භාවිතා කිරීමේ ප්‍රධාන වාසිය කුමක්ද?",
        options: [
            "ක්‍රමලේඛයේ ක්‍රියාත්මක වන වේගය අඩු කිරීම",
            "තීරණ ගැනීම සඳහා බහුවිධ කොන්දේසි ඇතුළත් කිරීම",
            "යම් කේත කොටසක් නැවත නැවත ලිවීමේ අවශ්‍යතාවය අවම කිරීම",
            "දත්ත ගබඩා කිරීමේ කාර්යක්ෂමතාව වැඩි කිරීම",
            "පරිශීලකයාගෙන් දත්ත ලබා ගැනීම සරල කිරීම"
        ],
        correctAnswerIndex: 2,
        explanation: "පුනරාවෘත්තිය (repetition) හෝ ලූප් (looping) ව්‍යුහයක් (උදා: for, while) භාවිතා කිරීමෙන් යම් කේත කොටසක් නියමිත වාර ගණනක් හෝ යම් කොන්දේසියක් සත්‍ය වන තුරු නැවත නැවත ක්‍රියාත්මක කළ හැකිය. මෙය එකම කේත කොටස නැවත නැවත ලිවීමේ අවශ්‍යතාවය ඉවත් කරන අතර, ක්‍රමලේඛය වඩාත් සංක්ෂිප්ත හා කියවීමට පහසු කරයි."
    },
    {
        questionText: "පහත කේත කොටසෙහි `for` ලූප් එකෙන් ප්‍රතිඵල ලෙස ලැබෙන්නේ කුමක්ද? for (i = 0; i < 3; i++) { print(i); }",
        options: [
            "012",
            "123",
            "0123",
            "i i i",
            "දෝෂයක්"
        ],
        correctAnswerIndex: 0,
        explanation: "`for` ලූප් එක `i = 0` සිට ආරම්භ වී, `i < 3` වන තුරු ක්‍රියාත්මක වේ. සෑම වාරයකදීම `i` හි අගය 1කින් වැඩි වේ. එබැවින්, ලූප් එක `i=0`, `i=1`, `i=2` සඳහා ක්‍රියාත්මක වන අතර, එම අගයන් මුද්‍රණය කරනු ඇත. ප්‍රතිඵලය '012' ලෙස ලැබෙනු ඇත."
    },
    {
        questionText: "නියමිත වාර ගණනක් කේත කොටසක් නැවත නැවත ක්‍රියාත්මක කිරීමට වඩාත් සුදුසු පාලන ව්‍යුහය කුමක්ද?",
        options: [
            "if-else ප්‍රකාශය",
            "switch ප්‍රකාශය",
            "for ලූප් එක",
            "while ලූප් එක",
            "sequence ව්‍යුහය"
        ],
        correctAnswerIndex: 2,
        explanation: "යම් කේත කොටසක් නියමිත වාර ගණනක් ක්‍රියාත්මක කිරීමට `for` ලූප් එක වඩාත් සුදුසු වේ. මක්නිසාද යත්, එය ආරම්භක අගයක්, අවසන් කොන්දේසියක් සහ පියවරක් සමඟ ක්‍රියාත්මක වන වාර ගණන පැහැදිලිව නිර්වචනය කිරීමට ඉඩ සලසන බැවිනි. `while` ලූප් එක සාමාන්‍යයෙන් භාවිතා කරන්නේ කොන්දේසියක් සත්‍ය වන තුරු ක්‍රියාත්මක වීමටයි, නියමිත වාර ගණනකට වඩා."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී 'අනුක්‍රමය (sequence)' පාලන ව්‍යුහය මගින් නිරූපණය කරන්නේ කුමක්ද?",
        options: [
            "යම් කොන්දේසියක් මත පදනම්ව කේත කොටස් ක්‍රියාත්මක කිරීම",
            "කේතයේ ප්‍රකාශන එකින් එක, ඉහළ සිට පහළට, අනුපිළිවෙලින් ක්‍රියාත්මක වීම",
            "යම් කේත කොටසක් නියමිත වාර ගණනක් නැවත නැවත ක්‍රියාත්මක කිරීම",
            "සංකීර්ණ ගැටළු කුඩා කොටස් වලට බෙදා විසඳීම",
            "දත්ත ගබඩා කිරීමේ විවිධ ක්‍රම"
        ],
        correctAnswerIndex: 1,
        explanation: "අනුක්‍රමය (sequence) යනු ක්‍රමලේඛනයක වඩාත්ම මූලික පාලන ව්‍යුහයයි. එයින් අදහස් කරන්නේ ක්‍රමලේඛයේ ප්‍රකාශන අර්ථ දක්වා ඇති අනුපිළිවෙලට, එනම් ඉහළ සිට පහළට, එකින් එක ක්‍රියාත්මක වන බවයි. මෙහිදී කිසිදු කොන්දේසියක් හෝ නැවත නැවත ක්‍රියාත්මක කිරීමක් සිදු නොවේ."
    },
    {
        questionText: "පහත කේත කොටසෙහි, `if` ප්‍රකාශනය තුළ තවත් `if` ප්‍රකාශනයක් භාවිතා කිරීම කුමන පාලන ව්‍යුහ වර්ගයට අයත් වන්නේද? `if (A) { if (B) { ... } }`",
        options: [
            "අනුක්‍රමය",
            "සරල තේරීම",
            "පුනරාවෘත්තිය",
            "නිහිත (nested) පාලන ව්‍යුහය",
            "ලූප් කිරීම"
        ],
        correctAnswerIndex: 3,
        explanation: "එක් පාලන ව්‍යුහයක් (මෙහි `if` ප්‍රකාශනයක්) තවත් පාලන ව්‍යුහයක් (මෙහි තවත් `if` ප්‍රකාශනයක්) තුළ අන්තර්ගත වන විට එය 'නිහිත (nested) පාලන ව්‍යුහයක්' ලෙස හැඳින්වේ. මෙය සංකීර්ණ තීරණ ගැනීමේ තත්ත්වයන් ක්‍රමලේඛනය කිරීමට ඉඩ සලසයි."
    },
    {
        questionText: "පහත දැක්වෙන කේත කොටසෙහි ප්‍රතිඵලය කුමක්ද? i = 0; while (i < 4) { print(i); i += 1; }",
        options: [
            "0123",
            "1234",
            "01234",
            "i i i i",
            "දෝෂයක්"
        ],
        correctAnswerIndex: 0,
        explanation: "`while` ලූප් එක `i < 4` වන තුරු ක්‍රියාත්මක වේ. `i` ආරම්භ වන්නේ 0 න් වන අතර, සෑම පුනරාවෘත්තියකදීම 1කින් වැඩි වේ. එබැවින්, `i` හි අගයන් 0, 1, 2, 3 සඳහා ලූප් එක ක්‍රියාත්මක වන අතර එම අගයන් මුද්‍රණය කරයි. `i` 4 වන විට, කොන්දේසිය `4 < 4` අසත්‍ය වන බැවින් ලූප් එක අවසන් වේ. ප්‍රතිඵලය '0123' ලෙස ලැබෙනු ඇත."
    },
    {
        questionText: "යම් ක්‍රමලේඛනයකදී එක් කොන්දේසියක් මත පදනම්ව එක් ක්‍රියාදාමයක් පමණක් සිදු කිරීමට අවශ්‍ය නම්, වඩාත් සුදුසු පාලන ව්‍යුහය කුමක්ද?",
        options: [
            "if-else ප්‍රකාශය",
            "switch ප්‍රකාශය",
            "සරල if ප්‍රකාශය",
            "while ලූප් එක",
            "for ලූප් එක"
        ],
        correctAnswerIndex: 2,
        explanation: "යම් කොන්දේසියක් සත්‍ය නම් පමණක් ක්‍රියාත්මක විය යුතු එක් ක්‍රියාදාමයක් සඳහා 'සරල if ප්‍රකාශය' (simple if statement) වඩාත් සුදුසු වේ. 'if-else' ප්‍රකාශය භාවිතා කරන්නේ කොන්දේසිය සත්‍ය හෝ අසත්‍ය යන දෙආකාරයටම වෙනස් ක්‍රියාදාමයන් ඇති විටය."
    },
    {
        questionText: "පහත දැක්වෙන කුමන අවස්ථාවකදී `do-while` ලූප් එකක් භාවිතා කිරීම වඩාත් සුදුසු වේද?",
        options: [
            "ලූප් එකේ ක්‍රියාත්මක වන වාර ගණන කලින්ම දන්නා විට",
            "ලූප් එකේ කොන්දේසිය මුලින්ම පරීක්ෂා කර, සත්‍ය නම් පමණක් ක්‍රියාත්මක විය යුතු විට",
            "ලූප් එකේ කේත කොටස අවම වශයෙන් එක් වරක්වත් ක්‍රියාත්මක විය යුතු විට",
            "බහුවිධ කොන්දේසි මත පදනම්ව විවිධ කේත කොටස් ක්‍රියාත්මක කිරීමට",
            "දත්ත ගොනුවක් කියවීමට"
        ],
        correctAnswerIndex: 2,
        explanation: "`do-while` ලූප් එකේ විශේෂත්වය වන්නේ එහි කොන්දේසිය ලූප් එකේ අවසානයේදී පරීක්ෂා කිරීමයි. එබැවින්, කොන්දේසිය කුමක් වුවත්, ලූප් එකේ කේත කොටස අවම වශයෙන් එක් වරක්වත් ක්‍රියාත්මක වීම සහතික කරයි. මෙය පරිශීලක ආදානය පරීක්ෂා කිරීම වැනි අවස්ථාවන් සඳහා ප්‍රයෝජනවත් වේ."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී 'නිරන්තර පුනරාවර්තනය (infinite loop)' වළක්වා ගැනීම සඳහා `while` ලූප් එකක් තුළ අත්‍යවශ්‍ය වන්නේ කුමක්ද?",
        options: [
            "ලූප් එක ආරම්භ වීමට පෙර කොන්දේසියක් නොතිබීම",
            "ලූප් එක තුළ කොන්දේසිය අසත්‍ය කරන ප්‍රකාශනයක් තිබීම",
            "ලූප් එක තුළ `break` ප්‍රකාශනයක් භාවිතා කිරීම",
            "ලූප් එකේ ආරම්භක අගය ශුන්‍ය ලෙස සැකසීම",
            "ලූප් එකේ කොන්දේසිය සෑම විටම සත්‍ය වන පරිදි සකස් කිරීම"
        ],
        correctAnswerIndex: 1,
        explanation: "නිරන්තර පුනරාවර්තනයක් (infinite loop) වළක්වා ගැනීම සඳහා, `while` ලූප් එකක් තුළ, ලූප් කොන්දේසිය අවසානයේදී අසත්‍ය වීමට හේතු වන යම් ප්‍රකාශනයක් (උදා: කවුන්ටරයක් වැඩි කිරීම හෝ කොන්දේසියට සම්බන්ධ විචල්‍යයක අගය වෙනස් කිරීම) අත්‍යවශ්‍ය වේ. එසේ නොමැති නම්, කොන්දේසිය සෑම විටම සත්‍යව පවතින අතර ලූප් එක කිසිදා අවසන් නොවනු ඇත."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී `switch` ප්‍රකාශනයක් භාවිතා කිරීමේ ප්‍රධාන අරමුණ කුමක්ද?",
        options: [
            "සංකීර්ණ ගණනය කිරීම් සිදු කිරීම",
            "බහුවිධ කොන්දේසි මත පදනම්ව විවිධ කේත කොටස් ක්‍රියාත්මක කිරීමේදී `if-else if-else` දාමයක් සරල කිරීමට",
            "ලූප් එකක් තුළ ඇති දෝෂ නිවැරදි කිරීම",
            "දත්ත ගොනුවක් විවෘත කිරීම සහ කියවීම",
            "ශ්‍රූතියක (function) පරාමිති නිර්වචනය කිරීම"
        ],
        correctAnswerIndex: 1,
        explanation: "`switch` ප්‍රකාශනයක් යනු තේරීම් පාලන ව්‍යුහයකි. එය ප්‍රධාන වශයෙන් භාවිතා කරනුයේ එක් විචල්‍යයක අගය මත පදනම්ව බහුවිධ ක්‍රියාදාමයන්ගෙන් එකක් තේරීමටයි. මෙය `if-else if-else` ප්‍රකාශන දාමයකට විකල්පයක් වන අතර, කේතය වඩාත් කියවීමට පහසු සහ සංවිධානාත්මක කරයි, විශේෂයෙන් බහුවිධ කොන්දේසි ඇති විට."
    },
    {
        questionText: "පහත කේත කොටසෙහි, `nested for` ලූප් එකක ප්‍රතිඵලය කුමක්ද? for (i = 0; i < 2; i++) { for (j = 0; j < 2; j++) { print(i, j); } }",
        options: [
            "00 01 10 11",
            "00 11",
            "01 01",
            "0123",
            "දෝෂයක්"
        ],
        correctAnswerIndex: 0,
        explanation: "මෙය නිහිත (nested) `for` ලූප් එකකි. පිටත ලූප් එක `i = 0` සහ `i = 1` සඳහා ක්‍රියාත්මක වේ. සෑම `i` අගයක් සඳහාම, ඇතුළත ලූප් එක `j = 0` සහ `j = 1` සඳහා ක්‍රියාත්මක වේ. එබැවින් ප්‍රතිඵලය වනුයේ: (i=0, j=0), (i=0, j=1), (i=1, j=0), (i=1, j=1) යන අනුපිළිවෙලට '00 01 10 11' මුද්‍රණය වීමයි."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී 'if-else' ප්‍රකාශනයක් භාවිතා කරනුයේ කුමන තත්ත්වයක් කළමනාකරණය කිරීමටද?",
        options: [
            "ප්‍රකාශන අනුපිළිවෙල පවත්වා ගැනීමට",
            "නියත වාර ගණනක් ක්‍රියාදාමයක් නැවත කිරීමට",
            "එක් කොන්දේසියක් සත්‍ය වූ විට එක් ක්‍රියාදාමයක් ද, අසත්‍ය වූ විට තවත් ක්‍රියාදාමයක් ද සිදු කිරීමට",
            "දත්ත අරා (arrays) තුළ ගබඩා කිරීමට",
            "ක්‍රමලේඛ දෝෂ (bugs) සොයා ගැනීමට"
        ],
        correctAnswerIndex: 2,
        explanation: "`if-else` ප්‍රකාශනය යනු තේරීම් පාලන ව්‍යුහයකි. එය භාවිතා කරන්නේ යම් කොන්දේසියක් සත්‍ය නම් එක් කේත කොටසක් ක්‍රියාත්මක කිරීමටත්, එම කොන්දේසිය අසත්‍ය නම් තවත් වෙනත් කේත කොටසක් ක්‍රියාත්මක කිරීමටත්ය. මෙය ක්‍රමලේඛයක තර්කානුකූල ශාඛාකරණයට (branching) ඉඩ සලසයි."
    },
    {
        questionText: "පහත දැක්වෙන කේත කොටසෙහි `while` ලූප් එක නිවැරදිව ක්‍රියාත්මක වීම සඳහා අත්‍යවශ්‍ය වන වෙනස කුමක්ද? `num = 5; while (num > 0) { print('Hello'); }`",
        options: [
            "`num = 0;` ලෙස ලූප් එක ආරම්භ කිරීම",
            "`print('Hello');` ප්‍රකාශනය ඉවත් කිරීම",
            "`num -= 1;` වැනි ප්‍රකාශනයක් ලූප් එක තුළට ඇතුළත් කිරීම",
            "`while` වෙනුවට `for` ලූප් එකක් භාවිතා කිරීම",
            "කොන්දේසිය `num == 0` ලෙස වෙනස් කිරීම"
        ],
        correctAnswerIndex: 2,
        explanation: "මෙම `while` ලූප් එකේ `num` හි අගය කිසිදා වෙනස් නොවන බැවින්, `num > 0` යන කොන්දේසිය සෑම විටම සත්‍යව පවතී. මෙය නිරන්තර පුනරාවර්තනයක් (infinite loop) ඇති කරයි. මෙය වළක්වා ගැනීමට, `num -= 1;` වැනි ප්‍රකාශනයක් ලූප් එක තුළට ඇතුළත් කිරීමෙන්, `num` හි අගය ක්‍රමයෙන් අඩු වී අවසානයේදී කොන්දේසිය අසත්‍ය වන බැවින් ලූප් එක නිවැරදිව අවසන් වනු ඇත."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී පාලන ව්‍යුහයන් (control structures) නිවැරදිව භාවිත කිරීමේ ප්‍රධාන වැදගත්කම කුමක්ද?",
        options: [
            "ක්‍රමලේඛයේ ප්‍රමාණය වැඩි කිරීම",
            "ක්‍රමලේඛයේ දෝෂ ඇති කිරීම",
            "ක්‍රමලේඛයේ ක්‍රියාකාරීත්වය සහ තර්කය පාලනය කිරීම",
            "ක්‍රමලේඛ ලිවීමට ගතවන කාලය වැඩි කිරීම",
            "ක්‍රමලේඛය කියවීමට අපහසු කිරීම"
        ],
        correctAnswerIndex: 2,
        explanation: "පාලන ව්‍යුහයන් යනු ක්‍රමලේඛන භාෂාවක අත්‍යවශ්‍ය අංගයන්ය. ඒවා ක්‍රමලේඛයේ ප්‍රකාශන ක්‍රියාත්මක වන අනුපිළිවෙල (sequence), කොන්දේසි මත පදනම්ව තීරණ ගැනීම (selection) සහ යම් කේත කොටස් නැවත නැවත ක්‍රියාත්මක කිරීම (repetition) වැනි දෑ පාලනය කිරීමට උපකාරී වේ. මේවා ක්‍රමලේඛයක ක්‍රියාකාරීත්වය සහ තර්කය නිවැරදිව කළමනාකරණය කිරීම සඳහා අත්‍යවශ්‍ය වේ."
    },
    {
        questionText: "පහත සඳහන් කේත කොටසෙහි, x=5 විට ප්‍රතිඵලය කුමක්ද? `if (x < 10) { print('කුඩා'); } else if (x < 20) { print('මධ්‍යම'); } else { print('විශාල'); }`",
        options: [
            "කුඩා",
            "මධ්‍යම",
            "විශාල",
            "දෝෂයක්",
            "කිසිවක් මුද්‍රණය නොවේ"
        ],
        correctAnswerIndex: 0,
        explanation: "මෙහිදී `x` හි අගය 5 වේ. පළමු කොන්දේසිය `x < 10` (5 < 10) සත්‍ය වන බැවින් 'කුඩා' යන පාඨය මුද්‍රණය වේ. `if-else if-else` ව්‍යුහයකදී එක් කොන්දේසියක් සත්‍ය වූ පසු, ඉතිරි කොන්දේසි පරීක්ෂා නොකරනු ලැබේ."
    },
    {
        questionText: "යම් ක්‍රමලේඛනයකදී, පේලි 1 සිට 10 දක්වා වූ සංඛ්‍යා මුද්‍රණය කිරීම සඳහා වඩාත්ම කාර්යක්ෂම ලූප් ව්‍යුහය කුමක්ද?",
        options: [
            "nested if-else",
            "while loop",
            "for loop",
            "switch statement",
            "sequence of print statements"
        ],
        correctAnswerIndex: 2,
        explanation: "`for` ලූප් එක නියමිත පුනරාවර්තන වාර ගණනක් ඇති විට (මෙහි 10 වාරයක්) වඩාත් කාර්යක්ෂම සහ කියවීමට පහසු ලූප් ව්‍යුහය වේ. `while` ලූප් එකක් ද භාවිතා කළ හැකි වුවද, `for` ලූප් එක මෙවැනි අවස්ථා සඳහා විශේෂයෙන් නිර්මාණය කර ඇත."
    },
    {
        questionText: "ක්‍රමලේඛයකදී ලූප් (loop) එකක් තුළ `break` ප්‍රකාශනයක් භාවිතා කිරීමේ අරමුණ කුමක්ද?",
        options: [
            "ලූප් එකේ ඊළඟ පුනරාවෘත්තියට යාමට",
            "ලූප් එකේ කොන්දේසිය වෙනස් කිරීමට",
            "ලූප් එක ක්ෂණිකව අවසන් කර, ලූප් එකෙන් පසු ඇති කේත කොටසට යාමට",
            "ලූප් එක තුළ දෝෂයක් ඇති කිරීමට",
            "කිසිදු ක්‍රියාදාමයක් සිදු නොකිරීමට"
        ],
        correctAnswerIndex: 2,
        explanation: "`break` ප්‍රකාශනය භාවිතා කරනුයේ යම් කොන්දේසියක් සත්‍ය වූ විට ලූප් එක ක්ෂණිකව අවසන් කර, ලූප් එකෙන් පසු ඇති කේත කොටසට පාලනය පැවරීමටයි. මෙය ලූප් එකේ සාමාන්‍ය ක්‍රියාත්මක වීමේ රටාව කඩ කිරීමට භාවිතා කළ හැකිය."
    },
    {
        questionText: "ක්‍රමලේඛයකදී ලූප් (loop) එකක් තුළ `continue` ප්‍රකාශනයක් භාවිතා කිරීමේ අරමුණ කුමක්ද?",
        options: [
            "ලූප් එක ක්ෂණිකව අවසන් කිරීමට",
            "ලූප් එකේ කොන්දේසිය නැවත පරීක්ෂා කිරීමට",
            "ලූප් එකේ වත්මන් පුනරාවෘත්තියේ ඉතිරි කේත කොටස මග හැර, ඊළඟ පුනරාවෘත්තියට යාමට",
            "ලූප් එක නැවත ආරම්භ කිරීමට",
            "ලූප් එක තුළ නව විචල්‍යයක් නිර්මාණය කිරීමට"
        ],
        correctAnswerIndex: 2,
        explanation: "`continue` ප්‍රකාශනය භාවිතා කරනුයේ ලූප් එකේ වත්මන් පුනරාවෘත්තියේ (iteration) ඉතිරි කේත කොටස මග හැර, කෙලින්ම ලූප් එකේ ඊළඟ පුනරාවෘත්තියට යාමටයි. මෙය යම් නිශ්චිත කොන්දේසියක් යටතේ ලූප් එකේ කොටසක් මග හැරීමට ප්‍රයෝජනවත් වේ."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී, බහුවිධ කොන්දේසි පරීක්ෂා කිරීම සඳහා `if-else if-else` ව්‍යුහයක් භාවිතා කරන විට, කොන්දේසි පරීක්ෂා කරන්නේ කුමන අනුපිළිවෙලකටද?",
        options: [
            "අහඹු අනුපිළිවෙලකට",
            "පහළ සිට ඉහළට",
            "මුලින්ම `else` කොටස පරීක්ෂා කරයි",
            "ඉහළ සිට පහළට, පළමු සත්‍ය කොන්දේසිය හමු වූ පසු ඉතිරිය මග හරියි",
            "සියලුම කොන්දේසි එකවර පරීක්ෂා කරයි"
        ],
        correctAnswerIndex: 3,
        explanation: "`if-else if-else` ව්‍යුහයකදී, කොන්දේසි ඉහළ සිට පහළට අනුපිළිවෙලින් පරීක්ෂා කරනු ලැබේ. පළමු වරට සත්‍ය වන කොන්දේසියට අදාළ කේත කොටස ක්‍රියාත්මක වන අතර, ඉතිරි කොන්දේසි කිසිවක් පරීක්ෂා නොකරනු ඇත. මෙය කාර්යක්ෂමතාවයට වැදගත් වේ."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී තීරණ ගැනීමේ යාන්ත්‍රණයක් ලෙස `switch` ප්‍රකාශනයක් භාවිතා කරන විට, `default` කොටසෙහි අරමුණ කුමක්ද?",
        options: [
            "සෑම විටම ක්‍රියාත්මක වන කේත කොටසක් සැපයීමට",
            "කුමන `case` එකක්වත් නොගැළපෙන විට ක්‍රියාත්මක වන කේත කොටසක් සැපයීමට",
            "`switch` ප්‍රකාශනය අවසන් කිරීමට",
            "නව `case` අගයක් නිර්වචනය කිරීමට",
            "දෝෂ පණිවිඩයක් ජනනය කිරීමට"
        ],
        correctAnswerIndex: 1,
        explanation: "`switch` ප්‍රකාශනයක `default` කොටස විකල්ප වේ. එය භාවිතා කරනුයේ `switch` ප්‍රකාශනයේ ඇති කිසිදු `case` අගයක්, පරීක්ෂා කරන විචල්‍යයේ අගයට නොගැළපෙන විට ක්‍රියාත්මක විය යුතු කේත කොටසක් සැපයීමටයි. මෙය 'අල්ලා නොගත්' තත්ත්වයන් (unhandled cases) කළමනාකරණය කිරීමට උපකාරී වේ."
    },
    {
        questionText: "පහත දැක්වෙන කේත කොටසෙහි, `count = 0; while (count < 5) { print(count); count++; }` ලූප් එකෙන් පසුව `count` විචල්‍යයේ අවසාන අගය කුමක්ද?",
        options: [
            "0",
            "4",
            "5",
            "6",
            "undefined"
        ],
        correctAnswerIndex: 2,
        explanation: "ලූප් එක `count` හි අගය 0, 1, 2, 3, 4 යන අගයන් සඳහා ක්‍රියාත්මක වන අතර, 4 මුද්‍රණය කිරීමෙන් පසු `count` 5 වේ. ඉන්පසු `while (5 < 5)` කොන්දේසිය අසත්‍ය වන බැවින් ලූප් එක අවසන් වේ. එබැවින්, ලූප් එක අවසන් වන විට `count` හි අවසාන අගය 5 වේ."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී 'නිරන්තර පුනරාවර්තනයක් (infinite loop)' ඇති විය හැකි ප්‍රධාන හේතුවක් කුමක්ද?",
        options: [
            "ලූප් එක තුළ `break` ප්‍රකාශනයක් භාවිතා කිරීම",
            "ලූප් එකේ කොන්දේසිය සෑම විටම සත්‍ය ලෙස පැවතීම",
            "ලූප් එකේ ආරම්භක අගය ශුන්‍ය වීම",
            "ලූප් එකේ `print` ප්‍රකාශනයක් තිබීම",
            "ලූප් එක තුළ `continue` ප්‍රකාශනයක් තිබීම"
        ],
        correctAnswerIndex: 1,
        explanation: "නිරන්තර පුනරාවර්තනයක් ඇති වන්නේ ලූප් එකේ අවසන් වීමේ කොන්දේසිය කිසිදා අසත්‍ය නොවන විටය. එනම්, ලූප් එකේ කොන්දේසිය සෑම විටම සත්‍ය ලෙස පවතින විට, ලූප් එක කිසිදා අවසන් නොවී දිගින් දිගටම ක්‍රියාත්මක වේ."
    },
    {
        questionText: "පාලන ව්‍යුහයක් තෝරා ගැනීමේදී, යම් කොන්දේසියක් සත්‍ය නම් පමණක් කේත කොටසක් ක්‍රියාත්මක කළ යුතු නමුත්, එම කොන්දේසිය අසත්‍ය නම් කිසිවක් සිදු නොකළ යුතු අවස්ථාවකදී වඩාත් සුදුසු වන්නේ කුමක්ද?",
        options: [
            "if-else ප්‍රකාශය",
            "switch ප්‍රකාශය",
            "සරල if ප්‍රකාශය",
            "for ලූප් එක",
            "while ලූප් එක"
        ],
        correctAnswerIndex: 2,
        explanation: "මෙවැනි අවස්ථාවක, 'සරල if ප්‍රකාශය' (simple if statement) වඩාත් සුදුසු වේ. එය කොන්දේසිය සත්‍ය නම් පමණක් කේත කොටසක් ක්‍රියාත්මක කිරීමට ඉඩ සලසන අතර, කොන්දේසිය අසත්‍ය නම් කිසිදු විකල්ප ක්‍රියාදාමයක් නියම නොකරයි."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී, 'ලූප් (loop)' යන වචනයෙන් සාමාන්‍යයෙන් අදහස් කරන්නේ කුමක්ද?",
        options: [
            "ක්‍රමලේඛය ආරම්භ වන ස්ථානය",
            "ක්‍රමලේඛයේ අවසානය",
            "යම් කේත කොටසක් නැවත නැවත ක්‍රියාත්මක කරන පාලන ව්‍යුහයක්",
            "දත්ත ගබඩා කරන ස්ථානය",
            "දෝෂ හඳුනා ගන්නා මෙවලමක්"
        ],
        correctAnswerIndex: 2,
        explanation: "'ලූප්' (loop) යනු ක්‍රමලේඛනයේදී යම් කේත කොටසක් නියමිත වාර ගණනක් හෝ යම් කොන්දේසියක් සත්‍ය වන තුරු නැවත නැවත ක්‍රියාත්මක කිරීමට භාවිතා කරන පාලන ව්‍යුහයකි. මෙය පුනරාවෘත්තිය (repetition) යන සංකල්පය නියෝජනය කරයි."
    },

    // 9.9: ක්‍රමලේඛනයේ දී උප ක්‍රමලේඛ (subprograms) භාවිත කරයි. (Subprograms/Functions)
    {
        questionText: "ක්‍රමලේඛනයකදී ශ්‍රූතියක (function) ප්‍රධාන අරමුණ කුමක්ද?",
        options: [
            "ප්‍රධාන ක්‍රමලේඛයේ ඇති සියලුම විචල්‍යයන් ගෝලීය (global) ලෙස ප්‍රකාශ කිරීමට",
            "ක්‍රමලේඛයේ ඇති දෝෂ හඳුනා ගැනීමට",
            "යම් නිශ්චිත කාර්යයක් ඉටු කරන, නැවත නැවත භාවිතා කළ හැකි කේත කොටසක් නිර්මාණය කිරීමට",
            "දත්ත ගොනුවක් විවෘත කිරීමට සහ එහි අන්තර්ගතය වෙනස් කිරීමට",
            "දත්ත සමුදායකට සම්බන්ධ වීමට"
        ],
        correctAnswerIndex: 2,
        explanation: "ශ්‍රූතියක් (function) යනු යම් නිශ්චිත කාර්යයක් ඉටු කිරීම සඳහා නිර්මාණය කර ඇති, නැවත නැවත භාවිතා කළ හැකි කේත කොටසකි. මෙය ක්‍රමලේඛය කුඩා, කළමනාකරණය කළ හැකි කොටස් වලට බෙදීමට (modularity) සහ කේතය නැවත භාවිතා කිරීමේ හැකියාවට (reusability) උපකාරී වේ."
    },
    {
        questionText: "පහත දැක්වෙන ශ්‍රූතියේ `num1` සහ `num2` කුමක් ලෙස හඳුන්වන්නේද? `function add(num1, num2) { return num1 + num2; }`",
        options: [
            "ආපසු එන අගයන් (return values)",
            "තර්ක (arguments)",
            "පරාමිති (parameters)",
            "ගෝලීය විචල්‍ය (global variables)",
            "ශ්‍රූති නාමයන් (function names)"
        ],
        correctAnswerIndex: 2,
        explanation: "ශ්‍රූතියක් නිර්වචනය කරන විට වරහන් තුළ සඳහන් කරනු ලබන විචල්‍යයන් 'පරාමිති (parameters)' ලෙස හැඳින්වේ. මේවා ශ්‍රූතියට ඇතුළු කරන අගයන් ග්‍රහණය කර ගැනීමට භාවිතා වේ. ශ්‍රූතියක් කැඳවන විට යොදන සත්‍ය අගයන් 'තර්ක (arguments)' ලෙස හැඳින්වේ."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී 'ස්ථානීය විචල්‍යයක් (local variable)' පිළිබඳ නිවැරදි ප්‍රකාශය කුමක්ද?",
        options: [
            "ක්‍රමලේඛයේ ඕනෑම තැනක සිට ප්‍රවේශ විය හැකි විචල්‍යයක්",
            "ශ්‍රූතියක් තුළ පමණක් ප්‍රකාශ කර ඇති අතර, එම ශ්‍රූතියෙන් පිටත සිට ප්‍රවේශ විය නොහැකි විචල්‍යයක්",
            "ප්‍රධාන ක්‍රමලේඛයේ ආරම්භයේදී ප්‍රකාශ කරන ලද විචල්‍යයක්",
            "කිසිදු ශ්‍රූතියක් තුළ ප්‍රකාශ නොකරන ලද විචල්‍යයක්",
            "එකවර බහුවිධ අගයන් ගබඩා කළ හැකි විචල්‍යයක්"
        ],
        correctAnswerIndex: 1,
        explanation: "ස්ථානීය විචල්‍යයක් (local variable) යනු ශ්‍රූතියක් (function) හෝ කේත කොටසක් (block) තුළ ප්‍රකාශ කර ඇති විචල්‍යයකි. එයට ප්‍රවේශ විය හැක්කේ එම ශ්‍රූතිය හෝ කේත කොටස තුළ සිට පමණක් වන අතර, එය එම ශ්‍රූතියේ හෝ කේත කොටසේ 'පරාසය (scope)' තුළ පමණක් පවතී. ශ්‍රූතියේ ක්‍රියාත්මක වීම අවසන් වූ විට ස්ථානීය විචල්‍යය විනාශ වේ."
    },
    {
        questionText: "ශ්‍රූතියක් මගින් යම් ගණනය කිරීමක් හෝ ක්‍රියාදාමයක් සිදු කිරීමෙන් පසු, එම ක්‍රියාදාමයේ ප්‍රතිඵලය ප්‍රධාන ක්‍රමලේඛයට ආපසු ලබා දීමට භාවිතා කරන ප්‍රධාන ක්‍රමලේඛන අංගය කුමක්ද?",
        options: [
            "print ප්‍රකාශනය",
            "input ප්‍රකාශනය",
            "return ප්‍රකාශනය",
            "ලූප් (loop) ප්‍රකාශනය",
            "if ප්‍රකාශනය"
        ],
        correctAnswerIndex: 2,
        explanation: "`return` ප්‍රකාශනය භාවිතා කරනුයේ ශ්‍රූතියක් මගින් යම් අගයක් ගණනය කිරීමෙන් හෝ ක්‍රියාදාමයක් සිදු කිරීමෙන් පසු, එම අගය ශ්‍රූතිය කැඳවූ ස්ථානයට ආපසු ලබා දීමටයි. මෙය ශ්‍රූතියක ප්‍රතිඵලය ප්‍රධාන ක්‍රමලේඛය තුළ භාවිත කිරීමට ඉඩ සලසයි."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී 'ගෝලීය විචල්‍යයක් (global variable)' පිළිබඳ නිවැරදි ප්‍රකාශය කුමක්ද?",
        options: [
            "ශ්‍රූතියක් තුළ පමණක් ප්‍රකාශ කළ හැකි විචල්‍යයක්",
            "කිසිදු ශ්‍රූතියකින් ප්‍රවේශ විය නොහැකි විචල්‍යයක්",
            "ක්‍රමලේඛයේ ඕනෑම තැනක සිට, ඕනෑම ශ්‍රූතියක් තුළින් ප්‍රවේශ විය හැකි විචල්‍යයක්",
            "නියත අගයක් පමණක් ගබඩා කළ හැකි විචල්‍යයක්",
            "ශ්‍රූතියකට පරාමිති ලෙස පමණක් යැවිය හැකි විචල්‍යයක්"
        ],
        correctAnswerIndex: 2,
        explanation: "ගෝලීය විචල්‍යයක් (global variable) යනු ක්‍රමලේඛයේ ඕනෑම ස්ථානයක සිට ප්‍රවේශ විය හැකි විචල්‍යයකි. එය කිසිදු ශ්‍රූතියක් හෝ කේත කොටසක් තුළ සීමා නොවේ. කෙසේ වෙතත්, ගෝලීය විචල්‍යයන් භාවිතය පාලනය කළ යුතුය, මන්ද ඒවායේ අගයන් අනපේක්ෂිත ලෙස වෙනස් විය හැකි බැවිනි."
    },
    {
        questionText: "ශ්‍රූතියකට පරාමිති යැවීමේදී, එම පරාමිති සඳහා පෙරනිමි අගයන් (default values) සැපයීමේ වාසිය කුමක්ද?",
        options: [
            "ශ්‍රූතියේ ක්‍රියාත්මක වන වේගය වැඩි කිරීම",
            "පරාමිති නැතිව ශ්‍රූතිය කැඳවිය නොහැකි වීම",
            "සෑම විටම එම පරාමිති සඳහා අගයන් ලබා දීම අනිවාර්ය කිරීම",
            "පරාමිතියක් සඳහා අගයක් ලබා නොදුන්නද ශ්‍රූතියට දෝෂයකින් තොරව ක්‍රියාත්මක වීමට ඉඩ දීම",
            "ශ්‍රූතියේ නම වෙනස් කිරීමට"
        ],
        correctAnswerIndex: 3,
        explanation: "ශ්‍රූතියක පරාමිති සඳහා පෙරනිමි අගයන් (default values) සැපයීමෙන්, ශ්‍රූතිය කැඳවන විට එම පරාමිතිය සඳහා අගයක් ලබා නොදුන්නද, පෙරනිමි අගය ස්වයංක්‍රීයව භාවිතා වේ. මෙය ශ්‍රූතිය වඩාත් නම්‍යශීලී කරන අතර, සමහර අවස්ථාවලදී පරාමිති අගයන් ලබා දීම අනිවාර්ය නොවේ."
    },
    {
        questionText: "පහත දැක්වෙන ක්‍රමලේඛයේ `x` හි අවසාන අගය කුමක්ද? `x = 10; function modifyX() { x = 20; } modifyX();`",
        options: [
            "10",
            "20",
            "undefined",
            "දෝෂයක්",
            "කිසිවක් වෙනස් නොවේ"
        ],
        correctAnswerIndex: 1,
        explanation: "මෙහි `x` යනු ගෝලීය විචල්‍යයකි. `modifyX()` ශ්‍රූතිය තුළ `x = 20` ලෙස ප්‍රකාශ කිරීමෙන් ගෝලීය `x` හි අගය වෙනස් වේ. එබැවින්, ශ්‍රූතිය ක්‍රියාත්මක වීමෙන් පසු `x` හි අගය 20 වේ."
    },
    {
        questionText: "පහත දැක්වෙන කුමන අවස්ථාවකදී 'තූළබැඳි / තූළැලි (Built-in) ශ්‍රූතියක්' භාවිතා කරන්නේද?",
        options: [
            "ගැටලුවකට නිශ්චිත විසඳුමක් ලෙස නව ශ්‍රූතියක් නිර්මාණය කිරීමට",
            "ක්‍රමලේඛන භාෂාවෙන් දැනටමත් සපයා ඇති, පොදු කාර්යයන් සඳහා නිර්මාණය කර ඇති ශ්‍රූතියක් භාවිතා කිරීමට",
            "ශ්‍රූතියක් තුළ තවත් ශ්‍රූතියක් අර්ථ දැක්වීමට",
            "දත්ත සමුදායකින් දත්ත කියවීමට",
            "විශාල දත්ත ගොනුවක් කළමනාකරණය කිරීමට"
        ],
        correctAnswerIndex: 1,
        explanation: "තූළබැඳි / තූළැලි (Built-in) ශ්‍රූති යනු ක්‍රමලේඛන භාෂාව සමඟම පැමිණෙන, පොදු සහ නිතර භාවිතා වන කාර්යයන් (උදා: ගණිතමය ක්‍රියා, String manipulation) ඉටු කිරීම සඳහා නිර්මාණය කර ඇති ශ්‍රූති වේ. මේවා පරිශීලකයා විසින් අලුතින් ලිවිය යුතු නැත, ඒවා කෙලින්ම භාවිතා කළ හැකිය."
    },
    {
        questionText: "පරිශීලක නිර්වාත (user-defined) ශ්‍රූතියක් නිර්මාණය කිරීමේ ප්‍රධාන වාසිය කුමක්ද?",
        options: [
            "පවතින ක්‍රමලේඛන භාෂාවේ ශ්‍රූති වෙනස් කිරීමට",
            "ක්‍රමලේඛය වඩාත් සංකීර්ණ කිරීමට",
            "නැවත නැවත භාවිතා කළ හැකි සහ නිශ්චිත ගැටළු විසඳන කේත කොටස් නිර්මාණය කිරීමට",
            "දත්ත සමුදා සම්බන්ධතා වේගවත් කිරීමට",
            "ක්‍රමලේඛයේ ප්‍රමාණය අඩු කිරීමට"
        ],
        correctAnswerIndex: 2,
        explanation: "පරිශීලක නිර්වාත ශ්‍රූති (user-defined functions) මගින් ක්‍රමලේඛකයාට තමන්ගේම අවශ්‍යතාවයන්ට අනුව නිශ්චිත කාර්යයන් ඉටු කරන කේත කොටස් නිර්මාණය කිරීමට ඉඩ සලසයි. මෙය කේතය නැවත භාවිතා කිරීම, ක්‍රමලේඛය කුඩා කොටස් වලට බෙදීම (modularity) සහ කියවීමේ පහසුව වැඩි දියුණු කරයි."
    },
    {
        questionText: "ක්‍රමලේඛයකදී විචල්‍යයක 'ආයු කාලය (lifetime)' යන්නෙන් අදහස් කරන්නේ කුමක්ද?",
        options: [
            "විචල්‍යයට අගයක් ලබා දිය හැකි උපරිම කාලය",
            "විචල්‍යයක් මත සිදු කළ හැකි මෙහෙයුම් ගණන",
            "විචල්‍යය මතකය තුළ පවතින කාල සීමාව",
            "විචල්‍යයක අගය වෙනස් කළ හැකි වාර ගණන",
            "විචල්‍යයක් ප්‍රකාශ කළ හැකි ස්ථාන ගණන"
        ],
        correctAnswerIndex: 2,
        explanation: "විචල්‍යයක 'ආයු කාලය (lifetime)' යනු ක්‍රමලේඛයේ ක්‍රියාත්මක වීමේදී එම විචල්‍යය මතකය තුළ පවතින කාල සීමාවයි. ස්ථානීය විචල්‍යයක ආයු කාලය එය ප්‍රකාශ කර ඇති ශ්‍රූතිය හෝ කේත කොටස ක්‍රියාත්මක වන තුරු පමණක් වන අතර, ගෝලීය විචල්‍යයක ආයු කාලය සාමාන්‍යයෙන් ක්‍රමලේඛයේ සමස්ත ක්‍රියාත්මක කාලය පුරාවටම පවතී."
    },
    {
        questionText: "පරාමිති 'අගය අනුව යැවීම (pass by value)' සහ 'යොමුව අනුව යැවීම (pass by reference)' අතර ඇති ප්‍රධාන වෙනස කුමක්ද?",
        options: [
            "අගය අනුව යැවීමේදී පරාමිතිය වෙනස් කළ නොහැකි අතර, යොමුව අනුව යැවීමේදී වෙනස් කළ හැකිය.",
            "අගය අනුව යැවීමේදී පරාමිතියේ පිටපතක් යවනු ලබන අතර, යොමුව අනුව යැවීමේදී විචල්‍යයේ මතක ස්ථානය යවනු ලබයි.",
            "අගය අනුව යැවීමේදී පරාමිති ගණන සීමිත වන අතර, යොමුව අනුව යැවීමේදී සීමාවක් නොමැත.",
            "අගය අනුව යැවීමේදී ශ්‍රූතියට ප්‍රතිාගමන අගයක් තිබිය යුතු අතර, යොමුව අනුව යැවීමේදී අවශ්‍ය නොවේ.",
            "අගය අනුව යැවීම වේගවත් වන අතර, යොමුව අනුව යැවීම මන්දගාමී වේ."
        ],
        correctAnswerIndex: 1,
        explanation: "අගය අනුව යැවීමේදී (pass by value), ශ්‍රූතියට පරාමිතියේ අගයේ පිටපතක් යවනු ලැබේ. එබැවින්, ශ්‍රූතිය තුළ සිදු කරන ඕනෑම වෙනස්කමක් පිටපතට පමණක් බලපාන අතර මුල් විචල්‍යයට බලපාන්නේ නැත. යොමුව අනුව යැවීමේදී (pass by reference), විචල්‍යයේ මතක ස්ථානය (memory address) යවනු ලබන අතර, ශ්‍රූතිය තුළ සිදු කරන වෙනස්කම් මුල් විචල්‍යයට ද බලපායි."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී ශ්‍රූතියක් 'ඕවර්ලෝඩ් (overload)' කිරීම යන්නෙන් අදහස් කරන්නේ කුමක්ද?",
        options: [
            "ශ්‍රූතියක් ඉතා විශාල වන විට එය කොටස් වලට කැඩීම",
            "එකම ශ්‍රූතියක් නැවත නැවත කැඳවීම",
            "වෙනස් පරාමිති ගණනක් හෝ වර්ගයක් ඇති නමුත් එකම නමකින් යුත් ශ්‍රූති කිහිපයක් නිර්මාණය කිරීම",
            "ශ්‍රූතියක් තුළ දෝෂයක් ඇති කිරීම",
            "ශ්‍රූතියක් ඉතා වේගයෙන් ක්‍රියාත්මක කිරීම"
        ],
        correctAnswerIndex: 2,
        explanation: "ශ්‍රූති ඕවර්ලෝඩ් කිරීම (function overloading) යනු එකම නමකින් යුත් නමුත් වෙනස් පරාමිති (parameters) සංයුති (සංඛ්‍යාව හෝ දත්ත වර්ගය) ඇති ශ්‍රූති කිහිපයක් නිර්මාණය කිරීමයි. මෙය ක්‍රමලේඛකයාට එකම කාර්යය සඳහා විවිධ ආදාන දත්ත සමඟ කටයුතු කිරීමට ඉඩ සලසන අතර, කේතය වඩාත් කියවීමට පහසු කරයි."
    },
    {
        questionText: "පහත දැක්වෙන ක්‍රමලේඛයේ `calculateArea` ශ්‍රූතියේ ප්‍රතිඵලය කුමක්ද? `function calculateArea(length, width) { return length * width; } let result = calculateArea(5, 4);`",
        options: [
            "9",
            "20",
            "undefined",
            "දෝෂයක්",
            "length * width"
        ],
        correctAnswerIndex: 1,
        explanation: "`calculateArea` ශ්‍රූතිය `length` (5) සහ `width` (4) යන පරාමිති ලබාගෙන ඒවායේ ගුණිතය (5 * 4 = 20) ආපසු ලබා දෙයි. එබැවින් `result` විචල්‍යයට 20 යන අගය පැවරේ."
    },
    {
        questionText: "ශ්‍රූතියකට පරාමිති කිසිවක් නොයවා, එයින් කිසිදු අගයක් ආපසු ලබා නොගෙන ක්‍රියාත්මක කළ හැකිද?",
        options: [
            "නොහැකිය, ශ්‍රූතියක් ක්‍රියාත්මක වීමට පරාමිති අනිවාර්ය වේ.",
            "නොහැකිය, ශ්‍රූතියකට සෑම විටම ප්‍රතිාගමන අගයක් තිබිය යුතුය.",
            "හැකිය, එයින් අදහස් වන්නේ ශ්‍රූතිය අභ්‍යන්තර ක්‍රියාවක් පමණක් සිදු කරන බවයි.",
            "හැකිය, නමුත් එයින් කිසිදු ප්‍රතිලාභයක් නොලැබේ.",
            "එය ක්‍රමලේඛන භාෂාව මත රඳා පවතී."
        ],
        correctAnswerIndex: 2,
        explanation: "ඔව්, ශ්‍රූතියකට පරාමිති කිසිවක් නොයවා හෝ කිසිදු අගයක් ආපසු ලබා නොගෙන ක්‍රියාත්මක කළ හැකිය. මෙවැනි ශ්‍රූති සාමාන්‍යයෙන් යම් අභ්‍යන්තර ක්‍රියාවක් (උදා: තිරය මත පණිවිඩයක් මුද්‍රණය කිරීම, ගොනුවකට දත්ත ලිවීම) සිදු කිරීමට භාවිතා වේ. ඒවාට 'void' ශ්‍රූති ලෙසද හැඳින්විය හැකිය."
    },
    {
        questionText: "ශ්‍රූතියක පරාසය (scope) යන්නෙන් අදහස් කරන්නේ කුමක්ද?",
        options: [
            "ශ්‍රූතිය ක්‍රියාත්මක වන වාර ගණන",
            "ශ්‍රූතියක් තුළ නිර්මාණය කළ හැකි උපරිම විචල්‍ය සංඛ්‍යාව",
            "විචල්‍යයකට හෝ ශ්‍රූතියකට ප්‍රවේශ විය හැකි ක්‍රමලේඛයේ කොටස",
            "ශ්‍රූතියක් මගින් ආපසු ලබා දෙන අගය",
            "ශ්‍රූතියක් තුළ ඇති දෝෂ ගණන"
        ],
        correctAnswerIndex: 2,
        explanation: "ශ්‍රූතියක පරාසය (scope) යනු ක්‍රමලේඛයක කේත කොටසකි, එහිදී යම් විචල්‍යයක් හෝ ශ්‍රූතියක් ප්‍රකාශ කර ඇති අතර එයට ප්‍රවේශ විය හැකිය. උදාහරණයක් ලෙස, ශ්‍රූතියක් තුළ ප්‍රකාශ කරන ලද ස්ථානීය විචල්‍යයකට ප්‍රවේශ විය හැක්කේ එම ශ්‍රූතිය තුළ සිට පමණි."
    },
    {
        questionText: "පහත දැක්වෙන ක්‍රමලේඛයේ `total` විචල්‍යයේ පරාසය කුමක්ද? `let total = 0; function calculateSum(a, b) { let sum = a + b; total = sum; }`",
        options: [
            "`calculateSum` ශ්‍රූතිය තුළ පමණි",
            "ගෝලීය පරාසය (global scope)",
            "`sum` විචල්‍යයේ පරාසය",
            "දෝෂයක් ඇති කරයි",
            "කිසිදු පරාසයක් නොමැත"
        ],
        correctAnswerIndex: 1,
        explanation: "`total` විචල්‍යය කිසිදු ශ්‍රූතියක් තුළ ප්‍රකාශ කර නොමැති බැවින්, එය ගෝලීය විචල්‍යයක් වන අතර, ක්‍රමලේඛයේ ඕනෑම තැනක සිට එයට ප්‍රවේශ විය හැකිය. `sum` විචල්‍යය ස්ථානීය විචල්‍යයකි."
    },
    {
        questionText: "ශ්‍රූතියක් කැඳවන විට, එම ශ්‍රූතියට යොදන සත්‍ය අගයන් කුමක් ලෙස හඳුන්වන්නේද?",
        options: [
            "පරාමිති (parameters)",
            "ආපසු එන අගයන් (return values)",
            "තර්ක (arguments)",
            "විචල්‍ය (variables)",
            "පෙරනිමි අගයන් (default values)"
        ],
        correctAnswerIndex: 2,
        explanation: "ශ්‍රූතියක් කැඳවන විට, ශ්‍රූතියේ පරාමිති වලට අනුරූපව යොදන සත්‍ය අගයන් 'තර්ක (arguments)' ලෙස හැඳින්වේ. මෙම තර්ක, ශ්‍රූතියේ නිර්වචනයේ ඇති පරාමිති වලට පිටපත් කරනු ලැබේ (අගය අනුව යැවීමේදී) හෝ යොමු කරනු ලැබේ (යොමුව අනුව යැවීමේදී)."
    },
    {
        questionText: "පහත දැක්වෙන ශ්‍රූතියේ, `greeting` පරාමිතිය සඳහා පෙරනිමි අගයක් සැපයීම සඳහා නිවැරදි ක්‍රමය කුමක්ද? `function sayHello(name, greeting) { print(greeting + ', ' + name); }`",
        options: [
            "`function sayHello(name, greeting = 'Hello')`",
            "`function sayHello(name, greeting) { greeting = 'Hello'; ... }`",
            "`function sayHello(name, default greeting)`",
            "`function sayHello(name, greeting?)`",
            "`function sayHello(name, greeting: 'Hello')`"
        ],
        correctAnswerIndex: 0,
        explanation: "බොහෝ ක්‍රමලේඛන භාෂාවලදී (උදා: JavaScript, Python), ශ්‍රූතියක පරාමිතියක් සඳහා පෙරනිමි අගයක් ලබා දීමට, පරාමිතියේ නමට පසුව `=` ලකුණ යොදා එම අගය සඳහන් කරයි. `function sayHello(name, greeting = 'Hello')` යනු නිවැරදි ක්‍රමයයි."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී ශ්‍රූති භාවිත කිරීමෙන් ලැබෙන වාසියක් නොවන්නේ කුමක්ද?",
        options: [
            "කේතය නැවත භාවිතා කිරීමේ හැකියාව (reusability)",
            "ක්‍රමලේඛයේ කියවීමේ පහසුව (readability)",
            "ක්‍රමලේඛය සංවිධානාත්මක කිරීම (organization)",
            "දෝෂ නිවැරදි කිරීමේ පහසුව (easier debugging)",
            "ක්‍රමලේඛයේ සමස්ත ක්‍රියාත්මක වන වේගය අනිවාර්යයෙන්ම වැඩි වීම"
        ],
        correctAnswerIndex: 4,
        explanation: "ශ්‍රූති භාවිතයෙන් කේතය නැවත භාවිතා කිරීම, කියවීමේ පහසුව සහ සංවිධානාත්මක බව වැඩි දියුණු වේ. දෝෂ නිවැරදි කිරීම ද පහසු වේ, මන්ද ඔබට කුඩා, නිශ්චිත කේත කොටස් පරීක්ෂා කළ හැකි බැවිනි. කෙසේ වෙතත්, ශ්‍රූති කැඳවීමට අමතර පරිගණක සම්පත් අවශ්‍ය විය හැකි බැවින්, ක්‍රමලේඛයේ සමස්ත ක්‍රියාත්මක වන වේගය අනිවාර්යයෙන්ම වැඩි වේ යැයි පැවසිය නොහැක; සමහර විට එය සුළු වශයෙන් අඩුවිය හැකිය."
    },
    {
        questionText: "පහත ක්‍රමලේඛයේ `result` විචල්‍යයේ පරාසය කුමක්ද? `function calculate(a, b) { let result = a * b; return result; } print(calculate(2, 3));`",
        options: [
            "ගෝලීය පරාසය",
            "`calculate` ශ්‍රූතිය තුළ පමණි (ස්ථානීය පරාසය)",
            "print ප්‍රකාශනය තුළ පමණි",
            "ක්‍රමලේඛයේ ඕනෑම තැනක",
            "Undefined"
        ],
        correctAnswerIndex: 1,
        explanation: "`result` විචල්‍යය `calculate` ශ්‍රූතිය තුළ `let` මගින් ප්‍රකාශ කර ඇති බැවින් එය ස්ථානීය විචල්‍යයකි. එයට ප්‍රවේශ විය හැක්කේ `calculate` ශ්‍රූතිය තුළ සිට පමණක් වන අතර, ශ්‍රූතිය ක්‍රියාත්මක වීම අවසන් වූ පසු එය විනාශ වේ."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී ශ්‍රූතියක් මගින් අගයක් ආපසු ලබා නොදුන්නද, එයින් සිදුවන ක්‍රියාවක් පිළිබඳ නිවැරදි උදාහරණයක් කුමක්ද?",
        options: [
            "අංක දෙකක් එකතු කර එහි එකතුව ලබා දීම",
            "දත්ත සමුදායකින් වාර්තා ගණනක් ලබා ගැනීම",
            "තිරය මත පරිශීලකයාට පණිවිඩයක් මුද්‍රණය කිරීම",
            "අරා (array) එකක් වර්ග කිරීම",
            "ගණිතමය ගණනයක් සිදු කිරීම"
        ],
        correctAnswerIndex: 2,
        explanation: "ශ්‍රූතියක් අගයක් ආපසු ලබා නොදුන්නද, එයට 'side effects' ලෙස හඳුන්වන ක්‍රියා සිදු කළ හැකිය. උදාහරණයක් ලෙස, තිරය මත පණිවිඩයක් මුද්‍රණය කිරීම, ගොනුවකට ලිවීම හෝ දත්ත සමුදායක් වෙනස් කිරීම වැනි දෑ. 'තිරය මත පරිශීලකයාට පණිවිඩයක් මුද්‍රණය කිරීම' යනු මෙවැනි ශ්‍රූතියකට හොඳ උදාහරණයකි, එහිදී ප්‍රයෝජනවත් ක්‍රියාවක් සිදු වුවද, කිසිදු අගයක් ආපසු නොලැබේ."
    },
    {
        questionText: "ශ්‍රූතියක ව්‍යුහය (structure) පිළිබඳව සලකන විට, අත්‍යවශ්‍ය නොවන කොටසක් කුමක්ද?",
        options: [
            "ශ්‍රූතියේ නම",
            "පරාමිති ලැයිස්තුව (හිස් විය හැක)",
            "ශ්‍රූතියේ කේත කොටස",
            "return ප්‍රකාශනය (අගයක් ආපසු දෙන ශ්‍රූති සඳහා පමණි)",
            "ශ්‍රූතියට පෙර ගෝලීය විචල්‍යයන් ප්‍රකාශ කිරීම"
        ],
        correctAnswerIndex: 4,
        explanation: "ශ්‍රූතියක් නිර්මාණය කිරීම සඳහා ශ්‍රූතියේ නම, පරාමිති ලැයිස්තුව (හිස් වුවත්) සහ ශ්‍රූතියේ කේත කොටස අත්‍යවශ්‍ය වේ. `return` ප්‍රකාශනය අත්‍යවශ්‍ය වන්නේ ශ්‍රූතියකින් අගයක් ආපසු ලබා දීමට අවශ්‍ය නම් පමණි. ශ්‍රූතියට පෙර ගෝලීය විචල්‍යයන් ප්‍රකාශ කිරීම ශ්‍රූතියක ව්‍යුහයට අත්‍යවශ්‍ය කොටසක් නොවේ, එය ක්‍රමලේඛයේ සමස්ත ව්‍යුහයට සම්බන්ධ වේ."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී, කිසියම් ශ්‍රූතියක් වෙනත් ශ්‍රූතියක් තුළ අර්ථ දැක්වීම කුමක් ලෙස හැඳින්වේද?",
        options: [
            "ශ්‍රූති ඕවර්ලෝඩ් කිරීම (Function Overloading)",
            "නිහිත ශ්‍රූති (Nested Functions)",
            "ශ්‍රූති පුනරාවර්තනය (Function Recursion)",
            "ගෝලීය ශ්‍රූති (Global Functions)",
            "පෙරනිමි ශ්‍රූති (Default Functions)"
        ],
        correctAnswerIndex: 1,
        explanation: "කිසියම් ශ්‍රූතියක් වෙනත් ශ්‍රූතියක් තුළ අර්ථ දැක්වීම 'නිහිත ශ්‍රූති (Nested Functions)' ලෙස හැඳින්වේ. මෙවැනි නිහිත ශ්‍රූතියකට බාහිර ශ්‍රූතියේ ස්ථානීය විචල්‍යයන්ට ප්‍රවේශ විය හැකිය."
    },
    {
        questionText: "ශ්‍රූතියක (function) ප්‍රධාන ව්‍යුහාත්මක අංගයක් නොවන්නේ කුමක්ද?",
        options: [
            "ශ්‍රූතියේ නම",
            "ආදාන පරාමිති",
            "ප්‍රතිදාන අගය (return value) - අවශ්‍ය නම්",
            "ශ්‍රූතියේ සිරුර (body of the function)",
            "දත්ත සමුදා සම්බන්ධතා තොරතුරු"
        ],
        correctAnswerIndex: 4,
        explanation: "ශ්‍රූතියක ප්‍රධාන ව්‍යුහාත්මක අංග වන්නේ එහි නම, ආදාන පරාමිති (තිබේ නම්), ප්‍රතිදාන අගය (තිබේ නම්) සහ ශ්‍රූතියේ සිරුර (එනම්, ක්‍රියාත්මක වන කේතය) වේ. දත්ත සමුදා සම්බන්ධතා තොරතුරු ශ්‍රූතියක් තුළ භාවිත කළ හැකි වුවත්, එය ශ්‍රූතියක අත්‍යවශ්‍ය ව්‍යුහාත්මක අංගයක් ලෙස නොසැලකේ."
    },
    {
        questionText: "පහත දැක්වෙන කේත කොටසෙහි, `x` හි අවසාන අගය කුමක්ද? `let x = 10; function testScope() { let x = 20; print(x); } testScope(); print(x);`",
        options: [
            "20 10",
            "10 20",
            "20 20",
            "10 10",
            "දෝෂයක්"
        ],
        correctAnswerIndex: 0,
        explanation: "මෙම කේත කොටසෙහි ගෝලීය `x` (අගය 10) සහ `testScope` ශ්‍රූතිය තුළ ප්‍රකාශ කර ඇති ස්ථානීය `x` (අගය 20) යන විචල්‍යයන් දෙකක් ඇත. `testScope()` ශ්‍රූතිය කැඳවූ විට, ස්ථානීය `x` (20) මුද්‍රණය වේ. ශ්‍රූතිය අවසන් වූ පසු, ගෝලීය `x` හි අගය (10) නොවෙනස්ව පවතින බැවින්, දෙවන `print(x)` මගින් 10 මුද්‍රණය වේ."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී ශ්‍රූතියක් (function) නැවත නැවත කැඳවීම (recursion) සඳහා ප්‍රධාන හේතුව කුමක්ද?",
        options: [
            "ක්‍රමලේඛයේ වේගය වැඩි කිරීම",
            "ලූප් (loop) ව්‍යුහ භාවිතය වැළැක්වීම",
            "සංකීර්ණ ගැටළුවක් කුඩා, සමාන උප-ගැටළු වලට කඩා විසඳීමට",
            "දත්ත ගොනු හැසිරවීම සඳහා",
            "පරිශීලක ආදානය ලබා ගැනීමට"
        ],
        correctAnswerIndex: 2,
        explanation: "පුනරාවර්තනය (recursion) යනු ශ්‍රූතියක් තමන්වම කැඳවීමයි. මෙය සාමාන්‍යයෙන් භාවිතා කරනුයේ යම් සංකීර්ණ ගැටළුවක් කුඩා, සමාන උප-ගැටළු වලට කඩා විසඳීමටයි. උදාහරණයක් ලෙස, ෆැක්ටෝරියල් ගණනය කිරීම හෝ ෆිබොනාච්චි අනුක්‍රමය වැනි ගැටළු recursion භාවිතයෙන් විසඳිය හැක."
    },
    {
        questionText: "ශ්‍රූතියකට පරාමිති යැවීමේදී, එම පරාමිති වල දත්ත වර්ගය ක්‍රමලේඛන භාෂාවට අනුව ස්වයංක්‍රීයව අනුමාන කරන්නේ කුමන ආකාරයේ භාෂාවකින්ද?",
        options: [
            "Strictly Typed Languages (උදා: Java, C++)",
            "Statically Typed Languages",
            "Dynamically Typed Languages (උදා: Python, JavaScript)",
            "Compiled Languages",
            "Low-level Languages"
        ],
        correctAnswerIndex: 2,
        explanation: "Dynamically Typed Languages (ගතිකව ටයිප් කරන ලද භාෂා) වලදී, විචල්‍යයක හෝ පරාමිතියක දත්ත වර්ගය ක්‍රමලේඛය ක්‍රියාත්මක වන විට (runtime) ස්වයංක්‍රීයව තීරණය වේ. මේවායේදී ඔබ අතින් දත්ත වර්ගය පැහැදිලිව ප්‍රකාශ කළ යුතු නැත. Strictly Typed/Statically Typed Languages වලදී දත්ත වර්ගය කල්තියා ප්‍රකාශ කළ යුතුය."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී ශ්‍රූතියකින් කිසිදු අගයක් ආපසු ලබා නොදෙන්නේ නම්, එම ශ්‍රූතිය කුමක් ලෙස හැඳින්විය හැකිද?",
        options: [
            "Return Function",
            "Value Function",
            "Void Function",
            "Parameter Function",
            "Global Function"
        ],
        correctAnswerIndex: 2,
        explanation: "බොහෝ ක්‍රමලේඛන භාෂාවලදී (විශේෂයෙන් C, Java වැනි භාෂාවලදී), කිසිදු අගයක් ආපසු ලබා නොදෙන ශ්‍රූතියක් 'Void Function' ලෙස හැඳින්වේ. JavaScript වැනි භාෂාවලදී ශ්‍රූතියක් `return` ප්‍රකාශනයක් නොමැතිව අවසන් වුවහොත් එය `undefined` ආපසු ලබා දෙයි, නමුත් ක්‍රියාකාරීත්වය අතින් 'void' ශ්‍රූතියකට සමාන වේ."
    },
    {
        questionText: "පහත දැක්වෙන කේත කොටසෙහි, `y` හි අවසාන අගය කුමක්ද? `function increment(num) { num = num + 1; return num; } let y = 5; y = increment(y);`",
        options: [
            "5",
            "6",
            "undefined",
            "දෝෂයක්",
            "num"
        ],
        correctAnswerIndex: 1,
        explanation: "`increment` ශ්‍රූතිය `y` (අගය 5) පරාමිතිය ලෙස ලබා ගනී. ශ්‍රූතිය තුළ `num` හි අගය 6 වේ. මෙම 6 ආපසු ලබා දෙන අතර, එය `y` විචල්‍යයට නැවත පවරනු ලැබේ. එබැවින් `y` හි අවසාන අගය 6 වේ."
    },

    // 9.10: ක්‍රමලේඛවල දී දත්ත ව්‍යුහ යොදා ගනී. (Data Structures)
    {
        questionText: "ක්‍රමලේඛනයකදී 'දත්ත ව්‍යුහයක් (data structure)' භාවිතා කිරීමේ ප්‍රධාන අරමුණ කුමක්ද?",
        options: [
            "ක්‍රමලේඛයේ දෝෂ හඳුනා ගැනීමට",
            "දත්ත කාර්යක්ෂමව ගබඩා කිරීමට සහ ප්‍රවේශ වීමට",
            "පරිශීලකයාගෙන් ආදානය ලබා ගැනීමට",
            "ක්‍රමලේඛයේ ප්‍රකාශන ක්‍රියාත්මක වන අනුපිළිවෙල පාලනය කිරීමට",
            "ගණිතමය ගණනය කිරීම් සිදු කිරීමට"
        ],
        correctAnswerIndex: 1,
        explanation: "දත්ත ව්‍යුහ යනු දත්ත කාර්යක්ෂමව ගබඩා කිරීමට, සංවිධානය කිරීමට සහ ප්‍රවේශ වීමට භාවිතා කරන ක්‍රමවේදයන් වේ. නිවැරදි දත්ත ව්‍යුහය තෝරා ගැනීමෙන් ක්‍රමලේඛයක ක්‍රියාකාරීත්වය (performance) විශාල වශයෙන් වැඩි දියුණු කළ හැකිය."
    },
    {
        questionText: "පහත දැක්වෙන දත්ත ව්‍යුහයන්ගෙන් කුමක්ද අනුපිළිවෙලක් ඇති (ordered), වෙනස් කළ හැකි (mutable) දත්ත එකතුවක් ගබඩා කිරීමට භාවිතා කරනුයේ?",
        options: [
            "String",
            "List",
            "Tuple",
            "Dictionary",
            "Set"
        ],
        correctAnswerIndex: 1,
        explanation: "List යනු අනුපිළිවෙලක් ඇති, වෙනස් කළ හැකි (mutable) දත්ත එකතුවකි. ඔබට List එකකට දත්ත එකතු කිරීමට, ඉවත් කිරීමට හෝ වෙනස් කිරීමට හැකිය. String සහ Tuple යනු වෙනස් කළ නොහැකි (immutable) දත්ත ව්‍යුහයන් වේ. Dictionary යනු අනුපිළිවෙලක් නොමැති (බොහෝ භාෂාවල), යතුර-අගය යුගල ගබඩා කරන ව්‍යුහයකි."
    },
    {
        questionText: "පහත දැක්වෙන දත්ත ව්‍යුහයන්ගෙන් කුමක්ද 'යතුර-අගය යුගල (key-value pairs)' ලෙස දත්ත ගබඩා කිරීමට භාවිතා කරනුයේ?",
        options: [
            "String",
            "List",
            "Tuple",
            "Dictionary",
            "Array"
        ],
        correctAnswerIndex: 3,
        explanation: "Dictionary (බොහෝ භාෂාවල Hash Map හෝ Associative Array ලෙසද හැඳින්වේ) යනු යතුර-අගය යුගල (key-value pairs) ලෙස දත්ත ගබඩා කිරීමට භාවිතා කරන දත්ත ව්‍යුහයකි. සෑම අගයක්ම අද්විතීය යතුරක් සමඟ සම්බන්ධ වී ඇති අතර, එම යතුර භාවිතයෙන් අගයට ප්‍රවේශ විය හැකිය."
    },
    {
        questionText: "Python භාෂාවේ `('apple', 'banana', 'cherry')` වැනි දත්ත එකතුවක් කුමක් ලෙස හැඳින්වේද?",
        options: [
            "List",
            "Set",
            "Dictionary",
            "Tuple",
            "String"
        ],
        correctAnswerIndex: 3,
        explanation: "වරහන් (parentheses) තුළ අගයන් සහිතව නිර්මාණය කර ඇති, අනුපිළිවෙලක් ඇති සහ වෙනස් කළ නොහැකි (immutable) දත්ත එකතුවක් Python හි Tuple ලෙස හැඳින්වේ. List භාවිතා කරන්නේ කොටු වරහන් (square brackets) වේ."
    },
    {
        questionText: "පහත දැක්වෙන දත්ත ව්‍යුහයන්ගෙන් කුමක්ද අනුපිළිවෙලක් ඇති (ordered) නමුත් වෙනස් කළ නොහැකි (immutable) අක්ෂර අනුපිළිවෙලක් ගබඩා කිරීමට භාවිතා කරනුයේ?",
        options: [
            "List",
            "Tuple",
            "String",
            "Dictionary",
            "Set"
        ],
        correctAnswerIndex: 2,
        explanation: "String යනු අක්ෂර අනුපිළිවෙලක් ගබඩා කිරීමට භාවිතා කරන දත්ත ව්‍යුහයකි. Strings අනුපිළිවෙලක් ඇති (indexed) අතර, ඒවා සාමාන්‍යයෙන් වෙනස් කළ නොහැකි (immutable) වේ. එනම්, නිර්මාණය කිරීමෙන් පසු String එකක අන්තර්ගතය කෙලින්ම වෙනස් කළ නොහැක, එයට නව String එකක් සෑදිය යුතුය."
    },
    {
        questionText: "දත්ත ව්‍යුහයක් තුළ දත්ත සෙවීමේදී, Dictionary එකක් List එකකට වඩා වාසිදායක වන්නේ කුමන අංශයෙන්ද?",
        options: [
            "Dictionary එකක දත්ත වෙනස් කළ නොහැකි බැවින්",
            "Dictionary එකක දත්ත ගබඩා කර ඇත්තේ යතුරු (keys) මගින් බැවින් වේගවත් ප්‍රවේශයක් ලබා ගත හැකි බැවින්",
            "List එකකට වඩා Dictionary එකක දත්ත ගබඩා කළ හැකි බැවින්",
            "List එකකට වඩා Dictionary එකක අඩු මතකයක් අවශ්‍ය වන බැවින්",
            "Dictionary එකක් නිර්මාණය කිරීම පහසු බැවින්"
        ],
        correctAnswerIndex: 1,
        explanation: "Dictionary එකක් තුළ දත්ත 'යතුරු (keys)' මගින් ප්‍රවේශ වන බැවින්, යතුරක් දන්නා විට අදාළ අගය සොයා ගැනීම ඉතා වේගවත් වේ (සාමාන්‍යයෙන් O(1) සංකීර්ණතාවය). List එකකදී දත්ත සොයා ගැනීමට අනුක්‍රමික සෙවුමක් (sequential search) අවශ්‍ය විය හැකි අතර එය මන්දගාමී විය හැකිය (සාමාන්‍යයෙන් O(n) සංකීර්ණතාවය)."
    },
    {
        questionText: "පහත JavaScript කේත කොටසෙහි, `fruits` විචල්‍යය කුමන දත්ත ව්‍යුහයට අයත් වන්නේද? `const fruits = ['apple', 'banana', 'cherry'];`",
        options: [
            "Object",
            "String",
            "Array",
            "Tuple",
            "Set"
        ],
        correctAnswerIndex: 2,
        explanation: "JavaScript හි, කොටු වරහන් `[]` භාවිතයෙන් නිර්මාණය කර ඇති අනුපිළිවෙලක් ඇති, වෙනස් කළ හැකි දත්ත එකතුවක් 'Array' ලෙස හැඳින්වේ. මෙය Python හි 'List' එකකට සමාන වේ."
    },
    {
        questionText: "JavaScript හි `{name: 'John', age: 30}` වැනි දත්ත එකතුවක් කුමක් ලෙස හඳුන්වන්නේද?",
        options: [
            "Array",
            "String",
            "Object",
            "Tuple",
            "List"
        ],
        correctAnswerIndex: 2,
        explanation: "JavaScript හි, curly braces `{}` භාවිතයෙන් නිර්මාණය කර ඇති යතුර-අගය යුගල (key-value pairs) ලෙස දත්ත ගබඩා කරන ව්‍යුහයක් 'Object' ලෙස හැඳින්වේ. මෙය Python හි 'Dictionary' එකකට සමාන වේ."
    },
    {
        questionText: "පහත සඳහන් දත්ත ව්‍යුහයන්ගෙන් කුමන එකක්ද 'දර්ශකයක් (index)' භාවිතයෙන් එහි අංගයන්ට ප්‍රවේශ වීමට ඉඩ නොදෙන්නේ?",
        options: [
            "String",
            "List",
            "Tuple",
            "Dictionary",
            "Array"
        ],
        correctAnswerIndex: 3,
        explanation: "String, List, Tuple සහ Array වැනි දත්ත ව්‍යුහයන්හි අංගයන්ට 0-පාදක දර්ශකයක් (index) භාවිතයෙන් ප්‍රවේශ විය හැකිය. නමුත් Dictionary එකක අංගයන්ට ප්‍රවේශ වන්නේ දර්ශකයක් වෙනුවට අදාළ 'යතුර (key)' භාවිතයෙනි."
    },
    {
        questionText: "පහත දැක්වෙන කුමන දත්ත ව්‍යුහයද 'අනුක්‍රමික (ordered)' නොවන අතර 'අද්විතීය (unique)' අංග පමණක් ගබඩා කරන්නේ?",
        options: [
            "List",
            "Tuple",
            "String",
            "Dictionary",
            "Set"
        ],
        correctAnswerIndex: 4,
        explanation: "Set යනු ගණිතමය 'ගොන්න' සංකල්පයට සමාන දත්ත ව්‍යුහයකි. එය අනුක්‍රමික නොවන අතර, එක් එක් අංගය එක් වරක් පමණක් ගබඩා කරයි, එනම් අද්විතීය අගයන් පමණි. List, Tuple, String අනුක්‍රමික වන අතර, Dictionary යතුර-අගය යුගල ගබඩා කරයි."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී 'දත්ත ව්‍යුහයක් (data structure)' නිවැරදිව තෝරා ගැනීමෙන් ලැබෙන ප්‍රධාන වාසිය කුමක්ද?",
        options: [
            "ක්‍රමලේඛයේ දෝෂ ගණන වැඩි කිරීම",
            "ක්‍රමලේඛයේ ක්‍රියාත්මක වන වේගය අඩු කිරීම",
            "ක්‍රමලේඛයේ සංකීර්ණතාවය වැඩි කිරීම",
            "දත්ත හැසිරවීමේ කාර්යක්ෂමතාව සහ මතක භාවිතය ප්‍රශස්ත කිරීම",
            "ක්‍රමලේඛ ලිවීමට ගතවන කාලය වැඩි කිරීම"
        ],
        correctAnswerIndex: 3,
        explanation: "නිවැරදි දත්ත ව්‍යුහය තෝරා ගැනීමෙන් දත්ත ගබඩා කිරීමේ හා ප්‍රවේශ වීමේ ක්‍රියාවලිය කාර්යක්ෂම වන අතර, එමගින් ක්‍රමලේඛයේ සමස්ත ක්‍රියාකාරීත්වය සහ මතක භාවිතය ප්‍රශස්ත කළ හැකිය. වැරදි දත්ත ව්‍යුහයක් තෝරා ගැනීමෙන් ක්‍රමලේඛය මන්දගාමී විය හැකිය."
    },
    {
        questionText: "පහත දැක්වෙන Python කේත කොටසෙහි, `my_dict['city']` හි අගය කුමක්ද? `my_dict = {'name': 'Alice', 'age': 25, 'city': 'New York'}`",
        options: [
            "Alice",
            "25",
            "New York",
            "city",
            "දෝෂයක්"
        ],
        correctAnswerIndex: 2,
        explanation: "Dictionary එකක අගයකට ප්‍රවේශ වීම සඳහා අදාළ යතුර (key) භාවිතා කරයි. මෙහි `city` යනු යතුර වන අතර, එහි අනුරූප අගය 'New York' වේ."
    },
    {
        questionText: "පහත දැක්වෙන JavaScript කේත කොටසෙහි, `colors[1]` හි අගය කුමක්ද? `const colors = ['red', 'green', 'blue'];`",
        options: [
            "red",
            "green",
            "blue",
            "colors",
            "undefined"
        ],
        correctAnswerIndex: 1,
        explanation: "JavaScript Array එකක දර්ශක (index) 0 සිට ආරම්භ වේ. 'red' යනු දර්ශකය 0, 'green' දර්ශකය 1, සහ 'blue' දර්ශකය 2 වේ. එබැවින් `colors[1]` හි අගය 'green' වේ."
    },
    {
        questionText: "පහත දැක්වෙන කේත කොටසෙහි, `message[0]` හි අගය කුමක්ද? `const message = 'Hello';`",
        options: [
            "H",
            "e",
            "l",
            "o",
            "undefined"
        ],
        correctAnswerIndex: 0,
        explanation: "String එකක් යනු අක්ෂර අනුපිළිවෙලකි. String එකක එක් එක් අක්ෂරයට 0-පාදක දර්ශකයක් භාවිතයෙන් ප්‍රවේශ විය හැකිය. `message[0]` යනු 'Hello' String එකේ පළමු අක්ෂරය වන 'H' වේ."
    },
    {
        questionText: "පහත දැක්වෙන Python කේත කොටසෙහි, `my_tuple[0] = 10` ප්‍රකාශනය ක්‍රියාත්මක කිරීමට උත්සාහ කළහොත් කුමක් සිදුවේද? `my_tuple = (1, 2, 3)`",
        options: [
            "Tuple එකේ පළමු අගය 10 ලෙස වෙනස් වේ.",
            "දෝෂයක් ඇති වේ, මන්ද Tuples වෙනස් කළ නොහැකි බැවිනි.",
            "නව Tuple එකක් 10, 2, 3 ලෙස නිර්මාණය වේ.",
            "කිසිවක් සිදු නොවේ.",
            "Tuple එක List එකක් ලෙස වෙනස් වේ."
        ],
        correctAnswerIndex: 1,
        explanation: "Tuples යනු වෙනස් කළ නොහැකි (immutable) දත්ත ව්‍යුහයන් වේ. නිර්මාණය කිරීමෙන් පසු ඒවායේ අන්තර්ගතය වෙනස් කළ නොහැක. එබැවින්, Tuple එකක අංගයක් වෙනස් කිරීමට උත්සාහ කළහොත් 'TypeError' වැනි දෝෂයක් ඇති වේ."
    },
    {
        questionText: "යම් සිදුවීම් අනුපිළිවෙලක් (උදා: පරිශීලක ක්‍රියාකාරකම් වාර්තා) ගබඩා කිරීමට සහ ඒවායේ අනුපිළිවෙල පවත්වා ගැනීමට අවශ්‍ය විට වඩාත් සුදුසු දත්ත ව්‍යුහය කුමක්ද?",
        options: [
            "Dictionary",
            "Set",
            "String",
            "List/Array",
            "Boolean"
        ],
        correctAnswerIndex: 3,
        explanation: "List (හෝ Array) යනු අනුපිළිවෙලක් ඇති (ordered) දත්ත එකතුවක් ගබඩා කිරීමට වඩාත් සුදුසු දත්ත ව්‍යුහයකි. සිදුවීම් අනුපිළිවෙලක් ගබඩා කිරීමේදී, සිදුවීම් සිදු වූ අනුපිළිවෙල ඉතා වැදගත් බැවින්, List එකක දර්ශක භාවිතයෙන් එම අනුපිළිවෙල පවත්වා ගත හැකිය."
    },
    {
        questionText: "දත්ත සමූහයකින් අද්විතීය අගයන් පමණක් ගබඩා කිරීමට අවශ්‍ය නම්, වඩාත් සුදුසු දත්ත ව්‍යුහය කුමක්ද?",
        options: [
            "List",
            "Tuple",
            "Dictionary",
            "Set",
            "String"
        ],
        correctAnswerIndex: 3,
        explanation: "Set යනු අද්විතීය (unique) අගයන් පමණක් ගබඩා කිරීමට විශේෂයෙන් නිර්මාණය කර ඇති දත්ත ව්‍යුහයකි. ඔබ Set එකකට සමාන අගයක් දෙවරක් එකතු කිරීමට උත්සාහ කළහොත්, එය එක් වරක් පමණක් ගබඩා වනු ඇත."
    },
    {
        questionText: "JSON (JavaScript Object Notation) යනු කුමක්ද?",
        options: [
            "ක්‍රමලේඛන භාෂාවකි",
            "දත්ත සමුදා වර්ගයකි",
            "දත්ත ව්‍යුහයන් ගබඩා කිරීම සඳහා වූ ගොනු ආකෘතියකි",
            "වෙබ් පිටු නිර්මාණය සඳහා වූ භාෂාවකි",
            "පරිගණක ජාල ප්‍රොටෝකෝලයකි"
        ],
        correctAnswerIndex: 2,
        explanation: "JSON (JavaScript Object Notation) යනු මිනිසුන්ට කියවීමට පහසු සහ යන්ත්‍රවලට විශ්ලේෂණය කිරීමට පහසු වන දත්ත හුවමාරු ආකෘතියකි. එය JavaScript Objects සහ Arrays වල ව්‍යුහය මත පදනම් වන අතර, ප්‍රධාන වශයෙන් වෙබ් යෙදුම් අතර දත්ත හුවමාරු කිරීමට භාවිතා වේ. එය String, Number, Boolean, Array, Object, null වැනි දත්ත වර්ග ගබඩා කළ හැක."
    },
    {
        questionText: "පහත දැක්වෙන දත්ත ව්‍යුහයන්ගෙන් කුමන එකක්ද 'පිළිවෙල (order)' වැදගත් වන අතර 'දර්ශක (index)' මගින් ප්‍රවේශ විය හැකි දත්ත ගබඩා කිරීමට භාවිතා කරන්නේ?",
        options: [
            "Dictionary",
            "Set",
            "String",
            "List/Array සහ Tuple",
            "None of the above"
        ],
        correctAnswerIndex: 3,
        explanation: "List/Array, Tuple සහ String යන දත්ත ව්‍යුහයන් සියල්ලම අනුපිළිවෙලක් ඇති දත්ත ගබඩා කරන අතර, ඒවායේ අංගයන්ට 0-පාදක දර්ශකයක් (index) භාවිතයෙන් ප්‍රවේශ විය හැකිය. Dictionary සහ Set අනුපිළිවෙලක් නොමැත (හෝ ඒවායේ අනුපිළිවෙල ස්ථාවර නොවේ, ක්‍රමලේඛන භාෂාව මත රඳා පවතී)."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී, දත්ත ව්‍යුහයක 'පුනරාවර්තනය (iteration)' යන්නෙන් අදහස් කරන්නේ කුමක්ද?",
        options: [
            "දත්ත ව්‍යුහය තුළ නව අංග එකතු කිරීම",
            "දත්ත ව්‍යුහයකින් අංග ඉවත් කිරීම",
            "දත්ත ව්‍යුහයක එක් එක් අංගය හරහා පිළිවෙලින් ගමන් කිරීම",
            "දත්ත ව්‍යුහයක ප්‍රමාණය වෙනස් කිරීම",
            "දත්ත ව්‍යුහයක් වර්ග කිරීම"
        ],
        correctAnswerIndex: 2,
        explanation: "දත්ත ව්‍යුහයක 'පුනරාවර්තනය (iteration)' යනු ලූප් (loop) භාවිතයෙන් හෝ පුනරාවර්තනයට ඉඩ දෙන ක්‍රමවේදයක් (iterator) භාවිතයෙන් එම දත්ත ව්‍යුහයේ ඇති එක් එක් අංගය හරහා පිළිවෙලින් ගමන් කිරීමේ ක්‍රියාවලියයි."
    },
    {
        questionText: "පහත දැක්වෙන Python කේත කොටසෙහි, `my_list.append('grape')` ක්‍රියාත්මක කිරීමෙන් පසු `my_list` හි අගය කුමක්ද? `my_list = ['apple', 'banana']`",
        options: [
            "['apple', 'banana']",
            "['grape', 'apple', 'banana']",
            "['apple', 'banana', 'grape']",
            "දෝෂයක්",
            "['grape']"
        ],
        correctAnswerIndex: 2,
        explanation: "`append()` method එක List එකක අවසානයට නව අංගයක් එකතු කරයි. එබැවින් 'grape' 'banana' ට පසුව List එකට එකතු වේ."
    },

    // 9.11: ක්‍රමලේඛවල දී ගොනු සහ දත්ත සමුදාය හසුරුවයි. (File Handling)
    {
        questionText: "ක්‍රමලේඛනයකදී 'ගොනුවක් විවෘත කිරීම (opening a file)' යන ක්‍රියාවෙන් ප්‍රධාන වශයෙන් අදහස් කරන්නේ කුමක්ද?",
        options: [
            "ගොනුවක අන්තර්ගතය මකා දැමීම",
            "පරිගණක මතකයට ගොනුවේ පිටපතක් සෑදීම",
            "ගොනුවට ප්‍රවේශ වීමට සහ මෙහෙයුම් සිදු කිරීමට මෙහෙයුම් පද්ධතියට (operating system) දැනුම් දීම",
            "ගොනුවේ නම වෙනස් කිරීම",
            "ගොනුවක් සම්පූර්ණයෙන්ම මකා දැමීම"
        ],
        correctAnswerIndex: 2,
        explanation: "ගොනුවක් විවෘත කිරීම යනු ක්‍රමලේඛයක් මගින් ගොනුවකට ප්‍රවේශ වීමට මෙහෙයුම් පද්ධතියෙන් අවසර ඉල්ලීමයි. මෙම ක්‍රියාවලියේදී, මෙහෙයුම් පද්ධතිය ගොනුව කළමනාකරණය කරන අතර, ක්‍රමලේඛයට ගොනුවට ලිවීමට හෝ කියවීමට අවශ්‍ය සම්බන්ධතාවය (file handle) ලබා දේ."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී ගොනුවක් 'කියවීමේ මාදිලියෙන් (read mode)' විවෘත කිරීමේදී සිදුවන ප්‍රධාන දෙය කුමක්ද?",
        options: [
            "ගොනුවේ ඇති සියලුම දත්ත මකා දමයි.",
            "ගොනුවට නව දත්ත එකතු කිරීමට ඉඩ දෙයි.",
            "ගොනුවේ අන්තර්ගතය පමණක් කියවීමට ඉඩ දෙයි, ලිවීමට හෝ වෙනස් කිරීමට ඉඩ නොදෙයි.",
            "ගොනුවක් නොමැති නම් නව ගොනුවක් සාදයි.",
            "දෝෂයක් ඇති කරයි."
        ],
        correctAnswerIndex: 2,
        explanation: "ගොනුවක් කියවීමේ මාදිලියෙන් ('r' mode) විවෘත කරන විට, ක්‍රමලේඛයට ගොනුවේ අන්තර්ගතය පමණක් කියවීමට ඉඩ ලැබේ. මෙම මාදිලියේදී ගොනුවට ලිවීමට හෝ ගොනුවේ අන්තර්ගතය වෙනස් කිරීමට හැකියාවක් නොමැත. ගොනුව නොමැති නම් දෝෂයක් ඇති වේ."
    },
    {
        questionText: "පවතින ගොනුවකට නව දත්ත 'එකතු කිරීම (append)' සඳහා භාවිතා කළ යුතු ගොනු මෙහෙයුම් මාදිලිය කුමක්ද?",
        options: [
            "'r' (read)",
            "'w' (write)",
            "'a' (append)",
            "'x' (exclusive creation)",
            "'rb' (read binary)"
        ],
        correctAnswerIndex: 2,
        explanation: "`a` (append) මාදිලිය භාවිතා කරනුයේ පවතින ගොනුවක අවසානයට නව දත්ත එකතු කිරීමටයි. ගොනුවක් නොමැති නම්, මෙම මාදිලිය නව ගොනුවක් සාදයි. `w` මාදිලිය ගොනුවේ පවතින සියලුම දත්ත මකා දමන අතර, `r` මාදිලිය කියවීමට පමණක් භාවිතා වේ."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී ගොනුවක් 'ලියවීමේ මාදිලියෙන් (write mode)' විවෘත කිරීමේදී (උදා: 'w') සිදුවන ප්‍රධාන අවාසියක් කුමක්ද?",
        options: [
            "ගොනුවේ අන්තර්ගතය කියවිය නොහැකි වීම",
            "ගොනුවේ දත්ත මකා දැමීමක් සිදු නොවීම",
            "ගොනුවක් නොමැති නම් දෝෂයක් ඇති කිරීම",
            "ගොනුවේ පවතින සියලුම දත්ත නැති වී යාම (overwrite)",
            "ඉතා සෙමින් දත්ත ලිවීම"
        ],
        correctAnswerIndex: 3,
        explanation: "ගොනුවක් ලියවීමේ මාදිලියෙන් ('w' mode) විවෘත කිරීමේදී, ගොනුවක් නොමැති නම් නව ගොනුවක් සාදයි. නමුත් ගොනුවක් දැනටමත් පවතී නම්, එහි ඇති සියලුම පවතින දත්ත මකා දමන අතර, එය හිස් ගොනුවක් ලෙස නැවත ආරම්භ වේ. මෙය අනවශ්‍ය ලෙස දත්ත නැති වීමට හේතු විය හැකි බැවින් ප්‍රවේශමෙන් භාවිතා කළ යුතුය."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී ගොනුවක් 'වසා දැමීම (closing a file)' අත්‍යවශ්‍ය වන්නේ ඇයි?",
        options: [
            "ගොනුවේ නම වෙනස් කිරීමට",
            "ගොනුවේ අන්තර්ගතය වෙනස් කිරීමට",
            "ගොනුවට සිදු කළ වෙනස්කම් සුරැකීමට සහ මතක සම්පත් මුදා හැරීමට",
            "ගොනුව වෙනත් ක්‍රමලේඛයකට ප්‍රවේශ වීමට ඉඩ නොදීමට",
            "ගොනුව නැවත විවෘත කිරීම වැළැක්වීමට"
        ],
        correctAnswerIndex: 2,
        explanation: "ගොනුවක් විවෘත කිරීමෙන් පසු, එය සමඟ වැඩ අවසන් වූ විට එය වසා දැමීම අත්‍යවශ්‍ය වේ. මෙය සිදු කිරීමෙන්, ගොනුවට සිදු කළ වෙනස්කම් ස්ථිරවම සුරැකෙන අතර, මෙහෙයුම් පද්ධතියට එම ගොනුව සඳහා වෙන් කළ මතක සම්පත් (memory resources) සහ ගොනු අගුළු (file locks) මුදා හැරීමට ඉඩ සලසයි. ගොනුවක් වසා නොදැමීමෙන් දත්ත නැතිවීම හෝ සම්පත් කාන්දු වීම (resource leaks) සිදුවිය හැකිය."
    },
    {
        questionText: "පහත දැක්වෙන කේත කොටසෙහි, `file.write('Hello\n')` ක්‍රියාත්මක කිරීමෙන් පසු `my_file.txt` ගොනුවේ අන්තර්ගතය කුමක්ද? `file = open('my_file.txt', 'w'); file.write('Hello\n'); file.close();` (my_file.txt මුලින්ම හිස් ගොනුවක් නම්)",
        options: [
            "හිස් ගොනුවක්",
            "Hello",
            "Hello\n",
            "දෝෂයක්",
            "ගොනුව නිර්මාණය නොවේ"
        ],
        correctAnswerIndex: 2,
        explanation: "`w` මාදිලියෙන් ගොනුව විවෘත කිරීමෙන් එය හිස් වන අතර, `write('Hello\n')` මගින් 'Hello' සහ නව පේළි අක්ෂරයක් ගොනුවට ලියනු ලැබේ. `\n` මගින් නව පේළියක් නිර්මාණය වේ."
    },
    {
        questionText: "පහත දැක්වෙන Python කේත කොටසෙහි, `file.read()` මගින් කුමක් කියවනු ඇත්ද? `file = open('data.txt', 'r'); content = file.read(); file.close();` (data.txt හි 'Line 1\nLine 2' අඩංගු වේ)",
        options: [
            "Line 1",
            "Line 2",
            "Line 1Line 2",
            "Line 1\nLine 2",
            "දෝෂයක්"
        ],
        correctAnswerIndex: 3,
        explanation: "`file.read()` method එක ගොනුවේ ඇති සියලුම අන්තර්ගතය (නව පේළි අක්ෂර ඇතුළුව) තනි String එකක් ලෙස කියවයි. එබැවින් 'Line 1\nLine 2' ලෙස කියවනු ඇත."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී ගොනුවක් මකා දැමීම (deleting a file) සඳහා භාවිතා කරන මෙහෙයුම කුමක්ද?",
        options: [
            "open()",
            "close()",
            "write()",
            "delete() හෝ remove() වැනි ක්‍රමලේඛන භාෂාවෙන් සපයන ලද මෙහෙයුමක්",
            "read()"
        ],
        correctAnswerIndex: 3,
        explanation: "ගොනුවක් මකා දැමීම සඳහා, ක්‍රමලේඛන භාෂාවන් මගින් විශේෂිත ශ්‍රූති හෝ methods සපයනු ලැබේ (උදා: Python හි `os.remove()` හෝ `os.unlink()`). `delete()` යනු පොදු සංකල්පයකි, නමුත් සත්‍ය ක්‍රියාව වෙනස් විය හැක."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී ගොනු හැසිරවීම (file handling) සඳහා 'try-except-finally' (හෝ try-catch-finally) බ්ලොක් එකක් භාවිතා කිරීමේ ප්‍රධාන වාසිය කුමක්ද?",
        options: [
            "ගොනු මෙහෙයුම් වේගවත් කිරීම",
            "ගොනු හැසිරවීමේදී ඇති විය හැකි දෝෂ (errors) කළමනාකරණය කිරීමට සහ ගොනු නිසියාකාරව වසා දැමීම සහතික කිරීමට",
            "ගොනු ප්‍රමාණය අඩු කිරීම",
            "ගොනුවේ අන්තර්ගතය සංකේතනය කිරීම",
            "ගොනුවට දත්ත ලිවීම පමණක් කිරීමට"
        ],
        correctAnswerIndex: 1,
        explanation: "ගොනු හැසිරවීමේදී, ගොනු නොමැති වීම, ප්‍රවේශ අවසර නොමැති වීම හෝ ලිවීමේ දෝෂ වැනි දෝෂ ඇතිවිය හැකිය. `try-except-finally` බ්ලොක් එක මගින් මෙම දෝෂ නිසියාකාරව කළමනාකරණය කිරීමට (except/catch) සහ දෝෂයක් ඇති වුවද ගොනුව නිසියාකාරව වසා දැමීම (finally) සහතික කිරීමට උපකාරී වේ. මෙය ක්‍රමලේඛයේ ස්ථාවරත්වය වැඩි කරයි."
    },
    {
        questionText: "පහත දැක්වෙන කේත කොටසෙහි, `line = file.readline()` ක්‍රියාත්මක කිරීමෙන් පසු `line` විචල්‍යයේ අගය කුමක්ද? `file = open('data.txt', 'r'); line = file.readline(); file.close();` (data.txt හි 'First line\nSecond line' අඩංගු වේ)",
        options: [
            "First line",
            "Second line",
            "First line\n",
            "Second line\n",
            "දෝෂයක්"
        ],
        correctAnswerIndex: 2,
        explanation: "`file.readline()` method එක ගොනුවෙන් එක් පේළියක් (එනම්, නව පේළි අක්ෂරය `\n` ඇතුළුව) කියවයි. එබැවින් 'First line\n' ලෙස කියවනු ඇත."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී ගොනුවකට දත්ත ලිවීමේදී 'Text mode' (පෙළ මාදිලිය) සහ 'Binary mode' (ද්වීමය මාදිලිය) අතර ඇති ප්‍රධාන වෙනස කුමක්ද?",
        options: [
            "Text mode වේගවත් වන අතර, Binary mode මන්දගාමී වේ.",
            "Text mode ASCII අක්ෂර පමණක් ලියන අතර, Binary mode ඕනෑම දත්ත වර්ගයක් ලියයි.",
            "Text mode නව පේළි අක්ෂර ස්වයංක්‍රීයව පරිවර්තනය කරන අතර, Binary mode එසේ නොකරයි.",
            "Binary mode කුඩා ගොනු සඳහා පමණක් භාවිතා කළ හැක.",
            "Text mode මගින් ගොනුවක් මකා දැමිය හැක."
        ],
        correctAnswerIndex: 2,
        explanation: "Text mode (උදා: 'r', 'w', 'a') ගොනුවලට කියවීමට/ලිවීමට පෙළ දත්ත සමඟ කටයුතු කරයි. එය මෙහෙයුම් පද්ධතියට අනුකූලව නව පේළි අක්ෂර (`\n`) ස්වයංක්‍රීයව පරිවර්තනය කරයි. Binary mode (උදා: 'rb', 'wb', 'ab') 'කඩදාසි' බයිට (raw bytes) සමඟ කටයුතු කරන අතර, කිසිදු ස්වයංක්‍රීය පරිවර්තනයක් සිදු නොකරයි. රූප, ශ්‍රව්‍ය හෝ වීඩියෝ වැනි ද්වීමය දත්ත හැසිරවීමට Binary mode භාවිතා වේ."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී ගොනුවකින් දත්ත කියවන විට, ගොනුවේ අවසානයට (End-Of-File / EOF) ළඟා වූ බව හඳුනා ගන්නේ කෙසේද?",
        options: [
            "read() method එක දෝෂයක් ලබා දෙන විට",
            "read() method එක හිස් String එකක් ලබා දෙන විට",
            "read() method එක 0 අගයක් ලබා දෙන විට",
            "ගොනුව ස්වයංක්‍රීයව වැසී යන විට",
            "ගොනුවට ලිවීමට නොහැකි වන විට"
        ],
        correctAnswerIndex: 1,
        explanation: "බොහෝ ක්‍රමලේඛන භාෂාවලදී, ගොනුවකින් දත්ත කියවීමේදී `read()` හෝ `readline()` වැනි methods මගින් ගොනුවේ අවසානයට (EOF) ළඟා වූ විට හිස් String එකක් (empty string) ආපසු ලබා දෙයි. මෙය ගොනුවේ අවසානය හඳුනා ගැනීමට ප්‍රධාන ක්‍රමයකි."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී ගොනුවක් 'exclusive creation mode' ('x' mode) වලින් විවෘත කිරීමේදී සිදුවන ප්‍රධාන දෙය කුමක්ද?",
        options: [
            "ගොනුවක් නොමැති නම් නව ගොනුවක් සාදයි, ගොනුවක් දැනටමත් පවතී නම් දෝෂයක් ඇති කරයි.",
            "ගොනුවේ පවතින දත්ත මකා දමයි.",
            "ගොනුවට නව දත්ත එකතු කරයි.",
            "ගොනුව කියවීමට පමණක් විවෘත කරයි.",
            "ගොනුවක් නොමැති නම් කිසිවක් සිදු නොකරයි."
        ],
        correctAnswerIndex: 0,
        explanation: "'x' mode (exclusive creation) මගින් ගොනුවක් නොමැති නම් පමණක් නව ගොනුවක් සාදයි. ගොනුවක් දැනටමත් පවතී නම්, එය FileExistsError වැනි දෝෂයක් ඇති කරයි. මෙය දැනටමත් පවතින ගොනු අහම්බෙන් නැවත ලිවීම වැළැක්වීමට ප්‍රයෝජනවත් වේ."
    },
    {
        questionText: "පහත දැක්වෙන Python කේත කොටසෙහි, `with open('output.txt', 'w') as f: f.write('Data');` මෙම `with` ප්‍රකාශය භාවිතා කිරීමේ ප්‍රධාන වාසිය කුමක්ද?",
        options: [
            "දත්ත ලිවීම වේගවත් කිරීම",
            "ගොනුව ස්වයංක්‍රීයව වසා දැමීම සහතික කිරීම, දෝෂයක් ඇති වුවද",
            "ගොනුවේ ප්‍රමාණය පාලනය කිරීම",
            "ගොනුවේ අන්තර්ගතය සංකේතනය කිරීම",
            "ගොනුව කියවීමට පමණක් ඉඩ දීම"
        ],
        correctAnswerIndex: 1,
        explanation: "`with open(...) as f:` ප්‍රකාශනය Python හි 'context manager' ලෙස හැඳින්වේ. මෙය ගොනුවක් විවෘත කර මෙහෙයුම් සිදු කිරීමෙන් පසු, ක්‍රමලේඛයේ දෝෂයක් ඇති වුවද, ගොනුව ස්වයංක්‍රීයව සහ නිසියාකාරව වසා දැමීම සහතික කරයි. මෙය මතක කාන්දු වීම් (memory leaks) සහ දත්ත අලාභය වැළැක්වීමට උපකාරී වේ."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී ගොනුවකට දත්ත ලිවීමේදී, සෑම ලිවීමේ මෙහෙයුමකින් පසුවම ගොනුව 'flush' කිරීමේ (buffer එක හිස් කිරීමේ) වැදගත්කම කුමක්ද?",
        options: [
            "ගොනුවේ ප්‍රමාණය අඩු කිරීම",
            "ගොනුවේ ලිවීමේ වේගය වැඩි කිරීම",
            "ලියන ලද දත්ත වහාම ගොනුවේ ස්ථිරව සුරැකෙන බවට වග බලා ගැනීම",
            "ගොනුව කියවීමේ පහසුව වැඩි කිරීම",
            "ගොනුව සම්පූර්ණයෙන්ම මකා දැමීම"
        ],
        correctAnswerIndex: 2,
        explanation: "ක්‍රමලේඛනයකදී, ගොනුවකට දත්ත ලියන විට, දත්ත සෘජුවම දෘඪ තැටියට නොගොස් තාවකාලික බෆරයක (buffer) ගබඩා විය හැක. 'flush' කිරීම යනු මෙම බෆරයේ ඇති දත්ත වහාම ගොනුවට ලිවීමයි. මෙය දත්ත වහාම ස්ථිරව සුරැකෙන බවට වග බලා ගැනීමට උපකාරී වේ, විශේෂයෙන් විදුලිය විසන්ධි වීමක් වැනි හදිසි තත්ත්වයකදී දත්ත අහිමි වීම වළක්වා ගැනීමට."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී ගොනු හැසිරවීම සඳහා අදාළ නොවන ප්‍රධාන ආරක්ෂක සැලකිල්ලක් කුමක්ද?",
        options: [
            "අනවසර ගොනු ප්‍රවේශය වැළැක්වීම",
            "ගොනු මෙහෙයුම් මගින් සිදුවිය හැකි දෝෂ කළමනාකරණය",
            "සංවේදී දත්ත සංකේතනය කිරීම",
            "ගොනු මෙහෙයුම් වලදී පරිගණකයේ RAM භාවිතය අධීක්ෂණය කිරීම",
            "ගොනු මකා දැමීමේදී තහවුරු කිරීමේ යාන්ත්‍රණයක් භාවිතා කිරීම"
        ],
        correctAnswerIndex: 3,
        explanation: "ගොනු හැසිරවීමේදී, අනවසර ප්‍රවේශය, දෝෂ කළමනාකරණය, දත්ත සංකේතනය සහ දත්ත අහිමි වීම වැළැක්වීම වැනි ආරක්ෂක සැලකිලි වැදගත් වේ. නමුත් ගොනු මෙහෙයුම් වලදී පරිගණකයේ RAM භාවිතය අධීක්ෂණය කිරීම සාමාන්‍යයෙන් ආරක්ෂක සැලකිල්ලකට වඩා කාර්ය සාධන (performance) අධීක්ෂණයක් වේ."
    },
    {
        questionText: "පහත දැක්වෙන Python කේත කොටසෙහි, `readlines()` method එක මගින් ආපසු ලබා දෙන්නේ කුමක්ද? `file = open('names.txt', 'r'); all_lines = file.readlines(); file.close();` (names.txt හි 'Alice\nBob\nCharlie' අඩංගු වේ)",
        options: [
            "Alice",
            "Bob",
            "Charlie",
            "['Alice', 'Bob', 'Charlie']",
            "['Alice\n', 'Bob\n', 'Charlie']"
        ],
        correctAnswerIndex: 4,
        explanation: "`readlines()` method එක ගොනුවේ ඇති සෑම පේළියක්ම තනි String එකක් ලෙස අඩංගු වන List එකක් ආපසු ලබා දෙයි. සෑම String එකකම අවසානයේ නව පේළි අක්ෂරය (`\n`) ඇතුළත් වේ."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී, විශාල ගොනුවකින් දත්ත කියවන විට මතක කාර්යක්ෂමතාව (memory efficiency) සඳහා වඩාත් සුදුසු ක්‍රමය කුමක්ද?",
        options: [
            "ගොනුවේ සම්පූර්ණ අන්තර්ගතය එකවර මතකයට කියවීම",
            "ගොනුව වරකට එක් පේළියක් බැගින් කියවීම",
            "ගොනුව Binary mode වලින් විවෘත කිරීම",
            "ගොනුවට කිසිවක් නොලිවීම",
            "ගොනුවේ ප්‍රමාණය වැඩි කිරීම"
        ],
        correctAnswerIndex: 1,
        explanation: "විශාල ගොනුවක් සමඟ වැඩ කරන විට, ගොනුවේ සම්පූර්ණ අන්තර්ගතය එකවර මතකයට කියවීමෙන් මතක ගැටළු ඇති විය හැක. ගොනුව වරකට එක් පේළියක් බැගින් කියවීමෙන් (උදා: `readline()` හෝ ලූප් එකක් භාවිතයෙන්) මතක භාවිතය වඩාත් කාර්යක්ෂම කළ හැක, මන්ද එක් වරකට මතකයේ තබා ගන්නේ එක් පේළියක දත්ත පමණි."
    },

    // 9.12: දත්ත සමුදායක දත්ත කළමනාකරණය කරයි. (Database Management)
    {
        questionText: "ක්‍රමලේඛනයකදී දත්ත සමුදායකට සම්බන්ධ වීම (connecting to a database) මගින් අදහස් කරන්නේ කුමක්ද?",
        options: [
            "දත්ත සමුදායේ ඇති සියලුම දත්ත මකා දැමීම",
            "දත්ත සමුදායට නව වගු එකතු කිරීම",
            "ක්‍රමලේඛයට දත්ත සමුදාය සමඟ අන්තර් ක්‍රියා කිරීමට හැකි වන පරිදි සම්බන්ධතාවයක් (connection) ස්ථාපිත කිරීම",
            "දත්ත සමුදායේ පිහිටීම වෙනස් කිරීම",
            "දත්ත සමුදාය දෘඪ තැටියෙන් ඉවත් කිරීම"
        ],
        correctAnswerIndex: 2,
        explanation: "දත්ත සමුදායකට සම්බන්ධ වීම යනු ක්‍රමලේඛයකට දත්ත සමුදාය සමඟ තොරතුරු හුවමාරු කර ගැනීමට හැකි වන පරිදි ජාලයක් හරහා හෝ දේශීයව සම්බන්ධතාවයක් (connection) ස්ථාපිත කිරීමයි. මෙම සම්බන්ධතාවය මගින් ක්‍රමලේඛයට දත්ත සමුදාය තුළ දත්ත කළමනාකරණය කිරීමට (කියවීමට, ලිවීමට, වෙනස් කිරීමට, මකා දැමීමට) ඉඩ ලැබේ."
    },
    {
        questionText: "දත්ත සමුදායකින් දත්ත 'සමුද්ධරණය (retrieve data)' කිරීම සඳහා භාවිතා කරන ප්‍රධාන SQL ප්‍රකාශය කුමක්ද?",
        options: [
            "INSERT INTO",
            "UPDATE",
            "DELETE FROM",
            "SELECT",
            "CREATE TABLE"
        ],
        correctAnswerIndex: 3,
        explanation: "`SELECT` ප්‍රකාශය භාවිතා කරනුයේ දත්ත සමුදායකින් දත්ත ලබා ගැනීමටයි. ඔබට අවශ්‍ය තොරතුරු, වගු සහ කොන්දේසි සඳහන් කළ හැකිය."
    },
    {
        questionText: "දත්ත සමුදායකට නව දත්ත 'එකතු කිරීම (add)' සඳහා භාවිතා කරන නිවැරදි SQL ප්‍රකාශය කුමක්ද?",
        options: [
            "SELECT * FROM Customers",
            "UPDATE Products SET Price = 20",
            "DELETE FROM Orders",
            "INSERT INTO Customers (Name, City) VALUES ('Kamal', 'Colombo')",
            "CREATE DATABASE MyDatabase"
        ],
        correctAnswerIndex: 3,
        explanation: "`INSERT INTO` ප්‍රකාශය භාවිතා කරනුයේ දත්ත සමුදා වගුවකට නව වාර්තා (records) එකතු කිරීමටයි. වගුවේ නම, එකතු කළ යුතු තීරු (columns) සහ ඒවාට අනුරූප අගයන් සඳහන් කළ යුතුය."
    },
    {
        questionText: "දත්ත සමුදායක පවතින දත්ත 'නවීකරණය කිරීම (modify)' සඳහා භාවිතා කරන SQL ප්‍රකාශය කුමක්ද?",
        options: [
            "SELECT",
            "INSERT INTO",
            "UPDATE",
            "DELETE FROM",
            "DROP TABLE"
        ],
        correctAnswerIndex: 2,
        explanation: "`UPDATE` ප්‍රකාශය භාවිතා කරනුයේ දත්ත සමුදා වගුවක පවතින වාර්තා වල දත්ත වෙනස් කිරීමටයි. `SET` යතුරුවචනය මගින් වෙනස් කළ යුතු තීරු සහ නව අගයන් ද, `WHERE` යතුරුවචනය මගින් වෙනස් කළ යුතු වාර්තා තේරීමට කොන්දේසියක් ද සඳහන් කළ හැකිය."
    },
    {
        questionText: "දත්ත සමුදායකින් වාර්තා 'මැකීම (delete)' සඳහා භාවිතා කරන නිවැරදි SQL ප්‍රකාශය කුමක්ද?",
        options: [
            "SELECT * FROM Users",
            "INSERT INTO Users VALUES ('Kasun')",
            "UPDATE Users SET Status = 'Inactive'",
            "DELETE FROM Users WHERE UserID = 101",
            "CREATE TABLE Users"
        ],
        correctAnswerIndex: 3,
        explanation: "`DELETE FROM` ප්‍රකාශය භාවිතා කරනුයේ දත්ත සමුදා වගුවකින් වාර්තා (records) ඉවත් කිරීමටයි. `WHERE` යතුරුවචනය භාවිතා කිරීමෙන් මකා දැමිය යුතු නිශ්චිත වාර්තා තෝරා ගත හැකිය. `WHERE` කොන්දේසියක් නොමැතිව භාවිතා කළහොත් වගුවේ ඇති සියලුම වාර්තා මකා දමනු ඇත."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී දත්ත සමුදා සම්බන්ධතාවයක් (database connection) 'වසා දැමීම' අත්‍යවශ්‍ය වන්නේ ඇයි?",
        options: [
            "දත්ත සමුදායේ දත්ත මකා දැමීමට",
            "දත්ත සමුදායට නව දත්ත එකතු කිරීමට",
            "සම්පත් කාන්දු වීම් (resource leaks) වළක්වා ගැනීමට සහ සම්බන්ධතාවය වෙනත් ක්‍රමලේඛයන්ට භාවිතා කිරීමට ඉඩ දීමට",
            "SQL ප්‍රකාශ ලිවීම වැළැක්වීමට",
            "දත්ත සමුදායේ ක්‍රියාකාරීත්වය වැඩි කිරීමට"
        ],
        correctAnswerIndex: 2,
        explanation: "දත්ත සමුදා සම්බන්ධතාවයක් විවෘත කිරීමෙන් පසු, එය සමඟ වැඩ අවසන් වූ විට එය වසා දැමීම ඉතා වැදගත් වේ. මෙය සිදු කිරීමෙන්, දත්ත සමුදාය සමඟ ඇති සම්බන්ධතාවය සඳහා වෙන් කළ මතක සම්පත් සහ ජාල සම්පත් මුදා හරින අතර, එම සම්පත් වෙනත් ක්‍රමලේඛයන්ට හෝ පරිශීලකයන්ට භාවිතා කිරීමට ඉඩ සලසයි. සම්බන්ධතා වසා නොදැමීමෙන් 'සම්පත් කාන්දු වීම්' ඇති විය හැක."
    },
    {
        questionText: "දත්ත සමුදායක් සමඟ ක්‍රමලේඛන භාෂාවක් මගින් අන්තර් ක්‍රියා කිරීමේදී, SQL ප්‍රකාශ ක්‍රියාත්මක කිරීමට භාවිතා කරන ප්‍රධාන වස්තුව (object) කුමක්ද?",
        options: [
            "Connection object",
            "Table object",
            "Column object",
            "Row object",
            "Database file"
        ],
        correctAnswerIndex: 0,
        explanation: "ක්‍රමලේඛන භාෂාවක් මගින් දත්ත සමුදායක් සමඟ අන්තර් ක්‍රියා කිරීමේදී, සාමාන්‍යයෙන් 'Connection object' එකක් නිර්මාණය කරනු ලැබේ. මෙම Connection object එක හරහා SQL ප්‍රකාශ දත්ත සමුදායට යැවීමට සහ ප්‍රතිඵල ලබා ගැනීමට 'Cursor object' වැනි තවත් වස්තූන් භාවිතා කළ හැකිය."
    },
    {
        questionText: "දත්ත සමුදායකට දත්ත 'එකතු කිරීමේදී (adding)' දත්ත වල අඛණ්ඩතාව (data integrity) සහතික කිරීම සඳහා ප්‍රධාන වශයෙන් භාවිතා කරන SQL සංකල්පය කුමක්ද?",
        options: [
            "SELECT",
            "ORDER BY",
            "WHERE",
            "CONSTRAINTS (e.g., PRIMARY KEY, UNIQUE, NOT NULL)",
            "GROUP BY"
        ],
        correctAnswerIndex: 3,
        explanation: "දත්ත වල අඛණ්ඩතාව සහතික කිරීම සඳහා `CONSTRAINTS` (සීමාවන්) භාවිතා වේ. `PRIMARY KEY`, `UNIQUE`, `NOT NULL`, `FOREIGN KEY` වැනි constraints මගින් දත්ත වල නිරවද්‍යතාවය, අනුකූලතාවය සහ විශ්වසනීයත්වය පවත්වා ගැනීමට උපකාරී වේ, විශේෂයෙන් නව දත්ත එකතු කිරීමේදී."
    },
    {
        questionText: "පහත දැක්වෙන ක්‍රමලේඛනයකදී, SQL Injection ප්‍රහාරයක් වළක්වා ගැනීම සඳහා ආරක්ෂිතම ක්‍රමය කුමක්ද?",
        options: [
            "පරිශීලකයාගේ ආදානය සෘජුවම SQL ප්‍රකාශය සමඟ සම්බන්ධ කිරීම",
            "SQL ප්‍රකාශ සිරස්තල (comments) සමඟ ආරම්භ කිරීම",
            "SQL ප්‍රකාශ වලදී `SELECT *` පමණක් භාවිතා කිරීම",
            "Prepared Statements හෝ Parameterized Queries භාවිතා කිරීම",
            "දත්ත සමුදාය වෙත ප්‍රවේශය කිසිවෙකුටත් නොදීම"
        ],
        correctAnswerIndex: 3,
        explanation: "SQL Injection ප්‍රහාරයක් යනු ද්වේශ සහගත පරිශීලක ආදානයක් මගින් SQL ප්‍රකාශය වෙනස් කර අනවසර දත්ත ප්‍රවේශයක් හෝ වෙනස් කිරීමක් සිදු කිරීමයි. මෙය වළක්වා ගැනීමට ආරක්ෂිතම ක්‍රමය වන්නේ Prepared Statements හෝ Parameterized Queries භාවිතා කිරීමයි. මෙමගින් පරිශීලක ආදානය දත්ත ලෙස සලකන අතර, SQL කේත කොටසක් ලෙස ක්‍රියාත්මක කිරීම වළක්වයි."
    },
    {
        questionText: "දත්ත සමුදායකින් දත්ත 'සමුද්ධරණය (retrieve)' කිරීමේදී, නිශ්චිත කොන්දේසි මත පදනම්ව වාර්තා පෙරහන් කිරීමට (filter) භාවිතා කරන SQL ප්‍රකාශය කුමක්ද?",
        options: [
            "INSERT INTO",
            "UPDATE",
            "DELETE FROM",
            "WHERE",
            "ORDER BY"
        ],
        correctAnswerIndex: 3,
        explanation: "`WHERE` යතුරුවචනය `SELECT`, `UPDATE` සහ `DELETE` ප්‍රකාශ සමඟ භාවිතා කරනුයේ යම් කොන්දේසියක් සපුරාලන වාර්තා පමණක් තෝරා ගැනීමට, වෙනස් කිරීමට හෝ මකා දැමීමටයි."
    },
    {
        questionText: "දත්ත සමුදායක දත්ත කළමනාකරණය (Data Manipulation) සඳහා SQL හි ප්‍රධාන කාණ්ඩයක් නොවන්නේ කුමක්ද?",
        options: [
            "Data Definition Language (DDL)",
            "Data Query Language (DQL)",
            "Data Manipulation Language (DML)",
            "Data Control Language (DCL)",
            "Transaction Control Language (TCL)"
        ],
        correctAnswerIndex: 0,
        explanation: "Data Manipulation (දත්ත හැසිරවීම) යනු දත්ත සමුදාය තුළ දත්ත එකතු කිරීම, වෙනස් කිරීම සහ මකා දැමීමයි. මේ සඳහා භාවිතා කරන SQL ප්‍රකාශ අයත් වන්නේ Data Manipulation Language (DML) කාණ්ඩයටයි (උදා: INSERT, UPDATE, DELETE). Data Definition Language (DDL) යනු වගු සහ දත්ත සමුදා ව්‍යුහය නිර්මාණය කිරීමට, වෙනස් කිරීමට සහ මකා දැමීමට (CREATE, ALTER, DROP) භාවිතා වේ, එය දත්ත කළමනාකරණයට වඩා ව්‍යුහය නිර්මාණයට සම්බන්ධයි."
    },
    {
        questionText: "දත්ත සමුදායකට සම්බන්ධ වීමට අවශ්‍ය වන මූලික තොරතුරු අංගයක් නොවන්නේ කුමක්ද?",
        options: [
            "දත්ත සමුදා සත්කාරකයේ නම (Hostname/IP Address)",
            "දත්ත සමුදායේ නම (Database Name)",
            "පරිශීලක නාමය (Username)",
            "මුරපදය (Password)",
            "පරිගණකයේ RAM ප්‍රමාණය"
        ],
        correctAnswerIndex: 4,
        explanation: "දත්ත සමුදායකට සම්බන්ධ වීමට දත්ත සමුදායේ ස්ථානය (Hostname/IP), දත්ත සමුදායේ නම, සහ ප්‍රවේශ අක්තපත්‍ර (පරිශීලක නාමය, මුරපදය) වැනි තොරතුරු අත්‍යවශ්‍ය වේ. පරිගණකයේ RAM ප්‍රමාණය දත්ත සමුදා සම්බන්ධතාවයට අදාළ මූලික තොරතුරක් නොවේ, එය පරිගණකයේ සාමාන්‍ය ක්‍රියාකාරීත්වයට අදාළ වේ."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී දත්ත සමුදායක් සමඟ අන්තර් ක්‍රියා කිරීමේදී 'COMMIT' ප්‍රකාශය භාවිතා කිරීමේ අරමුණ කුමක්ද?",
        options: [
            "දත්ත සමුදා සම්බන්ධතාවය වසා දැමීමට",
            "දත්ත සමුදායේ සියලුම දත්ත මකා දැමීමට",
            "සිදු කරන ලද සියලුම දත්ත වෙනස් කිරීම් දත්ත සමුදායේ ස්ථිරව සුරැකීමට",
            "දත්ත සමුදායෙන් දත්ත කියවීමට",
            "නව දත්ත සමුදායක් නිර්මාණය කිරීමට"
        ],
        correctAnswerIndex: 2,
        explanation: "`COMMIT` ප්‍රකාශය Transaction Control Language (TCL) යටතට වැටේ. එය දත්ත සමුදාය තුළ සිදු කරන ලද සියලුම වෙනස්කම් (INSERT, UPDATE, DELETE වැනි) ස්ථිරව සුරැකීමට (persisting changes) භාවිතා කරයි. `COMMIT` නොකළහොත්, එම වෙනස්කම් තාවකාලික වන අතර, යම් දෝෂයක් හෝ ක්‍රමලේඛය බිඳ වැටීමක් සිදුවුවහොත් ඒවා අහිමි විය හැක."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී දත්ත සමුදායක් සමඟ අන්තර් ක්‍රියා කිරීමේදී 'ROLLBACK' ප්‍රකාශය භාවිතා කිරීමේ අරමුණ කුමක්ද?",
        options: [
            "දත්ත සමුදායේ සියලුම දත්ත මකා දැමීමට",
            "සිදු කරන ලද සියලුම දත්ත වෙනස් කිරීම් අවලංගු කිරීමට සහ පෙර තත්ත්වයට යාමට",
            "දත්ත සමුදාය නැවත ආරම්භ කිරීමට",
            "නව දත්ත සමුදායක් නිර්මාණය කිරීමට",
            "දත්ත සමුදායේ දෝෂ නිවැරදි කිරීමට"
        ],
        correctAnswerIndex: 1,
        explanation: "`ROLLBACK` ප්‍රකාශය ද Transaction Control Language (TCL) යටතට වැටේ. එය `COMMIT` නොකළ, දත්ත සමුදාය තුළ සිදු කරන ලද සියලුම වෙනස් කිරීම් අවලංගු කිරීමට (undo) භාවිතා කරයි. යම් මෙහෙයුමක් දෝෂයකින් අවසන් වුවහොත් හෝ අනවශ්‍ය වෙනස්කම් සිදු වුවහොත් පෙර තත්ත්වයට යාමට මෙය ප්‍රයෝජනවත් වේ."
    },
    {
        questionText: "ක්‍රමලේඛන භාෂාවකින් දත්ත සමුදායක් තුළ වගුවක ව්‍යුහය වෙනස් කිරීමට (උදා: තීරුවක් එකතු කිරීම) භාවිතා කළ හැකි SQL ප්‍රකාශය කුමක්ද?",
        options: [
            "SELECT",
            "INSERT INTO",
            "UPDATE",
            "DELETE FROM",
            "ALTER TABLE"
        ],
        correctAnswerIndex: 4,
        explanation: "`ALTER TABLE` යනු Data Definition Language (DDL) ප්‍රකාශයකි. එය දත්ත සමුදා වගුවක ව්‍යුහය වෙනස් කිරීමට (උදා: නව තීරුවක් එකතු කිරීම, තීරුවක දත්ත වර්ගය වෙනස් කිරීම, තීරුවක් ඉවත් කිරීම) භාවිතා කරයි."
    },
    {
        questionText: "දත්ත සමුදායකින් දත්ත 'සමුද්ධරණය' කිරීමේදී, ප්‍රතිඵල වාර්තා යම් තීරුවක් අනුව 'වර්ග කිරීමට (sort)' භාවිතා කරන SQL ප්‍රකාශය කුමක්ද?",
        options: [
            "WHERE",
            "GROUP BY",
            "HAVING",
            "ORDER BY",
            "LIMIT"
        ],
        correctAnswerIndex: 3,
        explanation: "`ORDER BY` යතුරුවචනය `SELECT` ප්‍රකාශය සමඟ භාවිතා කරනුයේ ප්‍රතිඵල වාර්තා (result set) එකක් හෝ වැඩි ගණනක් තීරු (columns) අනුව ආරෝහණ (ASC) හෝ අවරෝහණ (DESC) අනුපිළිවෙලට වර්ග කිරීමටයි."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී දත්ත සමුදා මෙහෙයුම් සිදු කිරීමේදී ඇති විය හැකි 'Concurrency Issues' (සමකාලීන ගැටළු) යනු කුමක්ද?",
        options: [
            "දත්ත සමුදාය ඉතා සෙමින් ක්‍රියාත්මක වීම",
            "එකවර බහුවිධ පරිශීලකයන් හෝ ක්‍රමලේඛ කොටස් දත්ත සමුදායට ප්‍රවේශ වන විට ඇතිවන දත්ත අඛණ්ඩතා ගැටළු",
            "දත්ත සමුදා සම්බන්ධතාවය බිඳ වැටීම",
            "SQL ප්‍රකාශ වල ඇති සින්ටැක්ස් දෝෂ",
            "දත්ත සමුදාය ප්‍රමාණවත් තරම් දත්ත නොමැති වීම"
        ],
        correctAnswerIndex: 1,
        explanation: "Concurrency Issues (සමකාලීන ගැටළු) යනු එකවර බහුවිධ පරිශීලකයන් හෝ ක්‍රමලේඛ කොටස් දත්ත සමුදායට ප්‍රවේශ වන විට සහ දත්ත වෙනස් කරන විට ඇතිවන ගැටළු වේ. උදාහරණයක් ලෙස, එකම දත්තයක් එකවර වෙනස් කිරීමට උත්සාහ කිරීමෙන් දත්ත අඛණ්ඩතාවයට හානි විය හැකිය. මේවා කළමනාකරණය කිරීමට Transaction Management සහ Locking වැනි යාන්ත්‍රණ භාවිතා වේ."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී දත්ත සමුදායක් තුළ වගුවක් 'මැකීමට (delete a table)' භාවිතා කරන SQL ප්‍රකාශය කුමක්ද?",
        options: [
            "DELETE FROM TableName",
            "REMOVE TableName",
            "DROP TABLE TableName",
            "ERASE TableName",
            "CLEAR TableName"
        ],
        correctAnswerIndex: 2,
        explanation: "`DROP TABLE` යනු Data Definition Language (DDL) ප්‍රකාශයකි. එය දත්ත සමුදායකින් සම්පූර්ණ වගුවක් (වගුවේ ව්‍යුහය සහ එහි ඇති සියලුම දත්ත සමඟ) ස්ථිරවම මකා දැමීමට භාවිතා කරයි."
    },
    {
        questionText: "පහත දැක්වෙන SQL ප්‍රකාශය කුමක් සඳහා භාවිතා කරන්නේද? `SELECT COUNT(*) FROM Students;`",
        options: [
            "Students වගුවේ සිටින සිසුන්ගේ නම් ලබා ගැනීමට",
            "Students වගුවට නව ශිෂ්‍යයෙකු එකතු කිරීමට",
            "Students වගුවේ ඇති වාර්තා ගණන ගණනය කිරීමට",
            "Students වගුවෙන් සිසුන් ඉවත් කිරීමට",
            "Students වගුවේ සිසුන්ගේ තොරතුරු වෙනස් කිරීමට"
        ],
        correctAnswerIndex: 2,
        explanation: "`COUNT(*)` යනු SQL හි Aggregates Function එකකි. එය වගුවක හෝ `SELECT` ප්‍රකාශයක ප්‍රතිඵල කට්ටලයක ඇති වාර්තා ගණන ගණනය කිරීමට භාවිතා කරයි."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී දත්ත සමුදායක් සමඟ වැඩ කිරීමේදී 'Error Handling' (දෝෂ හැසිරවීම) අත්‍යවශ්‍ය වන්නේ ඇයි?",
        options: [
            "දත්ත සමුදාය වේගවත් කිරීමට",
            "SQL ප්‍රකාශ වල සින්ටැක්ස් දෝෂ වළක්වා ගැනීමට",
            "දත්ත සමුදා සම්බන්ධතා අසාර්ථක වීම්, දත්ත නොගැළපීම් හෝ ප්‍රවේශ අවසර ගැටළු වැනි අවස්ථා කළමනාකරණය කිරීමට",
            "දත්ත සමුදායේ ප්‍රමාණය අඩු කිරීමට",
            "දත්ත සමුදාය ආරක්ෂා කිරීමට"
        ],
        correctAnswerIndex: 2,
        explanation: "දත්ත සමුදා මෙහෙයුම් වලදී විවිධ දෝෂ ඇතිවිය හැකිය, උදාහරණයක් ලෙස දත්ත සමුදායට සම්බන්ධ වීමට නොහැකි වීම, SQL ප්‍රකාශ ක්‍රියාත්මක කිරීමේදී දෝෂ, දත්ත වල වලංගු නොවන අගයන් ඇතුළත් කිරීම. දෝෂ හැසිරවීම (Error Handling) මගින් මෙම දෝෂ නිසියාකාරව හඳුනාගෙන, ක්‍රමලේඛය බිඳ වැටීමකින් තොරව ඒවාට ප්‍රතිචාර දැක්වීමට ඉඩ සලසයි."
    },

    // 9.13: දත්ත සොයා තෝරයි (searches and sorts data). (Search and Sort Algorithms)
    {
        questionText: "දත්ත සමූහයක් තුළින් නිශ්චිත අගයක් සොයා ගැනීමට භාවිතා කරන සෙවුම් ශිල්ප ක්‍රමයක් කුමක්ද?",
        options: [
            "Bubble Sort",
            "Merge Sort",
            "Quick Sort",
            "Sequential Search",
            "Selection Sort"
        ],
        correctAnswerIndex: 3,
        explanation: "Sequential Search (අනුක්‍රමික සෙවුම) යනු සෙවුම් ඇල්ගොරිතමයකි. එය දත්ත සමූහයක ආරම්භයේ සිට අවසානය දක්වා අනුපිළිවෙලින් එක් එක් අංගය පරීක්ෂා කරමින්, සොයන අගය සොයා ගන්නා තුරු හෝ සමූහයේ අවසානයට ළඟා වන තුරු ගමන් කරයි."
    },
    {
        questionText: "දත්ත සමූහයක අගයන් කුඩාම අගයේ සිට විශාලතම අගය දක්වා (හෝ අනෙක් අතට) 'වර්ග කිරීමට (sort)' භාවිතා කරන තේරීම් ශිල්ප ක්‍රමයක් කුමක්ද?",
        options: [
            "Sequential Search",
            "Binary Search",
            "Bubble Sort",
            "Hashing",
            "Recursion"
        ],
        correctAnswerIndex: 2,
        explanation: "Bubble Sort (බුබුළු තේරීම / යා-සසඳා තේරීම) යනු සරල වර්ග කිරීමේ ඇල්ගොරිතමයකි. එය අනුක්‍රමිකව යාබද අංග යුගල සංසන්දනය කර වැරදි අනුපිළිවෙලක තිබේ නම් ඒවා මාරු කරයි. මෙම ක්‍රියාවලිය දත්ත සම්පූර්ණයෙන්ම වර්ග කරන තෙක් නැවත නැවත සිදු කරයි."
    },
    {
        questionText: "අනුක්‍රමික සෙවුම් ශිල්ප ක්‍රමයේ (sequential search) ප්‍රධාන අවාසිය කුමක්ද?",
        options: [
            "එය වර්ග කළ දත්ත සඳහා පමණක් භාවිතා කළ හැකි වීම",
            "කුඩා දත්ත සමූහයන් සඳහා පමණක් කාර්යක්ෂම වීම",
            "විශාල දත්ත සමූහයන් සඳහා ඉතා මන්දගාමී විය හැකි වීම",
            "එය ක්‍රමලේඛනය කිරීමට ඉතා සංකීර්ණ වීම",
            "එය අද්විතීය අගයන් පමණක් සොයන බැවින්"
        ],
        correctAnswerIndex: 2,
        explanation: "අනුක්‍රමික සෙවුම සරල වුවද, විශාල දත්ත සමූහයන් සඳහා එය ඉතා මන්දගාමී විය හැකිය. නරකම අවස්ථාවකදී, සොයන අගය සමූහයේ අවසානයේ තිබේ නම් හෝ නොපවතී නම්, සමූහයේ ඇති සෑම අංගයක්ම පරීක්ෂා කිරීමට සිදුවනු ඇත. එබැවින් එහි කාල සංකීර්ණතාවය O(n) වේ."
    },
    {
        questionText: "බුබුළු තේරීම් ශිල්ප ක්‍රමයේ (bubble sort) ප්‍රධාන අවාසියක් කුමක්ද?",
        options: [
            "එය කුඩා දත්ත සමූහයන් සඳහා ක්‍රියාත්මක නොවීම",
            "එය විශාල දත්ත සමූහයන් සඳහා කාර්යක්ෂම නොවීම",
            "එය ක්‍රමලේඛනය කිරීමට ඉතා සංකීර්ණ වීම",
            "එය වර්ග කළ දත්ත සඳහා පමණක් භාවිතා කළ හැකි වීම",
            "එය ඉතා වේගවත් වීම"
        ],
        correctAnswerIndex: 1,
        explanation: "බුබුළු තේරීම යනු සරල වර්ග කිරීමේ ඇල්ගොරිතමයකි, නමුත් එය විශාල දත්ත සමූහයන් සඳහා කාර්යක්ෂම නොවේ. එහි කාල සංකීර්ණතාවය නරකම අවස්ථාවකදී සහ සාමාන්‍ය අවස්ථාවකදී O(n^2) වේ, එය විශාල දත්ත කට්ටල සඳහා ඉතා මන්දගාමී වේ. වඩාත් සංකීර්ණ වර්ග කිරීමේ ඇල්ගොරිතම (උදා: Merge Sort, Quick Sort) විශාල දත්ත සඳහා වඩාත් කාර්යක්ෂම වේ."
    },
    {
        questionText: "දත්ත සමූහයක් වර්ග කිරීමට අවශ්‍ය වන අවස්ථාවකදී, අනුක්‍රමික සෙවුම (sequential search) භාවිතා කළ හැකිද?",
        options: [
            "ඔව්, එය වර්ග කිරීමේ ඇල්ගොරිතමයකි.",
            "නැහැ, එය වර්ග කිරීමේ ඇල්ගොරිතමයක් නොවේ, එය සෙවුම් ඇල්ගොරිතමයකි.",
            "ඔව්, නමුත් එය ඉතා සෙමින් වර්ග කරයි.",
            "නැහැ, එය වර්ග කළ දත්ත සඳහා පමණක් භාවිතා කළ හැක.",
            "සම්බන්ධයක් නැත, එය සෙවුම් ශිල්ප ක්‍රමයක් පමණි."
        ],
        correctAnswerIndex: 1,
        explanation: "අනුක්‍රමික සෙවුම යනු 'සෙවුම් ඇල්ගොරිතමයකි' (searching algorithm), එය දත්ත සමූහයකින් නිශ්චිත අගයක් සොයා ගැනීමට භාවිතා කරයි. එය දත්ත 'වර්ග කිරීමට' (sorting) භාවිතා නොවේ. දත්ත වර්ග කිරීම සඳහා Bubble Sort, Merge Sort, Quick Sort වැනි 'වර්ග කිරීමේ ඇල්ගොරිතම' භාවිතා කළ යුතුය."
    },
    {
        questionText: "යම් දත්ත සමූහයක් වර්ග කර ඇත්නම්, අනුක්‍රමික සෙවුමට (sequential search) වඩා කාර්යක්ෂමව දත්ත සෙවීම සඳහා භාවිතා කළ හැකි ශිල්ප ක්‍රමයක් කුමක්ද?",
        options: [
            "Bubble Sort",
            "Linear Sort",
            "Binary Search",
            "Random Search",
            "Sequential Sort"
        ],
        correctAnswerIndex: 2,
        explanation: "දත්ත සමූහයක් වර්ග කර ඇත්නම්, Binary Search (ද්විමය සෙවුම) අනුක්‍රමික සෙවුමට වඩා බෙහෙවින් කාර්යක්ෂම වේ. Binary Search මගින් සෑම පියවරකදීම සෙවුම් පරාසය අඩකින් අඩු කරයි, එබැවින් එහි කාල සංකීර්ණතාවය O(log n) වේ. අනුක්‍රමික සෙවුමේ කාල සංකීර්ණතාවය O(n) වේ."
    },
    {
        questionText: "බුබුළු තේරීම් ශිල්ප ක්‍රමය (bubble sort) වර්ග කිරීම සිදු කරන්නේ කුමන මූලධර්මය මතද?",
        options: [
            "දත්ත සමූහය අඩකින් බෙදා, නැවත නැවත වර්ග කිරීම",
            "පළමු අංගය තෝරාගෙන, ඉතිරි අංග සමඟ සංසන්දනය කිරීම",
            "යාබද අංග යුගල සංසන්දනය කර, වැරදි අනුපිළිවෙලක තිබේ නම් ඒවා මාරු කිරීම",
            "හැෂින් (hashing) වගුවක් භාවිතයෙන් දත්ත වර්ග කිරීම",
            "නියමිත ස්ථානයකට අංගයක් ඇතුළත් කිරීම"
        ],
        correctAnswerIndex: 2,
        explanation: "බුබුළු තේරීම ක්‍රියාත්මක වන්නේ යාබද අංග යුගල (adjacent elements) නැවත නැවත සංසන්දනය කරමින්. ඒවා වැරදි අනුපිළිවෙලක තිබේ නම්, ඒවායේ ස්ථාන මාරු කරයි. මෙම ක්‍රියාවලිය එක් 'පෙරළියක්' (pass) ලෙස හැඳින්වේ. මෙම පෙරළි කිහිපයක් සිදු කිරීමෙන් දත්ත සම්පූර්ණයෙන්ම වර්ග වේ."
    },
    {
        questionText: "පහත දැක්වෙන දත්ත සමූහය බුබුළු තේරීම (bubble sort) භාවිතයෙන් එක් පෙරළියකින් (one pass) පසු කුමක් වේද? ආරම්භක දත්ත: `[5, 1, 4, 2, 8]`",
        options: [
            "`[1, 2, 4, 5, 8]`",
            "`[1, 4, 2, 5, 8]`",
            "`[1, 5, 4, 2, 8]`",
            "`[5, 1, 4, 2, 8]`",
            "`[8, 5, 4, 2, 1]`"
        ],
        correctAnswerIndex: 1,
        explanation: "එක් පෙරළියක් (one pass) තුළදී: \n- (5, 1) සංසන්දනය කරයි, 1, 5 ලෙස මාරු කරයි: `[1, 5, 4, 2, 8]` \n- (5, 4) සංසන්දනය කරයි, 4, 5 ලෙස මාරු කරයි: `[1, 4, 5, 2, 8]` \n- (5, 2) සංසන්දනය කරයි, 2, 5 ලෙස මාරු කරයි: `[1, 4, 2, 5, 8]` \n- (5, 8) සංසන්දනය කරයි, මාරු නොකරයි: `[1, 4, 2, 5, 8]` \nඑබැවින් එක් පෙරළියකින් පසු ප්‍රතිඵලය `[1, 4, 2, 5, 8]` වේ."
    },
    {
        questionText: "අනුක්‍රමික සෙවුම් ශිල්ප ක්‍රමය (sequential search) යෙදීමට පෙර දත්ත සමූහයක් වර්ග කර තිබීම අනිවාර්යද?",
        options: [
            "ඔව්, එය කාර්යක්ෂමව ක්‍රියාත්මක වීමට වර්ග කර තිබිය යුතුය.",
            "නැහැ, වර්ග නොකළ දත්ත සමූහයන් සඳහාද එය භාවිතා කළ හැකිය.",
            "ඔව්, නැතිනම් දෝෂයක් ඇති වේ.",
            "නැහැ, නමුත් වර්ග කර තිබේ නම් වේගවත් වේ.",
            "එය දත්ත වර්ගය මත රඳා පවතී."
        ],
        correctAnswerIndex: 1,
        explanation: "අනුක්‍රමික සෙවුමේ ප්‍රධාන වාසියක් වන්නේ එය දත්ත සමූහයක් වර්ග කර තිබුණත් නැතත් භාවිතා කළ හැකි වීමයි. එය අනුපිළිවෙලින් එක් එක් අංගය පරීක්ෂා කරන බැවින්, දත්ත වල අනුපිළිවෙල එහි ක්‍රියාකාරීත්වයට අදාළ නොවේ (කාර්යක්ෂමතාවයට බලපෑම් කළත්)."
    },
    {
        questionText: "යම් ක්‍රමලේඛනයකදී, ඉතා විශාල, වර්ග නොකළ දත්ත සමූහයකින් නිශ්චිත අගයක් සොයා ගැනීමට වඩාත් සුදුසු සෙවුම් ශිල්ප ක්‍රමය කුමක්ද?",
        options: [
            "Binary Search",
            "Bubble Sort",
            "Sequential Search",
            "Quick Sort",
            "Merge Sort"
        ],
        correctAnswerIndex: 2,
        explanation: "Binary Search සඳහා දත්ත වර්ග කර තිබිය යුතුය. විශාල, වර්ග නොකළ දත්ත සමූහයකින් අගයක් සෙවීමට නම්, මුලින්ම දත්ත වර්ග කිරීමට විශාල කාලයක් ගත විය හැක. එවැනි අවස්ථාවකදී, Sequential Search (අනුක්‍රමික සෙවුම) යනු වර්ග කිරීමකින් තොරව කෙලින්ම යෙදිය හැකි එකම මූලික සෙවුම් ශිල්ප ක්‍රමයයි."
    },
    {
        questionText: "සෙවුම් සහ වර්ග කිරීමේ ඇල්ගොරිතම අධ්‍යයනය කිරීමෙන් ක්‍රමලේඛකයෙකුට ලැබෙන ප්‍රධාන වාසිය කුමක්ද?",
        options: [
            "ක්‍රමලේඛ ලිවීමට ගතවන කාලය වැඩි කිරීම",
            "ක්‍රමලේඛයේ ප්‍රමාණය වැඩි කිරීම",
            "ක්‍රමලේඛයේ දෝෂ ගණන වැඩි කිරීම",
            "කාර්යක්ෂම දත්ත හැසිරවීම සඳහා හොඳම ක්‍රමවේදයන් තෝරා ගැනීමට සහ නිර්මාණය කිරීමට හැකි වීම",
            "ක්‍රමලේඛන භාෂාවන් ඉගෙනීම පහසු වීම"
        ],
        correctAnswerIndex: 3,
        explanation: "සෙවුම් සහ වර්ග කිරීමේ ඇල්ගොරිතම පිළිබඳ අවබෝධය ක්‍රමලේඛකයෙකුට ඉතා වැදගත් වේ. එමගින්, යම් ගැටලුවක් විසඳීම සඳහා දත්ත හැසිරවීමට (සෙවීමට හෝ වර්ග කිරීමට) වඩාත්ම කාර්යක්ෂම ඇල්ගොරිතමය කුමක්ද යන්න තීරණය කිරීමටත්, අවශ්‍ය නම් නව ඇල්ගොරිතම නිර්මාණය කිරීමටත් හැකියාව ලැබේ. මෙය ක්‍රමලේඛයක ක්‍රියාකාරීත්වයට සෘජුවම බලපායි."
    },
    {
        questionText: "පහත දැක්වෙන දත්ත සමූහය බුබුළු තේරීම (bubble sort) භාවිතයෙන් සම්පූර්ණයෙන්ම වර්ග කිරීමට අවම වශයෙන් අවශ්‍ය වන පෙරළි (passes) ගණන කීයද? දත්ත: `[3, 1, 2]`",
        options: [
            "1",
            "2",
            "3",
            "4",
            "5"
        ],
        correctAnswerIndex: 1,
        explanation: "දත්ත: `[3, 1, 2]` \n**පළමු පෙරළිය:** \n- (3, 1) -> `[1, 3, 2]` \n- (3, 2) -> `[1, 2, 3]` (දැන් වර්ග කර ඇත) \nදෙවන පෙරළියකදී කිසිදු මාරු කිරීමක් සිදු නොවන බැවින්, ඇල්ගොරිතමය අවසන් වේ. එබැවින් අවම වශයෙන් අවශ්‍ය වන්නේ පෙරළි 2ක් පමණි (එකක් වර්ග කිරීමට, අනෙක වර්ග කර ඇති බව තහවුරු කිරීමට)."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී, අනුක්‍රමික සෙවුම් ශිල්ප ක්‍රමය (sequential search) ක්‍රියාත්මක කිරීමට අවශ්‍ය වන ප්‍රධාන ව්‍යුහය කුමක්ද?",
        options: [
            "කවුන්ටර ලූප් එකක් (counter-controlled loop)",
            "කොන්දේසි ලූප් එකක් (condition-controlled loop)",
            "නොනවතින ලූප් එකක් (infinite loop)",
            "තේරීම් ප්‍රකාශනයක් (selection statement)",
            "පරාමිති නැති ශ්‍රූතියක්"
        ],
        correctAnswerIndex: 1,
        explanation: "අනුක්‍රමික සෙවුමකදී, සොයන අගය සොයා ගන්නා තුරු හෝ දත්ත සමූහයේ අවසානයට ළඟා වන තුරු ලූප් එකක් දිගටම ක්‍රියාත්මක විය යුතුය. මෙය කොන්දේසි මත පදනම් වූ ලූප් එකක් (උදා: `while` ලූප්) සඳහා හොඳ උදාහරණයකි. කවුන්ටර ලූප් (for loop) ද භාවිතා කළ හැකි වුවද, කොන්දේසියක් සත්‍ය වන තුරු ක්‍රියාත්මක වන ලූප් එක වඩාත් ස්වාභාවිකය."
    },
    {
        questionText: "දත්ත සමූහයකින් නිශ්චිත අගයක් සොයා ගැනීම සඳහා අනුක්‍රමික සෙවුම් ශිල්ප ක්‍රමය ක්‍රියාත්මක කිරීමේදී, සොයන අගය මුලින්ම හමු වුවහොත්, ඉතිරි දත්ත පරීක්ෂා කරන්නේද?",
        options: [
            "ඔව්, එය සෑම විටම සියලුම දත්ත පරීක්ෂා කරයි.",
            "නැහැ, සොයන අගය හමු වූ පසු සෙවීම නතර කරයි.",
            "එය දත්ත සමූහයේ ප්‍රමාණය මත රඳා පවතී.",
            "එය ක්‍රමලේඛන භාෂාව මත රඳා පවතී.",
            "සමහර විට."
        ],
        correctAnswerIndex: 1,
        explanation: "අනුක්‍රමික සෙවුමේදී, සොයන අගය දත්ත සමූහය තුළින් හමු වූ පසු, තවදුරටත් දත්ත පරීක්ෂා කිරීම අවශ්‍ය නොවේ. ඇල්ගොරිතමය එම ස්ථානයෙන් සෙවීම නතර කරනු ඇත. මෙය එහි කාර්යක්ෂමතාව වැඩි කරයි."
    },
    {
        questionText: "බුබුළු තේරීම් ශිල්ප ක්‍රමය (bubble sort) කුමන අවස්ථාවලදී භාවිතා කිරීම වඩාත් ප්‍රායෝගිකද?",
        options: [
            "දත්ත සමූහය ඉතා විශාල වන විට",
            "දත්ත සමූහය අර්ධ වශයෙන් වර්ග කර ඇති විට",
            "දත්ත සමූහය ඉතා කුඩා වන විට හෝ ඇල්ගොරිතමයේ සරලත්වය වඩාත් වැදගත් වන විට",
            "දත්ත සමූහය තුළ අද්විතීය අගයන් පමණක් ඇති විට",
            "දත්ත වර්ග කිරීමේ වේගය අතිශයින් වැදගත් වන විට"
        ],
        correctAnswerIndex: 2,
        explanation: "බුබුළු තේරීම යනු ක්‍රියාත්මක කිරීමට ඉතා සරල ඇල්ගොරිතමයකි. එබැවින්, දත්ත සමූහය ඉතා කුඩා වන විට හෝ ඇල්ගොරිතමයේ සරලත්වය සහ තේරුම් ගැනීමේ පහසුව කාර්යක්ෂමතාවයට වඩා වැදගත් වන විට (උදා: අධ්‍යාපනික අරමුණු සඳහා) එය ප්‍රායෝගික වේ. විශාල දත්ත කට්ටල සඳහා එය කාර්යක්ෂම නොවේ."
    },
    {
        questionText: "දත්ත සමූහයක ඇති අංගයන්ගේ ස්ථාන, බුබුළු තේරීම් ක්‍රමයේදී (bubble sort) වර්ග කිරීමේ ක්‍රියාවලියේදී වෙනස් වන්නේ කෙසේද?",
        options: [
            "අගයන් ඒවායේ අවසාන ස්ථාන වලට කෙලින්ම ගෙන යයි.",
            "යාබද අගයන් සංසන්දනය කර, වැරදි අනුපිළිවෙලක තිබේ නම් ඒවා මාරු කරයි.",
            "වගුවේ මුලට සෑම විටම කුඩාම අගය ගෙන එයි.",
            "යම් අගයක් තෝරාගෙන, ඉතිරි අගයන් සමඟ සංසන්දනය කර වර්ග කරයි.",
            "අනුක්‍රමිකව අගයන් ඉවත් කර නැවත ඇතුල් කරයි."
        ],
        correctAnswerIndex: 1,
        explanation: "බුබුළු තේරීමේ මූලික යාන්ත්‍රණය වන්නේ යාබද අගයන් යුගල වශයෙන් සංසන්දනය කර, ඒවා නිවැරදි අනුපිළිවෙලක නොමැති නම් ඒවායේ ස්ථාන 'මාරු කිරීම' (swapping) යි. මෙම ක්‍රියාවලිය මගින් විශාලතම අගයන් 'බුබුළු මෙන්' දත්ත සමූහයේ අවසානයට ගමන් කරයි."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී 'ඇල්ගොරිතමයක කාර්යක්ෂමතාවය (efficiency of an algorithm)' යන්නෙන් අදහස් කරන්නේ කුමක්ද?",
        options: [
            "ඇල්ගොරිතමය ක්‍රියාත්මක කිරීමට අවශ්‍ය කේත පේලි ගණන",
            "ඇල්ගොරිතමය අවසන් වීමට ගතවන කාලය",
            "ඇල්ගොරිතමය ක්‍රියාත්මක කිරීමට අවශ්‍ය වන කාලය සහ මතක සම්පත් ප්‍රමාණය",
            "ඇල්ගොරිතමය තුළ ඇති දෝෂ ගණන",
            "ඇල්ගොරිතමය ක්‍රියාත්මක කළ හැකි පරිගණක ගණන"
        ],
        correctAnswerIndex: 2,
        explanation: "ඇල්ගොරිතමයක කාර්යක්ෂමතාවය සාමාන්‍යයෙන් මනිනු ලබන්නේ එය ක්‍රියාත්මක කිරීමට ගතවන කාලය සහ එහි මතක සම්පත් භාවිතය මත ය. මෙය ඇල්ගොරිතමයේ කාල සංකීර්ණතාවය (time complexity) සහ අවකාශ සංකීර්ණතාවය (space complexity) ලෙස හැඳින්වේ. කාර්යක්ෂම ඇල්ගොරිතමයක් වේගවත් ක්‍රියාත්මක වන අතර, අඩු මතක සම්පත් භාවිතා කරයි."
    },
    // 9.1 ගැටලු විසඳීමේ ක්‍රියාවලිය (Problem Solving Process)
    {
        questionText: "සංකීර්ණ ගැටලුවක් විසඳීමේදී, 'ගැටලුව හඳුනා ගැනීම' යන පියවරේදී මූලික වශයෙන් සිදුවන්නේ කුමක්ද?",
        options: [
            "ගැටලුවේ මූලික හේතු සහ ඒවායේ බලපෑම් විශ්ලේෂණය කිරීම.",
            "ගැටලුවට අදාළව දැනට පවතින විසඳුම් ක්‍රම අධ්‍යයනය කිරීම.",
            "විසඳුමක් ක්‍රියාත්මක කිරීමට අවශ්‍ය තාක්ෂණික සම්පත් හඳුනා ගැනීම.",
            "ගැටලුව විසඳීම සඳහා කාලරාමුවක් සහ අයවැයක් සකස් කිරීම.",
            "ගැටලුවේ තීව්‍රතාවය සහ එහි බලපෑම තක්සේරු කිරීම සඳහා දත්ත රැස් කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "ගැටලු විසඳීමේ ක්‍රියාවලියේ පළමු පියවර වන 'ගැටලුව හඳුනා ගැනීම' යටතේ සිදුවන්නේ ගැටලුවේ මූලික හේතු (root causes) සහ ඒවායේ සමස්ත බලපෑම් නිවැරදිව විශ්ලේෂණය කර තේරුම් ගැනීමයි. මෙය ගැටලුවට නිවැරදි විසඳුම් සැලසුම් කිරීමට පදනම සපයයි. අනෙක් විකල්ප ඊට පසු පියවර වලට හෝ ගැටලුව අර්ථ දැක්වීමට අදාළ වේ."
    },
    {
        questionText: "ගැටලුවක් විසඳීමේ ක්‍රියාවලියේදී, 'විසඳුම සැලසුම් කිරීම' යන පියවරේදී වඩාත් වැදගත් වන්නේ කුමක්ද?",
        options: [
            "සැලසුම් කළ විසඳුමේ කාර්යක්ෂමතාවය පරීක්ෂා කිරීම.",
            "විසඳුම ක්‍රියාත්මක කිරීමට අවශ්‍ය ක්‍රමලේඛ භාෂාව තෝරා ගැනීම.",
            "ගැටලුව විසඳීම සඳහා පියවරෙන් පියවර ඇල්ගොරිතමයක් හෝ සැලැස්මක් සකස් කිරීම.",
            "අවසාන විසඳුමේ පරිශීලක අතුරුමුහුණත නිර්මාණය කිරීම.",
            "ගැටලුවට අදාළ දත්ත ගබඩා කිරීමේ ක්‍රමවේද තීරණය කිරීම."
        ],
        correctAnswerIndex: 2,
        explanation: "'විසඳුම සැලසුම් කිරීම' යනු ගැටලුවට පිළිතුරු සැපයීම සඳහා පියවරෙන් පියවර වූ ක්‍රමවේදයක් (ඇල්ගොරිතමයක්) හෝ විස්තරාත්මක සැලැස්මක් නිර්මාණය කරන අවධියයි. මෙහිදී ගැලීම් සටහන් හෝ ව්‍යාජ කේත වැනි උපකරණ භාවිත කර විසඳුමේ තර්කය (logic) පැහැදිලිව ගොඩනගයි. අනෙක් විකල්ප සැලසුම් කිරීමෙන් පසු හෝ ක්‍රියාත්මක කිරීමේදී සිදුවන දේ වේ."
    },
    {
        questionText: "පහත සඳහන් ප්‍රකාශයන්ගෙන්, ගැටලු විසඳීමේ ක්‍රියාවලියේ 'සීමාවන් අර්ථ දැක්වීම' සඳහා වඩාත් නිවැරදිව අදාළ වන්නේ කුමක්ද?",
        options: [
            "ගැටලුව විසඳීමට ගතවන කාලය සහ පිරිවැය ඇස්තමේන්තු කිරීම.",
            "විසඳුම ක්‍රියාත්මක කළ හැකි තාක්ෂණික වේදිකා හඳුනා ගැනීම.",
            "ගැටලුවට බලපාන බාහිර සාධක සහ විසඳුම ක්‍රියාත්මක කිරීමේදී ඇතිවිය හැකි අවහිරතා හඳුනා ගැනීම.",
            "ගැටලුවට බලපාන සියලුම පාර්ශවකරුවන් ලැයිස්තුගත කිරීම.",
            "විසඳුමෙහි අපේක්ෂිත ප්‍රතිඵල සහ සාර්ථකත්ව මිනුම් තීරණය කිරීම."
        ],
        correctAnswerIndex: 2,
        explanation: "ගැටලුව හා එහි සීමාවන් අර්ථ දැක්වීමේදී, ගැටලුව විසඳීම සඳහා පවතින සීමාවන් (උදා: තාක්ෂණික සීමා, කාල සීමා, අයවැය සීමා, මානව සම්පත් සීමා) සහ විසඳුම ක්‍රියාත්මක කිරීමේදී ඇතිවිය හැකි අවහිරතා හඳුනා ගැනීම අත්‍යවශ්‍ය වේ. මෙය විසඳුමේ යථාර්ථවාදීභාවය සහ ශක්‍යතාව තීරණය කිරීමට උපකාරී වේ."
    },
    {
        questionText: "ගැටලු විසඳීමේ ක්‍රියාවලියේදී, 'විසඳුම ක්‍රියාත්මක කිරීම' යන පියවරෙන් අපේක්ෂා කරන්නේ කුමක්ද?",
        options: [
            "සැලසුම් කළ විසඳුම පරිගණක ක්‍රමලේඛයක් බවට පත් කිරීම.",
            "ගැටලුවට අදාළ සියලු තොරතුරු එකතු කිරීම.",
            "ගැටලුවට විවිධ විකල්ප විසඳුම් සොයා බැලීම.",
            "ක්‍රියාත්මක කළ විසඳුමේ පරිශීලක පුහුණුව ලබා දීම.",
            "සැලසුම් කළ විසඳුම සමාලෝචනය කර යාවත්කාලීන කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "'විසඳුම ක්‍රියාත්මක කිරීම' යනු සැලසුම් කළ ඇල්ගොරිතම හෝ සැලැස්ම සැබෑ ලෝකයේ භාවිත කළ හැකි ආකාරයේ පරිගණක ක්‍රමලේඛයක් (code) බවට පරිවර්තනය කිරීමයි. මෙහිදී තෝරාගත් ක්‍රමලේඛ භාෂාවක් භාවිත කර කේතීකරණය සිදු කරයි."
    },

    // 9.2 ගැටලු විසඳීම සඳහා ඉහළ පහළ පියවරාකාර ක්‍රමවේදය (Top-Down Stepwise Refinement)
    {
        questionText: "ඉහළ පහළ පියවරාකාර ක්‍රමවේදයේදී (Top-Down Stepwise Refinement) 'මොඩියුලකරණය' (Modularization) මගින් ප්‍රධාන වශයෙන් සිදුකරන්නේ කුමක්ද?",
        options: [
            "පද්ධතියේ සෑම කොටසක්ම ස්වාධීනව ක්‍රියාත්මක වන බව තහවුරු කිරීම.",
            "විසඳුමේ සියලුම දත්ත එකම ස්ථානයක ගබඩා කිරීම.",
            "සංකීර්ණ ගැටලුවක් කුඩා, කළමනාකරණය කළ හැකි උප-ගැටලු හෝ කොටස් වලට බෙදීම.",
            "ක්‍රමලේඛනයේදී භාවිතා කරන විචල්‍යයන් වර්ගීකරණය කිරීම.",
            "ගැටලුවේ තර්කය සරල ගැලීම් සටහන් මගින් නිරූපණය කිරීම."
        ],
        correctAnswerIndex: 2,
        explanation: "මොඩියුලකරණය යනු සංකීර්ණ පද්ධතියක් හෝ ගැටලුවක් කුඩා, ස්වාධීන සහ කළමනාකරණය කළ හැකි මොඩියුල (sub-problems or modules) වලට බෙදීමයි. මෙය ගැටලුව තේරුම් ගැනීම, සැලසුම් කිරීම සහ ක්‍රියාත්මක කිරීම පහසු කරයි, එමෙන්ම නඩත්තු කිරීම සහ දෝෂ නිවැරදි කිරීම ද සරල කරයි."
    },
    {
        questionText: "ඉහළ සිට පහළ සැලසුම (Top-Down Design) මගින් සංකීර්ණ ගැටලු විසඳීමේදී ලැබෙන ප්‍රධාන වාසිය කුමක්ද?",
        options: [
            "ක්‍රමලේඛයේ සෑම පේළියක්ම ස්වයංක්‍රීයව දෝෂ රහිත බව සහතික කිරීම.",
            "විසඳුම ක්‍රියාත්මක කිරීමට අවශ්‍ය අඩුම සම්පත් ප්‍රමාණය තීරණය කිරීම.",
            "ගැටලුවේ සමස්ත ව්‍යුහය පළමුව තේරුම් ගෙන, පසුව කුඩා කොටස් විස්තරාත්මකව විසඳීම.",
            "විවිධ ක්‍රමලේඛ භාෂා එකම මොඩියුලයක් තුළ භාවිතා කිරීමට ඉඩ සැලසීම.",
            "ක්‍රමලේඛ සංවර්ධනය සඳහා අවශ්‍ය වන කණ්ඩායම් සාමාජික සංඛ්‍යාව අවම කිරීම."
        ],
        correctAnswerIndex: 2,
        explanation: "ඉහළ සිට පහළ සැලසුමේ ප්‍රධාන වාසිය වන්නේ, මුලින්ම ගැටලුවේ පුළුල් දළ සටහන හෝ සමස්ත ව්‍යුහය තේරුම් ගැනීමයි. පසුව, එම දළ සටහන ක්‍රමයෙන් පිරිපහදු කරමින් (stepwise refinement) එක් එක් කුඩා කොටස (sub-problem) විස්තරාත්මකව විසඳීම සිදු කරයි. මෙය සංකීර්ණත්වය අඩු කර ගැටලුව පිළිබඳ පැහැදිලි දැක්මක් ලබා දෙයි."
    },
    {
        questionText: "ව්‍යුහ සටහනක (Structure Chart) මූලික අරමුණ කුමක්ද?",
        options: [
            "ක්‍රමලේඛයක කේත පේළි ගණන නිරූපණය කිරීම.",
            "ඇල්ගොරිතමයක තර්කනය සහ පාලන ප්‍රවාහය (control flow) පෙන්වීම.",
            "පද්ධතියක දත්ත ගබඩා කිරීමේ ක්‍රමවේද පැහැදිලි කිරීම.",
            "මොඩියුල අතර ඇති ධුරාවලිය (hierarchy) සහ දත්ත ප්‍රවාහය (data flow) නිරූපණය කිරීම.",
            "ක්‍රමලේඛයක දෝෂ නිවැරදි කිරීමේ පියවර සටහන් කිරීම."
        ],
        correctAnswerIndex: 3,
        explanation: "ව්‍යුහ සටහන් (Structure Charts) භාවිත කරන්නේ පද්ධතියක මොඩියුල අතර ඇති ධුරාවලිය (එනම්, කුමන මොඩියුලය කුමන මොඩියුලය කැඳවන්නේද) සහ එම මොඩියුල අතර දත්ත හුවමාරු වන ආකාරය (data flow) පැහැදිලිව නිරූපණය කිරීමටයි. මෙය මොඩියුලරණය කළ පද්ධතියක සමස්ත ව්‍යුහය තේරුම් ගැනීමට ඉතා ප්‍රයෝජනවත් වේ."
    },
    {
        questionText: "පියවරාකාර පිරිපහදු (Stepwise Refinement) ක්‍රමවේදයේදී, සෑම පියවරකදීම සිදු කළ යුත්තේ කුමක්ද?",
        options: [
            "අලුතින් මොඩියුල නිර්මාණය කිරීමෙන් වැළකී සිටීම.",
            "විසඳුමෙහි සංකීර්ණත්වය වැඩි කිරීම.",
            "දැනට පවතින ගැටලුවෙහි එක් කොටසක් පමණක් සම්පූර්ණයෙන්ම විසඳීම.",
            "විශාල ගැටලුවක් හෝ මොඩියුලයක් ක්‍රමයෙන් කුඩා, වඩාත් විස්තරාත්මක උප-කාර්යයන් වලට බෙදීම.",
            "අවසාන කේතය ලියන තුරු කිසිදු පරීක්ෂණයක් නොකිරීම."
        ],
        correctAnswerIndex: 3,
        explanation: "පියවරාකාර පිරිපහදු ක්‍රමවේදයේදී, විශාල ගැටලුවක් හෝ මොඩියුලයක්, ක්‍රමයෙන් කුඩා, වඩාත් නිශ්චිත සහ කළමනාකරණය කළ හැකි උප-කාර්යයන් (sub-tasks) වලට බෙදා වෙන් කරනු ලැබේ. මෙම ක්‍රියාවලිය නැවත නැවතත් සිදු කරනු ලබන්නේ විසඳුම අවසන් විස්තරාත්මක මට්ටමකට ළඟා වන තුරුය."
    },

    // 9.3 ගැටලු විසඳීම සඳහා ඇල්ගෝරිතමික ප්‍රවේශය (Algorithmic Approach)
    {
        questionText: "ඇල්ගොරිතමයක් (Algorithm) පිළිබඳ පහත සඳහන් ප්‍රකාශයන්ගෙන්, වඩාත් නිවැරදි ප්‍රකාශය කුමක්ද?",
        options: [
            "එය සැමවිටම පරිගණක භාෂාවකින් ලියා තිබිය යුතුය.",
            "එය නිශ්චිත ගැටලුවක් විසඳීම සඳහා පියවරෙන් පියවර වූ පැහැදිලි සහ නිශ්චිත උපදෙස් මාලාවකි.",
            "එය ගැටලුවක දත්ත ගබඩා කිරීමේ ක්‍රමවේදය පමණක් විස්තර කරයි.",
            "එය අනිවාර්යයෙන්ම ගැලීම් සටහනක් ලෙස නිරූපණය කළ යුතුය.",
            "එය කිසිදු දෝෂයකින් තොරව ක්‍රියාත්මක වන බවට සහතිකයක් සපයයි."
        ],
        correctAnswerIndex: 1,
        explanation: "ඇල්ගොරිතමයක් යනු යම්කිසි ගැටලුවක් විසඳීම සඳහා පියවරෙන් පියවර වූ, පැහැදිලි, නිශ්චිත සහ සීමිත කාලයක් තුළ අවසන් වන උපදෙස් මාලාවකි. එය පරිගණක භාෂාවක් මත රඳා නොපවතින අතර, ගැලීම් සටහන් හෝ ව්‍යාජ කේත වැනි විවිධ ක්‍රම මගින් නිරූපණය කළ හැක."
    },
    {
        questionText: "ගැලීම් සටහනක (Flow Chart) 'ක්‍රියාවලිය' (Process) සංකේතය (ආයත චතුරස්‍රය) නිරූපණය කරන්නේ කුමක්ද?",
        options: [
            "ආදාන හෝ ප්‍රතිදාන මෙහෙයුම්.",
            "කොන්දේසි සහිත තීරණයක් (conditional decision).",
            "ක්‍රමලේඛයක ආරම්භය හෝ අවසානය.",
            "ගණනය කිරීම් හෝ දත්ත සැකසීම වැනි මෙහෙයුම්.",
            "වෙනත් ගැලීම් සටහනකට යොමු කිරීමක්."
        ],
        correctAnswerIndex: 3,
        explanation: "ගැලීම් සටහනක ආයත චතුරස්‍රය (rectangle) 'ක්‍රියාවලියක්' නිරූපණය කරයි. මෙය ගණනය කිරීම්, දත්ත සැකසීම, විචල්‍යයකට අගයක් පැවරීම වැනි යම්කිසි ක්‍රියාවක් හෝ මෙහෙයුමක් පෙන්නුම් කරයි."
    },
    {
        questionText: "ව්‍යාජ කේත (Pseudo Code) භාවිත කිරීමේ ප්‍රධාන වාසිය කුමක්ද?",
        options: [
            "එය සෘජුවම පරිගණකයක ක්‍රියාත්මක කළ හැකි වීම.",
            "එය ක්‍රමලේඛ භාෂාවක නීති රීතිවලට අනුකූලව ලිවිය යුතු වීම.",
            "එය මිනිසුන්ට පහසුවෙන් තේරුම් ගැනීමට හැකි වන පරිදි ඇල්ගොරිතමයක තර්කය සරල බසින් ඉදිරිපත් කිරීම.",
            "එය ගැලීම් සටහන් ඇඳීමට වඩා අඩු කාලයක් ගතවීම.",
            "එය ස්වයංක්‍රීයව දෝෂ හඳුනා ගැනීම."
        ],
        correctAnswerIndex: 2,
        explanation: "ව්‍යාජ කේත (Pseudo Code) යනු කිසියම් ක්‍රමලේඛ භාෂාවක වාක්‍ය රීතිවලට (syntax) බැඳී නොසිට, මිනිසුන්ට පහසුවෙන් තේරුම් ගත හැකි සරල බසකින් ඇල්ගොරිතමයක තර්කය (logic) ඉදිරිපත් කරන ක්‍රමයකි. මෙය ඇල්ගොරිතමයක් සැලසුම් කිරීමේ සහ සන්නිවේදනය කිරීමේදී ඉතා ප්‍රයෝජනවත් වේ."
    },
    {
        questionText: "ගැලීම් සටහනක 'තීරණය' (Decision) සංකේතය (සමචතුරශ්‍රය) නිරූපණය කරන්නේ කුමක්ද?",
        options: [
            "දත්ත ආදානය.",
            "පද්ධතියේ ආරම්භක ලක්ෂ්‍යය.",
            "කොන්දේසියක් පරීක්ෂා කිරීමෙන් පසුව විවිධ මාර්ග ඔස්සේ තර්කය ඉදිරියට ගෙන යාම.",
            "පද්ධතියේ ප්‍රතිදානය.",
            "වෙනත් ගැලීම් සටහනකට යොමු කිරීම."
        ],
        correctAnswerIndex: 2,
        explanation: "ගැලීම් සටහනක දියමන්ති හැඩැති 'තීරණ' සංකේතය මගින් කොන්දේසියක් (condition) පරීක්ෂා කිරීමක් නිරූපණය කරයි. මෙම කොන්දේසිය සත්‍ය හෝ අසත්‍ය විය හැකි අතර, එය අනුව ගැලීම් සටහනේ ප්‍රවාහය විවිධ මාර්ග ඔස්සේ ඉදිරියට ගමන් කරයි."
    },
    {
        questionText: "ඇල්ගොරිතමයක් සැලසුම් කිරීමෙන් පසු 'හස්තානුලේඛන' (Hand Traces) සටහන් ඇඳීමේ ප්‍රධාන අරමුණ කුමක්ද?",
        options: [
            "ඇල්ගොරිතමයේ කේතය ක්‍රමලේඛ භාෂාවකට පරිවර්තනය කිරීම.",
            "ඇල්ගොරිතමයේ ක්‍රියාකාරීත්වය පරිගණකයක් නොමැතිව පියවරෙන් පියවර අතින් පරීක්ෂා කිරීමෙන් එහි තර්කනයේ (logic) නිවැරදිභාවය තහවුරු කර ගැනීම.",
            "ඇල්ගොරිතමයක් ලිවීමට අවශ්‍ය කාලය ඇස්තමේන්තු කිරීම.",
            "ඇල්ගොරිතමයේ කාර්යක්ෂමතාවය මැන බැලීම.",
            "ඇල්ගොරිතමයේ සංකීර්ණතාවය තක්සේරු කිරීම."
        ],
        correctAnswerIndex: 1,
        explanation: "හස්තානුලේඛන (Hand Traces) යනු ඇල්ගොරිතමයක් සැබෑ දත්ත කට්ටලයක් සමඟ අතින් පියවරෙන් පියවර ක්‍රියාත්මක කර, විචල්‍යයන්ගේ අගයන් වෙනස් වන ආකාරය නිරීක්ෂණය කරමින් එහි තර්කනයේ (logic) නිවැරදිභාවය සහ අපේක්ෂිත ප්‍රතිඵල ලැබේදැයි තහවුරු කර ගැනීමයි. මෙය ක්‍රමලේඛනයට පෙර දෝෂ හඳුනා ගැනීමට උපකාරී වේ."
    },
    {
        questionText: "පහත ව්‍යාජ කේත කොටසෙහි ප්‍රතිඵලය කුමක්ද? \n\n```\nSTART\n  SET X = 5\n  SET Y = 10\n  IF X > Y THEN\n    PRINT 'X is greater'\n  ELSE\n    PRINT 'Y is greater'\n  END IF\nEND\n```",
        options: [
            "X is greater",
            "Y is greater",
            "දෝෂයක් (Error)",
            "කිසිවක් මුද්‍රණය නොවේ (Nothing printed)",
            "X is greater, Y is greater"
        ],
        correctAnswerIndex: 1,
        explanation: "මෙහිදී X හි අගය 5 වන අතර Y හි අගය 10 වේ. X > Y (5 > 10) යන කොන්දේසිය අසත්‍ය වේ. එබැවින් ELSE කොටස ක්‍රියාත්මක වන අතර 'Y is greater' ලෙස මුද්‍රණය වේ."
    },

    // 9.4 ක්‍රමලේඛනය කිරීමේ විවිධ සුසමාදර්ශ (Programming Paradigms)
    {
        questionText: "ක්‍රමලේඛන සුසමාදර්ශයන් (Programming Paradigms) අතරින්, 'ආඥාත්මක' (Imperative) භාෂාවකට අයත් නොවන ලක්ෂණය කුමක්ද?",
        options: [
            "ක්‍රමලේඛය මගින් 'කෙසේද' (how) යන්න පිළිබඳව පැහැදිලි පියවර අනුපිළිවෙලක් අඩංගු වීම.",
            "පද්ධතියේ තත්වය (state) වෙනස් කිරීම සඳහා විචල්‍යයන් (variables) සහ පැවරුම් ප්‍රකාශ (assignment statements) බහුලව භාවිතා කිරීම.",
            "ක්‍රමලේඛය බොහෝ දුරට 'කුමක්ද' (what) යන්න ප්‍රකාශ කිරීම කෙරෙහි අවධානය යොමු කිරීම.",
            "ලූප් (loops) සහ කොන්දේසි ප්‍රකාශ (conditional statements) වැනි පාලන ව්‍යුහයන් (control structures) භාවිතය.",
            "ක්‍රමලේඛය යනු පරිගණකයට දිය යුතු විධානයන්ගේ (commands) අනුපිළිවෙලක් ලෙස සැලකීම."
        ],
        correctAnswerIndex: 2,
        explanation: "ආඥාත්මක (Imperative) භාෂා මගින් පරිගණකයට 'කෙසේද' (how) යන්න පිළිබඳව පැහැදිලි, පියවරෙන් පියවර විධානයන් (commands) ලබා දීම කෙරෙහි අවධානය යොමු කරයි. 'කුමක්ද' (what) යන්න ප්‍රකාශ කිරීම ප්‍රකාශාත්මක (Declarative) භාෂාවල ලක්ෂණයකි."
    },
    {
        questionText: "වස්තු නැඹුරු ක්‍රමලේඛන සුසමාදර්ශය (Object-Oriented Programming Paradigm) මගින් සංකීර්ණ පද්ධති සංවර්ධනයට දායක වන්නේ කෙසේද?",
        options: [
            "ක්‍රමලේඛයේ සෑම පේළියක්ම ස්වාධීන කාර්යයක් ලෙස සැලකීමෙන්.",
            "ක්‍රමලේඛකයින්ට දත්ත සහ ඒවා මත ක්‍රියා කරන කාර්යයන් (functions) එකට කාණ්ඩගත කර 'වස්තු' (objects) ලෙස නිර්මාණය කිරීමට ඉඩ දීමෙන්.",
            "ක්‍රමලේඛනය සඳහා භාවිතා කළ යුතු දත්ත වර්ග ප්‍රමාණය අවම කිරීමෙන්.",
            "සියලුම කේතයන් එක් ගොනුවක් තුළ තබා ගැනීමෙන් සංකීර්ණත්වය අඩු කිරීමෙන්.",
            "දත්ත ගබඩා කිරීමේදී ස්වයංක්‍රීයව දෝෂ නිවැරදි කිරීමේ හැකියාව ලබා දීමෙන්."
        ],
        correctAnswerIndex: 1,
        explanation: "වස්තු නැඹුරු ක්‍රමලේඛනයේදී (OOP), දත්ත (data) සහ එම දත්ත මත ක්‍රියා කරන ක්‍රමවේදයන් (methods/functions) 'වස්තු' (objects) ලෙස එකට කාණ්ඩගත කරයි. මෙය සංකීර්ණ පද්ධති මොඩියුලකරණය කිරීමට, කේතය නැවත භාවිත කිරීමට (reusability) සහ පද්ධතියේ නඩත්තුව (maintainability) වැඩි දියුණු කිරීමට උපකාරී වේ."
    },
    {
        questionText: "පරිගණක භාෂාවන්ගේ පරිණාමය සැලකීමේදී 'දෙවන පරම්පරාවේ භාෂා' (Second Generation Languages - 2GL) වල ප්‍රධාන ලක්ෂණය කුමක්ද?",
        options: [
            "මේවා යන්ත්‍ර කේත (Machine Code) භාවිතයෙන් කෙලින්ම පරිගණකයට විධාන ලබා දීම.",
            "මේවා මිනිසාට කියවිය හැකි ස්වාභාවික භාෂාවන්ට සමීප වීම.",
            "මෙය 'ඇසෙම්බ්ලි භාෂා' (Assembly Languages) ලෙස හඳුන්වන අතර, යන්ත්‍ර කේත සඳහා සංකේතාත්මක නිරූපණ (symbolic representations) භාවිත කිරීම.",
            "මේවා තවදුරටත් පරිවර්තනය කිරීමකින් තොරව ක්‍රියාත්මක කළ හැකි වීම.",
            "මේවා වස්තු නැඹුරු (Object-Oriented) ක්‍රමලේඛන සංකල්ප හඳුන්වා දීම."
        ],
        correctAnswerIndex: 2,
        explanation: "දෙවන පරම්පරාවේ භාෂා (2GL) ප්‍රධාන වශයෙන් 'ඇසෙම්බ්ලි භාෂා' (Assembly Languages) වේ. මේවා යන්ත්‍ර කේතවල ද්විමය උපදෙස් සඳහා (binary instructions) mnemonic codes වැනි සංකේතාත්මක නිරූපණ (symbolic representations) භාවිතා කරන අතර, 'ඇසෙම්බලර්' (Assembler) නම් පරිවර්තකයක් මගින් යන්ත්‍ර කේත බවට පරිවර්තනය වේ."
    },
    {
        questionText: "ප්‍රකාශාත්මක ක්‍රමලේඛන සුසමාදර්ශය (Declarative Programming Paradigm) ආඥාත්මක සුසමාදර්ශයෙන් (Imperative Paradigm) වෙනස් වන්නේ කෙසේද?",
        options: [
            "ප්‍රකාශාත්මක භාෂා 'කෙසේද' (how) යන්න විස්තර කරන අතර, ආඥාත්මක භාෂා 'කුමක්ද' (what) යන්න විස්තර කරයි.",
            "ප්‍රකාශාත්මක භාෂා දත්ත ව්‍යුහයන් මත පමණක් අවධානය යොමු කරන අතර, ආඥාත්මක භාෂා ක්‍රියාවලීන් මත අවධානය යොමු කරයි.",
            "ප්‍රකාශාත්මක භාෂා 'කුමක්ද' (what) යන්න ප්‍රකාශ කරන අතර, ආඥාත්මක භාෂා 'කෙසේද' (how) යන්න ප්‍රකාශ කරයි.",
            "ප්‍රකාශාත්මක භාෂා වස්තු නැඹුරු සංකල්ප භාවිත කරන අතර, ආඥාත්මක භාෂා ඒවා භාවිත නොකරයි.",
            "ප්‍රකාශාත්මක භාෂා සම්පාදක (compilers) භාවිත කරන අතර, ආඥාත්මක භාෂා අර්ථනාසක (interpreters) පමණක් භාවිත කරයි."
        ],
        correctAnswerIndex: 2,
        explanation: "ප්‍රකාශාත්මක (Declarative) ක්‍රමලේඛනයේදී ක්‍රමලේඛකයා අවධානය යොමු කරන්නේ 'කුමක්ද' (what) යන ප්‍රතිඵලය ලබා ගත යුතුද යන්න මතයි. එය එම ප්‍රතිඵලය ලබා ගන්නා 'කෙසේද' (how) යන පියවරයන් විස්තර නොකරයි. ආඥාත්මක (Imperative) ක්‍රමලේඛනයේදී 'කෙසේද' යන්න පැහැදිලිව විධානයන් ලෙස ලබා දේ."
    },

    // 9.5 ක්‍රමලේඛ පරිවර්තනය කිරීමේ අවශ්‍යතාව සහ ක්‍රමලේඛ පරිවර්තක වර්ග (Program Translation)
    {
        questionText: "ප්‍රභව ක්‍රමලේඛයක් (Source Program) වස්තු ක්‍රමලේඛයක් (Object Program) බවට පරිවර්තනය කිරීමේ මූලික අවශ්‍යතාව කුමක්ද?",
        options: [
            "මිනිසාට පහසුවෙන් තේරුම් ගත හැකි කේතයක් නිර්මාණය කිරීම.",
            "පරිගණක දෘඩාංග මගින් සෘජුවම ක්‍රියාත්මක කළ හැකි ආකෘතියකට කේතය පත් කිරීම.",
            "ක්‍රමලේඛයේ දෝෂ ස්වයංක්‍රීයව නිවැරදි කිරීම.",
            "ක්‍රමලේඛයේ ගබඩා කිරීමේ ඉඩ ප්‍රමාණය අඩු කිරීම.",
            "ක්‍රමලේඛය විවිධ මෙහෙයුම් පද්ධති මත ක්‍රියාත්මක කිරීමේ හැකියාව වැඩි කිරීම."
        ],
        correctAnswerIndex: 1,
        explanation: "ප්‍රභව ක්‍රමලේඛය (උදා: Python කේතය) මිනිසාට තේරුම් ගත හැකි නමුත්, පරිගණකයේ මධ්‍යම සැකසුම් ඒකකයට (CPU) එය සෘජුවම තේරුම් ගත නොහැක. එබැවින්, එය පරිගණකයට තේරුම් ගත හැකි යන්ත්‍ර කේත (Machine Code) වලින් සමන්විත වස්තු ක්‍රමලේඛයක් බවට පරිවර්තනය කිරීම අත්‍යවශ්‍ය වේ. මෙය පරිගණක දෘඩාංග මගින් සෘජුවම ක්‍රියාත්මක කළ හැකි එකම ආකෘතියයි."
    },
    {
        questionText: "අර්ථනාසකයක් (Interpreter) සහ සම්පාදකයක් (Compiler) අතර ඇති ප්‍රධාන වෙනස කුමක්ද?",
        options: [
            "අර්ථනාසකය දත්ත ගබඩා කිරීමට භාවිතා කරන අතර, සම්පාදකය දත්ත සැකසීමට භාවිතා කරයි.",
            "අර්ථනාසකය සම්පූර්ණ ප්‍රභව කේතයම එකවර පරිවර්තනය කරන අතර, සම්පාදකය කේතය පේළියෙන් පේළියට ක්‍රියාත්මක කරයි.",
            "අර්ථනාසකය ප්‍රභව කේතය කෙලින්ම යන්ත්‍ර කේත බවට පරිවර්තනය කරන අතර, සම්පාදකය අතරමැදි කේතයක් ජනනය කරයි.",
            "අර්ථනාසකය ප්‍රභව කේතය පේළියෙන් පේළියට ක්‍රියාත්මක කරන අතර, සම්පාදකය සම්පූර්ණ ප්‍රභව කේතයම එකවර යන්ත්‍ර කේත බවට පරිවර්තනය කරයි.",
            "අර්ථනාසකය දෝෂ වාර්තා නොකරන අතර, සම්පාදකය දෝෂ වාර්තා කරයි."
        ],
        correctAnswerIndex: 3,
        explanation: "සම්පාදකයක් (Compiler) සම්පූර්ණ ප්‍රභව කේතයම එකවර යන්ත්‍ර කේත බවට පරිවර්තනය කර, වස්තු ක්‍රමලේඛයක් (Object Program) සාදයි. අර්ථනාසකයක් (Interpreter) ප්‍රභව කේතය පේළියෙන් පේළියට කියවමින්, එය ක්‍රියාත්මක කරන අවස්ථාවේදීම පරිවර්තනය කරයි. මේ නිසා අර්ථනාසකවලින් ක්‍රියාත්මක වන වැඩසටහන් සාමාන්‍යයෙන් සම්පාදකයකින් ක්‍රියාත්මක වන වැඩසටහන් වලට වඩා සෙමෙන් ක්‍රියා කරයි."
    },
    {
        questionText: "පරිගණක ක්‍රමලේඛ සංවර්ධනයේදී 'සන්ධාරකයක' (Linker) කාර්යභාරය කුමක්ද?",
        options: [
            "ප්‍රභව කේතයේ ඇති වාක්‍ය දෝෂ (syntax errors) හඳුනා ගැනීම.",
            "විවිධ මොඩියුල වලින් සම්පාදනය කරන ලද වස්තු කේත (object code) කොටස් එකට සම්බන්ධ කර ක්‍රියාත්මක කළ හැකි වැඩසටහනක් (executable program) නිර්මාණය කිරීම.",
            "ක්‍රමලේඛය ක්‍රියාත්මක කිරීමට අවශ්‍ය දත්ත ගොනු නිර්මාණය කිරීම.",
            "ක්‍රමලේඛයේ ප්‍රතිදානය පරිශීලකයාට පෙන්වීම.",
            "වස්තු ක්‍රමලේඛය නැවත ප්‍රභව කේතයක් බවට පරිවර්තනය කිරීම."
        ],
        correctAnswerIndex: 1,
        explanation: "සන්ධාරකයක් (Linker) යනු සම්පාදනය කරන ලද විවිධ වස්තු කේත (object code) මොඩියුල සහ පුස්තකාල (libraries) එකට සම්බන්ධ කර, පරිගණකයට කෙලින්ම ක්‍රියාත්මක කළ හැකි තනි වැඩසටහනක් (executable program) නිර්මාණය කරන මෘදුකාංගයකි. මෙය විශාල ක්‍රමලේඛ සංවර්ධනයේදී අත්‍යවශ්‍ය වේ."
    },
    {
        questionText: "හයිබ්‍රිඩ් ප්‍රවේශය (Hybrid Approach) මගින් ක්‍රමලේඛ පරිවර්තනයේදී ලැබෙන ප්‍රධාන වාසිය කුමක්ද?",
        options: [
            "එය සම්පූර්ණයෙන්ම දෝෂ රහිත කේතයක් ජනනය කරයි.",
            "එය සම්පාදකයක වේගය සහ අර්ථනාසකයක නම්‍යශීලී බව ඒකාබද්ධ කරයි.",
            "එය ක්‍රමලේඛය ක්‍රියාත්මක කිරීමට පෙර කිසිදු පරිවර්තනයක් අවශ්‍ය නොවේ.",
            "එය ක්‍රමලේඛයේ ගබඩා කිරීමේ ඉඩ ප්‍රමාණය සැලකිය යුතු ලෙස අඩු කරයි.",
            "එය පරිගණක භාෂා පරම්පරා සියල්ලටම පොදු පරිවර්තන ක්‍රමයකි."
        ],
        correctAnswerIndex: 1,
        explanation: "හයිබ්‍රිඩ් ප්‍රවේශය (Hybrid Approach) යනු සම්පාදනය (compilation) සහ අර්ථනාසනය (interpretation) යන ක්‍රම දෙකෙහිම වාසි ලබා ගැනීම සඳහා ඒවා ඒකාබද්ධ කරන ක්‍රමයකි. මෙහිදී, ප්‍රභව කේතය අතරමැදි කේතයක් (intermediate code) බවට සම්පාදනය කරන අතර, පසුව එම අතරමැදි කේතය අර්ථනාසකයක් මගින් ක්‍රියාත්මක කරයි. මෙය සම්පාදකයක කාර්යක්ෂමතාවයත්, අර්ථනාසකයක නිදොස් කිරීමේ පහසුවත් ඒකාබද්ධ කරයි."
    },

    // 9.6 සමෝධානික සංවර්ධන පරිසරයේ (IDE) මූලික ලක්ෂණ (IDE Features)
    {
        questionText: "සමෝධානික සංවර්ධන පරිසරයක (IDE - Integrated Development Environment) මූලික ලක්ෂණයක් වන 'කේත සම්පූර්ණ කිරීමේ' (Code Completion) පහසුකමෙහි ප්‍රධාන අරමුණ කුමක්ද?",
        options: [
            "ස්වයංක්‍රීයව දෝෂ නිවැරදි කිරීම.",
            "ක්‍රමලේඛ සංවර්ධනය වේගවත් කිරීම සඳහා කේත ලිවීමේදී යෝජනා සහ ස්වයංක්‍රීයව අදාළ කේත කොටස් සම්පූර්ණ කිරීම.",
            "ක්‍රමලේඛයේ කාර්යක්ෂමතාවය ස්වයංක්‍රීයව විශ්ලේෂණය කිරීම.",
            "ක්‍රමලේඛය සුරැකීමේදී ස්වයංක්‍රීයව පිටපත් නිර්මාණය කිරීම.",
            "ක්‍රමලේඛය ක්‍රියාත්මක කිරීමට පෙර පරිශීලක අතුරුමුහුණත නිර්මාණය කිරීම."
        ],
        correctAnswerIndex: 1,
        explanation: "කේත සම්පූර්ණ කිරීමේ (Code Completion) පහසුකම IDEs හි ප්‍රධාන ලක්ෂණයකි. මෙය කේතය ලියන අතරතුර, ක්‍රමලේඛ භාෂාවේ වාක්‍ය රීති (syntax) සහ පෙර අර්ථ දක්වා ඇති නාමයන් (identifiers) මත පදනම්ව, යෝජනා ඉදිරිපත් කරමින් හෝ අදාළ කේත කොටස් ස්වයංක්‍රීයව සම්පූර්ණ කරමින් කේත ලිවීමේ ක්‍රියාවලිය වේගවත් කරයි. මෙය ක්‍රමලේඛකයාගේ කාලය ඉතිරි කරන අතර දෝෂ අවම කරයි."
    },
    {
        questionText: "IDE එකක 'නිදොස් කිරීමේ' (Debugging) පහසුකමෙහි ප්‍රයෝජනය කුමක්ද?",
        options: [
            "ක්‍රමලේඛය ස්වයංක්‍රීයව සම්පාදනය කිරීම.",
            "ක්‍රමලේඛය ක්‍රියාත්මක කිරීමට අවශ්‍ය පුස්තකාල (libraries) ස්වයංක්‍රීයව සම්බන්ධ කිරීම.",
            "ක්‍රමලේඛයක් ක්‍රියාත්මක වන අතරතුර, එහි දෝෂ හඳුනා ගැනීමට, විචල්‍යයන්ගේ අගයන් පරීක්ෂා කිරීමට සහ ක්‍රියාත්මක කිරීම පාලනය කිරීමට.",
            "ක්‍රමලේඛයේ ප්‍රභව කේතය වෙනත් භාෂාවකට පරිවර්තනය කිරීම.",
            "ක්‍රමලේඛය සුරැකීමට පෙර එහි ප්‍රමාණය අඩු කිරීම."
        ],
        correctAnswerIndex: 2,
        explanation: "නිදොස් කිරීමේ (Debugging) පහසුකම යනු IDEs හි ඇති අත්‍යවශ්‍යම මෙවලමකි. එය ක්‍රමලේඛයක් ක්‍රියාත්මක වන අතරතුර, එහි සිදුවන දෝෂ (bugs) හඳුනා ගැනීමට, කේතය පියවරෙන් පියවර ක්‍රියාත්මක කිරීමට (step-by-step execution), විචල්‍යයන්ගේ අගයන් නිරීක්ෂණය කිරීමට (inspecting variables) සහ ක්‍රියාත්මක කිරීමේ ප්‍රවාහය පාලනය කිරීමට (control flow) හැකියාව ලබා දෙයි. මෙය දෝෂ ඉක්මනින් සොයාගෙන නිවැරදි කිරීමට උපකාරී වේ."
    },
    {
        questionText: "IDE එකක 'ගොනු ආරම්භය හා සුරැකීම' (File Initialization and Saving) සම්බන්ධයෙන් සැලකිය යුතු වැදගත්ම කරුණ කුමක්ද?",
        options: [
            "සෑම විටම ස්වයංක්‍රීයව ගොනු සුරැකීමේ (auto-save) විකල්පය අක්‍රිය කිරීම.",
            "ක්‍රමලේඛය සුරැකීමේදී එය විවිධ මෙහෙයුම් පද්ධති සඳහා සුදුසු ආකෘතියකින් සුරැකීම.",
            "නව ගොනුවක් ආරම්භ කිරීමේදී නිවැරදි ගොනු වර්ගය (file type) සහ දිගුව (extension) තෝරා ගැනීම.",
            "සියලුම ක්‍රමලේඛ ගොනු එකම ෆෝල්ඩරයක තබා ගැනීම.",
            "ගොනු සුරැකීමට පෙර සෑම විටම අමතර පිටපතක් (backup) නිර්මාණය කිරීම."
        ],
        correctAnswerIndex: 2,
        explanation: "IDE එකක නව ගොනුවක් ආරම්භ කිරීමේදී හෝ සුරැකීමේදී, ක්‍රමලේඛය ලියන භාෂාවට අදාළ නිවැරදි ගොනු වර්ගය සහ දිගුව (උදා: Python සඳහා .py, Java සඳහා .java) තෝරා ගැනීම ඉතා වැදගත් වේ. මෙය IDE එකට කේතය නිවැරදිව හඳුනා ගැනීමට සහ අදාළ පහසුකම් (syntax highlighting, compilation) සැපයීමට උපකාරී වේ."
    },
    {
        questionText: "IDE එකක් භාවිතා කිරීමේදී 'ක්‍රමලේඛ සම්පාදනය හා ක්‍රියාත්මක කිරීම' (Compiling and Running a Program) යන ක්‍රියාවලියේදී සිදුවන දෝෂයක් 'සම්පාදන දෝෂයක්' (Compilation Error) ලෙස හඳුන්වන්නේ කුමක් නිසාද?",
        options: [
            "ක්‍රමලේඛය ක්‍රියාත්මක වන අතරතුර සිදුවන දෝෂයක් නිසා.",
            "සම්පාදකයට (compiler) ප්‍රභව කේතයේ ඇති වාක්‍ය රීති (syntax) හෝ ව්‍යාකරණ (grammar) දෝෂ හඳුනා ගැනීමට නොහැකි වීම නිසා.",
            "ක්‍රමලේඛය ක්‍රියාත්මක කිරීමට අවශ්‍ය මතක ප්‍රමාණය ප්‍රමාණවත් නොවීම නිසා.",
            "ක්‍රමලේඛයේ ප්‍රතිඵල අපේක්ෂිත පරිදි නොවීම නිසා.",
            "සම්පාදකයට ප්‍රභව කේතය යන්ත්‍ර කේත බවට පරිවර්තනය කිරීමට පෙර එහි ඇති තාර්කික දෝෂ (logical errors) හඳුනා ගැනීම නිසා."
        ],
        correctAnswerIndex: 1,
        explanation: "සම්පාදන දෝෂයක් (Compilation Error) සිදුවන්නේ ක්‍රමලේඛය යන්ත්‍ර කේත බවට පරිවර්තනය කරන අවස්ථාවේදී සම්පාදකයට (compiler) ප්‍රභව කේතයේ ඇති වාක්‍ය රීති (syntax) හෝ ව්‍යාකරණ (grammar) දෝෂ (syntax errors) හඳුනා ගැනීමට නොහැකි වීම නිසයි. මේවා කේතය ක්‍රියාත්මක කිරීමට පෙර නිවැරදි කළ යුතු දෝෂ වේ."
    },

    // 9.7 ඇල්ගොරිතම ආවේතනය කිරීම සඳහා ආඥාත්මක ක්‍රමලේඛ භාෂාවක් (Python) භාර්ත කරයි (Using Python)
    {
        questionText: "Python ක්‍රමලේඛයක 'විවරණ' (Comments) භාවිතා කිරීමේ මූලික අරමුණ කුමක්ද?",
        options: [
            "ක්‍රමලේඛයේ ක්‍රියාත්මක වීමේ වේගය වැඩි කිරීම.",
            "ක්‍රමලේඛයේ දෝෂ ස්වයංක්‍රීයව නිවැරදි කිරීම.",
            "ක්‍රමලේඛයේ ක්‍රියාකාරීත්වය මිනිසුන්ට තේරුම් ගැනීමට පහසු කිරීම සඳහා සටහන් ඇතුළත් කිරීම.",
            "ක්‍රමලේඛය සම්පාදනය කිරීමේදී ඇතිවන දෝෂ වළක්වා ගැනීම.",
            "ක්‍රමලේඛයේ ගබඩා කිරීමේ ඉඩ ප්‍රමාණය අඩු කිරීම."
        ],
        correctAnswerIndex: 2,
        explanation: "විවරණ (Comments) යනු ක්‍රමලේඛයේ කේත කොටසක් නොවන, ක්‍රමලේඛකයාට හෝ වෙනත් ක්‍රමලේඛකයන්ට කේතයේ ක්‍රියාකාරීත්වය, අරමුණ හෝ සංකීර්ණ කොටස් පැහැදිලි කිරීමට භාවිතා කරන සටහන් වේ. පරිවර්තකයන් හෝ සම්පාදකයන් මගින් මේවා නොසලකා හරින අතර, වැඩසටහනේ ක්‍රියාත්මක වීමට බලපෑමක් නොකරයි."
    },
    {
        questionText: "Python හි 'නියත' (Constants) සහ 'චල්‍ය' (Variables) අතර ඇති ප්‍රධාන වෙනස කුමක්ද?",
        options: [
            "නියතයන්ට අගයන් පැවරිය නොහැකි අතර, චල්‍යයන්ට අගයන් පැවරිය හැක.",
            "නියතයන් ක්‍රමලේඛය ක්‍රියාත්මක වන අතරතුර වෙනස් කළ නොහැකි අගයන් ගබඩා කරන අතර, චල්‍යයන්ට අගයන් වෙනස් කළ හැක.",
            "නියතයන් භාවිත කරන්නේ ගණිතමය කාරක (arithmetical operators) සඳහා පමණක් වන අතර, චල්‍යයන් භාවිත කරන්නේ තාර්කික කාරක (logical operators) සඳහා පමණි.",
            "නියතයන් විශාල අගයන් ගබඩා කරන අතර, චල්‍යයන් කුඩා අගයන් ගබඩා කරයි.",
            "Python භාෂාව නියතයන්ට සහ චල්‍යයන්ට එකම නීති රීති අදාළ කරයි."
        ],
        correctAnswerIndex: 1,
        explanation: "නියතයන් (Constants) යනු ක්‍රමලේඛය ක්‍රියාත්මක වන අතරතුර එහි අගය වෙනස් නොවන දත්ත ගබඩා කිරීමට භාවිතා කරන මතක ස්ථාන වේ. චල්‍යයන් (Variables) යනු ක්‍රමලේඛය ක්‍රියාත්මක වන අතරතුර එහි අගය වෙනස් කළ හැකි දත්ත ගබඩා කිරීමට භාවිතා කරන මතක ස්ථාන වේ."
    },
    {
        questionText: "Python හි 'ප්‍රාථමික දත්ත වර්ග' (Primitive Data Types) අතරට අයත් නොවන වර්ගය කුමක්ද?",
        options: [
            "Integer (පූර්ණ සංඛ්‍යා)",
            "Float (දශම සංඛ්‍යා)",
            "String (අක්ෂර මාලා)",
            "Boolean (සත්‍ය/අසත්‍ය අගයන්)",
            "Array (පසු පෙළ)"
        ],
        correctAnswerIndex: 4,
        explanation: "Python හි ප්‍රාථමික දත්ත වර්ග ලෙස Integer (int), Float (float), String (str), සහ Boolean (bool) වැනි දත්ත වර්ග හඳුනාගත හැක. Array යනු Python හි 'list' ලෙස හැඳින්වෙන සංකීර්ණ දත්ත ව්‍යුහයකි, එය ප්‍රාථමික දත්ත වර්ගයක් ලෙස නොසැලකේ."
    },
    {
        questionText: "Python හි කාරක ප්‍රමුඛතාව (Operator Precedence) පිළිබඳව සලකා බලන විට, පහත ප්‍රකාශනයෙහි නිවැරදි ප්‍රතිඵලය කුමක්ද? \n\n`result = 10 + 5 * 2 - 4 / 2`",
        options: [
            "26.0",
            "18.0",
            "13.0",
            "10.0",
            "15.0"
        ],
        correctAnswerIndex: 2,
        explanation: "Python හි කාරක ප්‍රමුඛතාවට අනුව, ගුණ කිරීම (*) සහ බෙදීම (/) එකතු කිරීම (+) සහ අඩු කිරීම (-) වලට වඩා ඉහළ ප්‍රමුඛතාවයක් ගනී. එබැවින්, මෙසේ ගණනය වේ:\n1. `5 * 2 = 10`\n2. `4 / 2 = 2.0`\n3. `10 + 10 - 2.0 = 20 - 2.0 = 18.0` \n නිවැරදි පිලිතුර 18.0 වේ. අනේක විකල්ප සාවද්‍ය වේ."
    },
    {
        questionText: "පහත Python කේත කොටස ක්‍රියාත්මක කිරීමෙන් පසු 'num' හි අවසාන අගය කුමක්ද?\n\n```python\nnum = 15\nif num % 2 == 0:\n    num = num + 5\nelif num > 10:\n    num = num - 3\nelse:\n    num = num * 2\n```",
        options: [
            "15",
            "20",
            "12",
            "30",
            "10"
        ],
        correctAnswerIndex: 2,
        explanation: "මුලින්ම `num` හි අගය 15 වේ. \n1. `num % 2 == 0` (15 % 2 == 0) යන කොන්දේසිය අසත්‍ය වේ, මන්ද 15 ඉරට්ටේ සංඛ්‍යාවක් නොවන බැවිනි. \n2. `elif num > 10` (15 > 10) යන කොන්දේසිය සත්‍ය වේ. \n3. එබැවින් `num = num - 3` ක්‍රියාත්මක වේ, එනම් `num = 15 - 3 = 12` වේ. \nඅවසාන අගය 12 වේ."
    },
    {
        questionText: "Python හි ආදාන (Input) සහ ප්‍රතිදාන (Output) මෙහෙයුම් සම්බන්ධයෙන්, පහත සඳහන් ප්‍රකාශයන්ගෙන් නිවැරදි ප්‍රකාශය කුමක්ද?",
        options: [
            "ආදාන මෙහෙයුම් සඳහා `print()` ශ්‍රිතය භාවිතා කරන අතර, ප්‍රතිදාන මෙහෙයුම් සඳහා `input()` ශ්‍රිතය භාවිතා කරයි.",
            "`input()` ශ්‍රිතය සැමවිටම සංඛ්‍යාත්මක දත්ත පමණක් ආදානය කර ගන්නා අතර, `print()` ශ්‍රිතය අක්ෂර මාලා පමණක් ප්‍රතිදානය කරයි.",
            "`input()` ශ්‍රිතය යතුරු පුවරුවෙන් දත්ත ලබා ගැනීමට භාවිතා කරන අතර, `print()` ශ්‍රිතය සම්මත ප්‍රතිදාන උපාංගවල (උදා: තිරය) දත්ත පෙන්වීමට භාවිතා කරයි.",
            "Python හි ආදාන සහ ප්‍රතිදාන මෙහෙයුම් සඳහා විශේෂ පුස්තකාල (libraries) ආයාත කළ යුතුය.",
            "`input()` ශ්‍රිතයෙන් ලබා ගන්නා දත්ත සැමවිටම Integer වර්ගයට පරිවර්තනය වේ."
        ],
        correctAnswerIndex: 2,
        explanation: "`input()` ශ්‍රිතය Python හි යතුරු පුවරුවෙන් පරිශීලක ආදානය ලබා ගැනීමට භාවිතා කරයි. එය සැමවිටම අක්ෂර මාලාවක් (string) ලෙස ආදානය ලබා ගනී. `print()` ශ්‍රිතය සම්මත ප්‍රතිදාන උපාංගවල (උදා: තිරය) දත්ත පෙන්වීමට භාවිතා කරයි."
    },

    // Additional questions to reach 30, covering remaining aspects and ensuring difficulty.
    // 9.1 ගැටලු විසඳීමේ ක්‍රියාවලිය (Problem Solving Process)
    {
        questionText: "ගැටලුවක් විසඳීමේ ක්‍රියාවලියක 'පුනරාවර්තී ස්වභාවය' (Iterative Nature) යන්නෙන් අදහස් කරන්නේ කුමක්ද?",
        options: [
            "විසඳුම එක් වරක් පමණක් සැලසුම් කර ක්‍රියාත්මක කිරීම.",
            "ගැටලුව විසඳීම සඳහා එක් ක්‍රමවේදයක් පමණක් භාවිතා කිරීම.",
            "පියවර අතර නිරන්තරයෙන් ඉදිරියට හා පසුපසට ගමන් කරමින්, අවශ්‍ය නම් පෙර පියවර නැවත සමාලෝචනය කර වැඩිදියුණු කිරීම.",
            "සෑම විටම නව ගැටලු විසඳීම සඳහා නව ක්‍රමවේද නිර්මාණය කිරීම.",
            "ගැටලුව විසඳීම සඳහා කණ්ඩායම් සාමාජිකයන් කිහිප දෙනෙකු සම්බන්ධ කිරීම."
        ],
        correctAnswerIndex: 2,
        explanation: "ගැටලු විසඳීමේ ක්‍රියාවලිය යනු සෘජු, රේඛීය ක්‍රියාවලියක් නොවේ. එය පුනරාවර්තී ස්වභාවයක් ගනී. එනම්, එක් පියවරකදී ලැබෙන ප්‍රතිඵල මත පදනම්ව, පෙර පියවර නැවත සමාලෝචනය කිරීමට, වෙනස් කිරීමට හෝ වැඩිදියුණු කිරීමට සිදුවිය හැක. මෙය විසඳුමේ ගුණාත්මක භාවය වැඩි දියුණු කිරීමට උපකාරී වේ."
    },
    {
        questionText: "ගැටලුවක් විසඳීමේ ක්‍රියාවලියේදී, 'පසු විපරම සහ නඩත්තුව' (Monitoring and Maintenance) යන පියවරේ වැදගත්කම කුමක්ද?",
        options: [
            "විසඳුම ක්‍රියාත්මක කිරීමට පෙර සියලු දෝෂ ඉවත් කිරීම.",
            "විසඳුමෙහි කාර්යසාධනය (performance) පරීක්ෂා කර, කාලයත් සමඟ ඇතිවන ගැටලු හෝ අවශ්‍යතා අනුව එය යාවත්කාලීන කිරීම.",
            "විසඳුම ක්‍රියාත්මක කිරීමට අවශ්‍ය අවම දෘඪාංග අවශ්‍යතා තීරණය කිරීම.",
            "විසඳුම සැලසුම් කිරීමේදී අනාගත වෙනස්කම් සඳහා ඉඩ තැබීම.",
            "විසඳුමෙහි ආරක්ෂාව සහතික කිරීම."
        ],
        correctAnswerIndex: 1,
        explanation: "විසඳුම ක්‍රියාත්මක කිරීමෙන් පසුව එය අධීක්ෂණය කිරීම සහ නඩත්තු කිරීම අත්‍යවශ්‍ය වේ. මෙය විසඳුමෙහි කාර්යසාධනය පරීක්ෂා කිරීමට, කාලයත් සමඟ ඇතිවන නව අවශ්‍යතා හෝ දෝෂ හඳුනාගෙන ඒවාට අනුව විසඳුම යාවත්කාලීන කිරීමට උපකාරී වේ. මෙය විසඳුමෙහි දිගුකාලීන සාර්ථකත්වය සහතික කරයි."
    },

    // 9.2 ගැටලු විසඳීම සඳහා ඉහළ පහළ පියවරාකාර ක්‍රමවේදය (Top-Down Stepwise Refinement)
    {
        questionText: "ඉහළ පහළ සැලසුමකදී මොඩියුල අතර 'අඩු සම්බන්ධතාවයක්' (Low Coupling) සහ 'ඉහළ ඒකාබද්ධතාවයක්' (High Cohesion) තිබීම වැදගත් වන්නේ ඇයි?",
        options: [
            "එය මොඩියුලවල ප්‍රමාණය වැඩි කිරීමට උපකාරී වේ.",
            "එය මොඩියුල අතර දත්ත හුවමාරුව සංකීර්ණ කරයි.",
            "එය මොඩියුල වඩාත් ස්වාධීන සහ නැවත භාවිත කළ හැකි (reusable) බවට පත් කරන අතර, නඩත්තු කිරීම සහ දෝෂ නිවැරදි කිරීම පහසු කරයි.",
            "එය එක් මොඩියුලයක් වෙනස් කිරීමෙන් අනෙක් මොඩියුලවලට ඇති බලපෑම වැඩි කරයි.",
            "එය මොඩියුලකරණයෙන් තොරව වැඩසටහන් ලිවීමට ඉඩ සලසයි."
        ],
        correctAnswerIndex: 2,
        explanation: "අඩු සම්බන්ධතාවයක් (Low Coupling) යනු මොඩියුල අතර රඳා පැවැත්ම (dependency) අවම වීමයි, එනම් එක් මොඩියුලයක වෙනසක් තවත් මොඩියුලයකට අවම බලපෑමක් එල්ල කරයි. ඉහළ ඒකාබද්ධතාවයක් (High Cohesion) යනු මොඩියුලයක් තුළ ඇති කාර්යයන් තනි, පැහැදිලි අරමුණක් වටා හොඳින් කාණ්ඩගත වී තිබීමයි. මෙම දෙකම මොඩියුල නැවත භාවිත කිරීමට, නඩත්තු කිරීමට සහ දෝෂ නිවැරදි කිරීමට පහසු කරයි."
    },
    {
        questionText: "ව්‍යුහ සටහන් (Structure Charts) භාවිතයෙන් ප්‍රකාශ කළ නොහැකි තොරතුරු වර්ගය කුමක්ද?",
        options: [
            "මොඩියුල අතර ධුරාවලිය.",
            "මොඩියුල අතර දත්ත ප්‍රවාහය.",
            "සෑම මොඩියුලයක් තුළම සිදුවන පාලන ප්‍රවාහය (control flow) සහ තර්කය (logic).",
            "මොඩියුල කැඳවීමේ අනුපිළිවෙල.",
            "පද්ධතියේ ප්‍රධාන කාර්යයන් සහ උප-කාර්යයන්."
        ],
        correctAnswerIndex: 2,
        explanation: "ව්‍යුහ සටහන් මගින් මොඩියුල අතර ඇති ධුරාවලිය සහ දත්ත ප්‍රවාහය (who calls whom and what data passes) නිරූපණය කරයි. නමුත්, එක් එක් මොඩියුලයක් තුළ සිදුවන විස්තරාත්මක පාලන ප්‍රවාහය (උදා: if-else statements, loops) හෝ තර්කය ව්‍යුහ සටහන් මගින් නිරූපණය නොකරයි. ඒ සඳහා ගැලීම් සටහන් හෝ ව්‍යාජ කේත භාවිතා වේ."
    },

    // 9.3 ගැටලු විසඳීම සඳහා ඇල්ගෝරිතමික ප්‍රවේශය (Algorithmic Approach)
    {
        questionText: "ගැලීම් සටහනක 'ආරම්භය/අවසානය' (Start/End) සංකේතය (කවය හෝ ඕවලාකාරය) නිරූපණය කරන්නේ කුමක්ද?",
        options: [
            "දත්ත සැකසීම.",
            "තීරණයක් ගැනීම.",
            "ක්‍රමලේඛයේ ප්‍රධාන කොටස් අතර සම්බන්ධතාවය.",
            "ඇල්ගොරිතමයක ආරම්භක සහ අවසාන ලක්ෂ්‍යය.",
            "ක්‍රමලේඛය තුළ සිදුවන පුනරාවර්තන ක්‍රියාවලියක්."
        ],
        correctAnswerIndex: 3,
        explanation: "ගැලීම් සටහනක කවය හෝ ඕවලාකාර හැඩැති සංකේතය මගින් ඇල්ගොරිතමයක ආරම්භක සහ අවසාන ලක්ෂ්‍යය නිරූපණය කරයි. මෙය ගැලීම් සටහනේ සීමාවන් පැහැදිලිව පෙන්වයි."
    },
    {
        questionText: "ව්‍යාජ කේතයක් ලිවීමේදී 'අවසාන කේතය' (Final Code) ලිවීමට පෙර 'හස්තානුලේඛන' (Hand Traces) සිදුකිරීමෙන් ලැබෙන ප්‍රධාන ප්‍රතිලාභය කුමක්ද?",
        options: [
            "කේතයේ වාක්‍ය දෝෂ (syntax errors) හඳුනා ගැනීම.",
            "කේතය ක්‍රියාත්මක කිරීමට ගතවන කාලය අඩු කිරීම.",
            "ක්‍රමලේඛ භාෂාව පිළිබඳ ගැඹුරු අවබෝධයක් ලබා දීම.",
            "ඇල්ගොරිතමයේ තාර්කික දෝෂ (logical errors) පරිගණකය භාවිත නොකරම හඳුනාගෙන නිවැරදි කර ගැනීමට හැකි වීම.",
            "ක්‍රමලේඛය ස්වයංක්‍රීයව ලේඛනගත කිරීම (documenting)."
        ],
        correctAnswerIndex: 3,
        explanation: "හස්තානුලේඛන (Hand Traces) ප්‍රධාන වශයෙන් භාවිතා කරන්නේ ඇල්ගොරිතමයක ඇති තාර්කික දෝෂ (logical errors) පරිගණකයක් මත ක්‍රියාත්මක කිරීමට පෙර හඳුනාගෙන නිවැරදි කර ගැනීමටයි. මෙය සංවර්ධන ක්‍රියාවලියේදී කාලය සහ සම්පත් ඉතිරි කරයි, මන්ද දෝෂ මුල් අවධියේදීම හඳුනාගත හැකි බැවිනි."
    },
    {
        questionText: "යම් සිසුවෙකු ගැටලුවකට විසඳුමක් සැලසුම් කිරීමේදී, පියවරෙන් පියවර උපදෙස් මාලාවක් මිනිසාට පහසුවෙන් තේරුම් ගත හැකි භාෂාවකින් ලියා, පසුව එය පරිගණකයකට ක්‍රියාත්මක කළ හැකි ආකාරයට පරිවර්තනය කිරීමට පෙර, එහි තර්කය පරීක්ෂා කිරීමට අවශ්‍ය වූ විට ඔහු විසින් භාවිතා කළ යුතු හොඳම ක්‍රමවේදයන් යුගලය කුමක්ද?",
        options: [
            "යථාර්ථික කේතය (Actual Code) සහ සම්පාදනය (Compilation).",
            "හස්තානුලේඛන (Hand Traces) සහ දත්ත සමුදා සැලසුම් (Database Design).",
            "ව්‍යාජ කේත (Pseudo Code) සහ ගැලීම් සටහන් (Flow Charts).",
            "ව්‍යුහ සටහන් (Structure Charts) සහ පද්ධති පිරිවිතර (System Specifications).",
            "ක්‍රමලේඛ පරිවර්තක (Program Translators) සහ IDE."
        ],
        correctAnswerIndex: 2,
        explanation: "ගැටලුවකට විසඳුමක් සැලසුම් කිරීමේදී, පියවරෙන් පියවර උපදෙස් මාලාවක් මිනිසාට පහසුවෙන් තේරුම් ගත හැකි භාෂාවකින් ලිවීම සඳහා 'ව්‍යාජ කේත' (Pseudo Code) වඩාත් සුදුසු වේ. එහි තර්කය දෘශ්‍යමය වශයෙන් නිරූපණය කිරීමට 'ගැලීම් සටහන්' (Flow Charts) උපකාරී වේ. මෙම ක්‍රමවේද දෙකම කේතීකරණයට පෙර ඇල්ගොරිතමයේ තර්කය පැහැදිලිව නිර්වචනය කිරීමට සහ පරීක්ෂා කිරීමට උපකාරී වේ."
    },

    // 9.4 ක්‍රමලේඛනය කිරීමේ විවිධ සුසමාදර්ශ (Programming Paradigms)
    {
        questionText: "පරිගණක භාෂාවන්ගේ 'පස්වන පරම්පරාව' (Fifth Generation Languages - 5GL) පිළිබඳ නිවැරදිම ප්‍රකාශය කුමක්ද?",
        options: [
            "මේවා යන්ත්‍ර කේතයට (Machine Code) සෘජුවම සම්බන්ධ භාෂා වේ.",
            "මේවා ප්‍රධාන වශයෙන් ක්‍රමලේඛන දෝෂ (bugs) සොයා ගැනීම සඳහා නිර්මාණය කරන ලදි.",
            "මේවා ප්‍රධාන වශයෙන් කෘත්‍රිම බුද්ධිය (Artificial Intelligence) සහ ස්වාභාවික භාෂා සැකසීම (Natural Language Processing) වැනි ක්ෂේත්‍ර සඳහා සංවර්ධනය කරන ලද භාෂා වේ.",
            "මේවා යතුරු පුවරුවෙන් ආදානය ලබා ගැනීමට පමණක් සීමා වේ.",
            "මේවායේ ප්‍රධාන අරමුණ වන්නේ දත්ත ගබඩා කිරීමේ කාර්යක්ෂමතාවය වැඩි කිරීමයි."
        ],
        correctAnswerIndex: 2,
        explanation: "පස්වන පරම්පරාවේ භාෂා (5GL) ප්‍රධාන වශයෙන් නිර්මාණය කර ඇත්තේ කෘත්‍රිම බුද්ධිය (AI), ස්වාභාවික භාෂා සැකසීම (NLP) සහ විශේෂඥ පද්ධති (expert systems) වැනි සංකීර්ණ ක්ෂේත්‍ර සඳහාය. මේවායේ අරමුණ වන්නේ පරිගණකයට ගැටලුව 'කුමක්ද' යන්න පැවසීමෙන් විසඳුම් සෙවීමට ඉඩ දීමයි, 'කෙසේද' යන්න නොවේ."
    },

    // 9.5 ක්‍රමලේඛ පරිවර්තනය කිරීමේ අවශ්‍යතාව සහ ක්‍රමලේඛ පරිවර්තක වර්ග (Program Translation)
    {
        questionText: "ක්‍රමලේඛ පරිවර්තනය කිරීමේදී, 'ප්‍රභව ක්‍රමලේඛය' (Source Program) සහ 'වස්තු ක්‍රමලේඛය' (Object Program) අතර ඇති මූලික වෙනස කුමක්ද?",
        options: [
            "ප්‍රභව ක්‍රමලේඛය පරිගණකයකට තේරුම් ගත හැකි අතර, වස්තු ක්‍රමලේඛය මිනිසුන්ට තේරුම් ගත හැක.",
            "ප්‍රභව ක්‍රමලේඛය යනු මිනිසා විසින් ලියන ලද ඉහළ මට්ටමේ කේතයක් වන අතර, වස්තු ක්‍රමලේඛය යනු පරිගණකයට ක්‍රියාත්මක කළ හැකි යන්ත්‍ර කේතයකි.",
            "ප්‍රභව ක්‍රමලේඛය ක්‍රියාත්මක වීමට අර්ථනාසකයක් අවශ්‍ය වන අතර, වස්තු ක්‍රමලේඛය ක්‍රියාත්මක වීමට සම්පාදකයක් අවශ්‍ය වේ.",
            "ප්‍රභව ක්‍රමලේඛය සැමවිටම කෙටි වන අතර, වස්තු ක්‍රමලේඛය සැමවිටම දිගු වේ.",
            "ප්‍රභව ක්‍රමලේඛයට දෝෂ අඩංගු විය හැකි අතර, වස්තු ක්‍රමලේඛය සැමවිටම දෝෂ රහිතය."
        ],
        correctAnswerIndex: 1,
        explanation: "ප්‍රභව ක්‍රමලේඛය (Source Program) යනු ක්‍රමලේඛකයින් විසින් ලියන ලද, මිනිසාට කියවිය හැකි උසස් මට්ටමේ භාෂාවකින් (උදා: Python) ලියන ලද කේතයයි. වස්තු ක්‍රමලේඛය (Object Program) යනු පරිවර්තකයක් (compiler හෝ interpreter) මගින් ප්‍රභව කේතය පරිගණකයට සෘජුවම ක්‍රියාත්මක කළ හැකි යන්ත්‍ර කේතය (machine code) බවට පරිවර්තනය කිරීමෙන් ලැබෙන ප්‍රතිඵලයයි."
    },
    {
        questionText: "සම්පාදකයක් (Compiler) මගින් පරිවර්තනය කරන ලද ක්‍රමලේඛයක්, අර්ථනාසකයක් (Interpreter) මගින් පරිවර්තනය කරන ලද ක්‍රමලේඛයකට වඩා වේගවත්ව ක්‍රියාත්මක වන්නේ ඇයි?",
        options: [
            "සම්පාදකයක් මගින් අර්ථනාසකයකට වඩා අඩු දෝෂ සංඛ්‍යාවක් ජනනය කරන නිසා.",
            "සම්පාදකයක් මගින් සම්පූර්ණ ක්‍රමලේඛයම එක් වරක් යන්ත්‍ර කේත බවට පරිවර්තනය කරන බැවින්, නැවත නැවත පරිවර්තනය කිරීමේ අවශ්‍යතාවක් නොමැති වීම නිසා.",
            "අර්ථනාසකයක් මගින් වැඩි මතක ප්‍රමාණයක් භාවිතා කරන නිසා.",
            "සම්පාදකයක් මගින් ක්‍රමලේඛයේ ප්‍රමාණය අඩු කරන නිසා.",
            "අර්ථනාසකයක් මගින් ක්‍රමලේඛයේ විවරණ (comments) ද පරිවර්තනය කරන නිසා."
        ],
        correctAnswerIndex: 1,
        explanation: "සම්පාදකයක් මගින් සම්පූර්ණ ප්‍රභව කේතයම එක් වරක් යන්ත්‍ර කේත බවට පරිවර්තනය කර වස්තු ක්‍රමලේඛයක් (executable file) සාදයි. මෙම වස්තු ක්‍රමලේඛය පසුව සෘජුවම ක්‍රියාත්මක කළ හැක. අර්ථනාසකයක් කේතය පේළියෙන් පේළියට කියවමින්, සෑම වතාවකම එය ක්‍රියාත්මක කරන අවස්ථාවේදීම පරිවර්තනය කරන නිසා, සම්පාදකයකට වඩා මන්දගාමී වේ."
    },

    // 9.6 සමෝධානික සංවර්ධන පරිසරයේ (IDE) මූලික ලක්ෂණ (IDE Features)
    {
        questionText: "පහත සඳහන් IDE ලක්ෂණ අතරින්, 'Syntax Highlighting' හි මූලික අරමුණ කුමක්ද?",
        options: [
            "ක්‍රමලේඛය ක්‍රියාත්මක කිරීමට අවශ්‍ය මතක ප්‍රමාණය පෙන්වීම.",
            "කේතයේ විවිධ කොටස් (උදා: keyword, variables, comments) වර්ණ ගැන්වීමෙන් කියවීමේ හැකියාව වැඩි දියුණු කිරීම.",
            "කේතයේ දෝෂ ස්වයංක්‍රීයව නිවැරදි කිරීම.",
            "කේතය ලිවීමට අවශ්‍ය කාලය ඇස්තමේන්තු කිරීම.",
            "ක්‍රමලේඛයේ අනුවාද පාලනය (version control) සිදු කිරීම."
        ],
        correctAnswerIndex: 1,
        explanation: "Syntax Highlighting යනු IDE හි ඇති දෘශ්‍ය පහසුකමකි. එය කේතයේ විවිධ කොටස් (වාක්‍ය කීවර්ඩ්, විචල්‍යයන්, විවරණ, ස්ට්‍රිං) විවිධ වර්ණවලින් වර්ණ ගන්වයි. මෙය කේතය කියවීම සහ තේරුම් ගැනීම පහසු කරන අතර, වාක්‍ය දෝෂ (syntax errors) ඉක්මනින් හඳුනා ගැනීමටද උපකාරී වේ."
    },
    {
        questionText: "IDE එකක 'Breakpoints' භාවිතා කිරීමේ ප්‍රධාන වාසිය කුමක්ද?",
        options: [
            "ක්‍රමලේඛය සම්පාදනය කිරීමේ ක්‍රියාවලිය වේගවත් කිරීම.",
            "ක්‍රමලේඛය තුළ දත්ත ගබඩා කිරීමේ ක්‍රමවේද වෙනස් කිරීම.",
            "ක්‍රමලේඛයක් ක්‍රියාත්මක වන අතරතුර, නිශ්චිත ස්ථානයකදී එය තාවකාලිකව නැවැත්වීමට, එමගින් එම ස්ථානයේදී විචල්‍ය අගයන් පරීක්ෂා කිරීමට හෝ කේතය පියවරෙන් පියවර ක්‍රියාත්මක කිරීමට.",
            "ක්‍රමලේඛයේ ප්‍රතිදානය විවිධ ආකෘතිවලින් පෙන්වීම.",
            "ක්‍රමලේඛය ස්වයංක්‍රීයව පරිශීලක අතුරුමුහුණතක් (GUI) බවට පත් කිරීම."
        ],
        correctAnswerIndex: 2,
        explanation: "Breakpoints යනු නිදොස් කිරීමේ (debugging) ක්‍රියාවලියේදී අත්‍යවශ්‍ය මෙවලමකි. ක්‍රමලේඛකයාට කේතයේ නිශ්චිත පේළිවල 'breakpoints' සැකසිය හැකි අතර, වැඩසටහන ක්‍රියාත්මක වන විට එම ස්ථානයට පැමිණි විට එය තාවකාලිකව නතර වේ. මෙය මගින් ක්‍රමලේඛකයාට එම අවස්ථාවේ විචල්‍යයන්ගේ අගයන් පරීක්ෂා කිරීමට, කේතය පියවරෙන් පියවර ක්‍රියාත්මක කිරීමට (step through) සහ දෝෂ හඳුනා ගැනීමට හැකි වේ."
    },

    // 9.7 ඇල්ගොරිතම ආවේතනය කිරීම සඳහා ආඥාත්මක ක්‍රමලේඛ භාෂාවක් (Python) භාර්ත කරයි (Using Python)
    {
        questionText: "Python හි 'සම්බන්ධක කාරක' (Relational Operators) භාවිත කිරීමේ මූලික අරමුණ කුමක්ද?",
        options: [
            "ගණිතමය ගණනය කිරීම් සිදු කිරීම.",
            "දත්ත වර්ග අතර පරිවර්තනයන් සිදු කිරීම.",
            "විචල්‍යයන් දෙකක් හෝ ප්‍රකාශන දෙකක් අතර සම්බන්ධතාවය (සමානත්වය, විශාලත්වය, කුඩා බව) පරීක්ෂා කිරීම.",
            "දත්ත ගබඩා කිරීමේ ක්‍රමවේදයන් නිර්මාණය කිරීම.",
            "ක්‍රමලේඛයේ විවරණ (comments) එකතු කිරීම."
        ],
        correctAnswerIndex: 2,
        explanation: "සම්බන්ධක කාරක (Relational Operators) (උදා: `==`, `!=`, `<`, `>`, `<=`, `>=`) යනු Python හි විචල්‍යයන් දෙකක් හෝ ප්‍රකාශන දෙකක් අතර සම්බන්ධතාවය පරීක්ෂා කිරීමට භාවිතා කරන කාරක වේ. මේවායේ ප්‍රතිඵලය සෑම විටම Boolean (True/False) අගයකි."
    },
    {
        questionText: "පහත Python කේත කොටස ක්‍රියාත්මක කිරීමෙන් පසු 'result' හි අගය කුමක්ද?\n\n```python\na = True\nb = False\nresult = a and b\n```",
        options: [
            "True",
            "False",
            "Error",
            "None",
            "a"
        ],
        correctAnswerIndex: 1,
        explanation: "`and` යනු තාර්කික කාරකයකි. `True and False` යන ප්‍රකාශනයේ ප්‍රතිඵලය සෑම විටම `False` වේ. මන්ද, `and` කාරකයේ ප්‍රතිඵලය `True` වීමට නම්, දෙපසම ඇති ප්‍රකාශන `True` විය යුතුය."
    },
    {
        questionText: "Python හි 'Bitwise Operators' (බිටු අනුසාර්ත කාරක) භාවිත කිරීමේ ප්‍රධාන අවශ්‍යතාව කුමක්ද?",
        options: [
            "සංඛ්‍යාත්මක දත්ත ගබඩා කිරීමේදී ඒවායේ නිරවද්‍යතාවය වැඩි කිරීම.",
            "දත්ත ගොනු ආරක්ෂා කිරීම සඳහා ඒවා සංකේතනය කිරීම.",
            "සංඛ්‍යා වල ද්විමය නිරූපණයේ (binary representation) තනි බිටු මත මෙහෙයුම් සිදු කිරීම.",
            "ක්‍රමලේඛයේ වේගය අඩු කර මතක භාවිතය වැඩි කිරීම.",
            "විවිධ දත්ත වර්ග අතර පරිවර්තනයන් පහසු කිරීම."
        ],
        correctAnswerIndex: 2,
        explanation: "Bitwise Operators (උදා: `&` (AND), `|` (OR), `^` (XOR), `~` (NOT), `<<` (Left Shift), `>>` (Right Shift)) යනු සංඛ්‍යාවල ද්විමය නිරූපණයේ තනි බිටු (bits) මත මෙහෙයුම් සිදු කිරීමට භාවිතා කරන කාරක වේ. මේවා පහත් මට්ටමේ (low-level) දත්ත හැසිරවීම් සහ සමහර ඇල්ගොරිතම සඳහා ප්‍රයෝජනවත් වේ."
    },
    {
        questionText: "පහත Python කේතය ක්‍රියාත්මක කිරීමෙන් පසු ප්‍රතිදානය කුමක්ද?\n\n```python\nx = 7\ny = 3\nprint(x // y)\n```",
        options: [
            "2.333",
            "2",
            "1",
            "7",
            "3"
        ],
        correctAnswerIndex: 1,
        explanation: "`//` යනු Python හි 'Floor Division' කාරකයයි. එය බෙදීමේ ප්‍රතිඵලයේ පූර්ණ සංඛ්‍යා කොටස පමණක් ලබා දෙයි (දශම කොටස ඉවත් කරයි). `7 / 3` හි ප්‍රතිඵලය 2.333... වන අතර, `7 // 3` හි ප්‍රතිඵලය 2 වේ."
    },
    {
        questionText: "Python හි 'print()' ශ්‍රිතය භාවිතයෙන් විවිධ දත්ත වර්ග ප්‍රතිදානය කිරීමේදී, ස්වයංක්‍රීයව නව පේළියකට (newline) මාරු වීම වැලැක්වීමට භාවිතා කළ හැකි තර්කය (argument) කුමක්ද?",
        options: [
            "sep=''",
            "end=''",
            "flush=True",
            "file=sys.stdout",
            "text=''"
        ],
        correctAnswerIndex: 1,
        explanation: "Python හි `print()` ශ්‍රිතය පෙරනිමියෙන් (by default) සෑම විටම මුද්‍රණය කිරීමෙන් පසු නව පේළියකට මාරු වේ. මෙය වැලැක්වීම සඳහා `end` යන තර්කය භාවිතා කළ හැක. උදාහරණයක් ලෙස, `print('Hello', end='')` මගින් 'Hello' මුද්‍රණය කර නව පේළියකට නොයයි."
    },
    {
        questionText: "Python හි, විචල්‍ය නාමකරණය (variable naming) සඳහා අදාළ නොවන රීතිය කුමක්ද?",
        options: [
            "විචල්‍ය නාමයක් ඉංග්‍රීසි අකුරකින් හෝ යටිරේඛාවකින් (underscore) ආරම්භ විය යුතුය.",
            "විචල්‍ය නාමයක ඉංග්‍රීසි අකුරු, සංඛ්‍යා සහ යටිරේඛා අඩංගු විය හැක.",
            "විචල්‍ය නාමයක් සංඛ්‍යාවකින් ආරම්භ විය හැක.",
            "Python යනු case-sensitive භාෂාවක් බැවින් 'Age' සහ 'age' යනු විවිධ විචල්‍යයන් ලෙස සැලකේ.",
            "Python හි වෙන්කළ වචන (keywords) විචල්‍ය නාම ලෙස භාවිතා කළ නොහැක."
        ],
        correctAnswerIndex: 2,
        explanation: "Python හි විචල්‍ය නාමයක් කිසිවිටෙකත් සංඛ්‍යාවකින් ආරම්භ විය නොහැක. එය අනිවාර්යයෙන්ම ඉංග්‍රීසි අකුරකින් (a-z, A-Z) හෝ යටිරේඛාවකින් (_) ආරම්භ විය යුතුය. මෙය Python හි නාමකරණ සම්මුතියේ (naming convention) මූලික රීතියකි."
    },
    {
        questionText: "පහත Python කේතය ක්‍රියාත්මක කිරීමෙන් පසු 'message' හි අගය කුමක්ද?\n\n```python\nname = 'Alice'\nage = 30\nmessage = 'My name is ' + name + ' and I am ' + str(age) + ' years old.'\n```",
        options: [
            "'My name is Alice and I am 30 years old.'",
            "'My name is name and I am age years old.'",
            "Error: cannot concatenate string and int",
            "None",
            "'Alice30'"
        ],
        correctAnswerIndex: 0,
        explanation: "මෙහිදී `name` (string) සහ `age` (integer) විචල්‍යයන් string concatenation මගින් එකතු කර ඇත. `age` යනු integer වර්ගයක් බැවින්, එය `str(age)` මගින් string වර්ගයකට පරිවර්තනය කිරීමෙන් පසු අනෙක් string සමඟ සාර්ථකව සම්බන්ධ කළ හැක. ප්‍රතිඵලය වන්නේ 'My name is Alice and I am 30 years old.' යන string එකයි."
    },
    {
        questionText: "Python ක්‍රමලේඛයක මූලික ව්‍යුහය පිළිබඳව පහත සඳහන් ප්‍රකාශයන්ගෙන් වැරදි ප්‍රකාශය කුමක්ද?",
        options: [
            "Python කේතය පේළි වලින් සමන්විත වන අතර, සෑම පේළියක්ම උපදෙස් (statement) එකක් හෝ කිහිපයක් විය හැක.",
            "Python බ්ලොක් (block) හඳුනා ගැනීම සඳහා `{}` වරහන් භාවිතා කරයි.",
            "Python indentation (ඉඩ තැබීම) භාවිතා කරමින් කේත බ්ලොක් (code blocks) හඳුනා ගනී.",
            "විවරණ (comments) `#` සංකේතයෙන් ආරම්භ වේ.",
            "Python හි ශ්‍රිත (functions) නිර්මාණය කිරීමට `def` යන වචනය භාවිතා කරයි."
        ],
        correctAnswerIndex: 1,
        explanation: "Python භාෂාව කේත බ්ලොක් (code blocks) හඳුනා ගැනීම සඳහා indentation (ඉඩ තැබීම) භාවිතා කරයි. `{}` වරහන් භාවිතා කරන්නේ වෙනත් බොහෝ ක්‍රමලේඛ භාෂාවල (උදා: C++, Java, JavaScript) බ්ලොක් හඳුනා ගැනීමටයි. මෙය Python හි සුවිශේෂී ලක්ෂණයකි."
    },
    {
        questionText: "Python හි 'තාර්කික කාරක' (Logical Operators) භාවිතයෙන් තොරව, පහත සඳහන් කොන්දේසිය 'num' 5ට වඩා විශාල සහ 10ට වඩා කුඩා බව පරීක්ෂා කිරීමට වඩාත් නිවැරදි Python ප්‍රකාශය කුමක්ද?",
        options: [
            "`if 5 < num < 10:`",
            "`if num > 5 and num < 10:`",
            "`if num > 5 or num < 10:`",
            "`if (num > 5) then (num < 10):`",
            "`if num between 5 and 10:`"
        ],
        correctAnswerIndex: 0,
        explanation: "Python හි කොන්දේසි පරීක්ෂා කිරීමේදී, `5 < num < 10` වැනි chained comparisons භාවිතා කළ හැක. මෙය `num > 5 and num < 10` යන්නට සමාන අර්ථයක් දරන අතර, වඩාත් සංක්ෂිප්ත හා Pythonic ක්‍රමයකි. අනෙක් විකල්ප සාවද්‍ය වාක්‍ය රීති (syntax) හෝ වැරදි තාර්කික අර්ථයක් දරයි."
    },
    // 9.8: ක්‍රමලේඛ සංවර්ධනයේ පාලන ව්‍යුහ භාවිත කරයි. (Control Structures)
    {
        questionText: "ක්‍රමලේඛයක කාර්යයන් අනුපිළිවෙලකට ක්‍රියාත්මක කිරීමේදී භාවිතා වන මූලික පාලන ව්‍යුහය කුමක්ද?",
        options: [
            "අනුක්‍රමය (Sequence)",
            "තේරීම (Selection)",
            "පුනරාවෘත්තිය (Repetition)",
            "උපක්‍රමලේඛ (Subprogram)",
            "දත්ත ව්‍යුහ (Data Structure)"
        ],
        correctAnswerIndex: 0,
        explanation: "ක්‍රමලේඛයක මූලිකම ක්‍රියාකාරීත්වය වන්නේ විධාන එකින් එක අනුපිළිවෙලින් ක්‍රියාත්මක වීමයි. මෙය 'අනුක්‍රමය' (Sequence) ලෙස හැඳින්වේ. අනෙකුත් ව්‍යුහයන් විශේෂිත තත්වයන් හෝ පුනරාවර්තන සඳහා යොදා ගැනේ."
    },
    {
        questionText: "යම්කිසි කොන්දේසියක් සත්‍ය වන තුරු හෝ අසත්‍ය වන තුරු කේත කොටසක් නැවත නැවත ක්‍රියාත්මක කිරීමට වඩාත් සුදුසු පාලන ව්‍යුහය කුමක්ද?",
        options: [
            "පුනරාවෘත්තිය (Repetition)",
            "තේරීම (Selection)",
            "අනුක්‍රමය (Sequence)",
            "නිහිත ව්‍යුහ (Nested Structure)",
            "සමාන්තර සැකසුම් (Parallel Processing)"
        ],
        correctAnswerIndex: 0,
        explanation: "'පුනරාවෘත්තිය' (Repetition) හෙවත් පුනරාවර්තනය (Iteration) හෝ රූප්නය (Looping) යනු යම් කොන්දේසියක් මත පදනම්ව කේත කොටසක් නැවත නැවත ක්‍රියාත්මක කිරීමයි. උදාහරණ ලෙස for සහ while ලූප් දැක්විය හැක. තේරීම යනු කොන්දේසියක් මත එක් වරක් ක්‍රියාත්මක වීමක් වන අතර අනුක්‍රමය යනු සරල විධාන අනුපිළිවෙලකි."
    },
    {
        questionText: "ශිෂ්‍යයෙකුගේ ලකුණු 75ට වැඩි නම් 'A' ලෙසත්, 65ට වැඩි නම් 'B' ලෙසත්, 55ට වැඩි නම් 'C' ලෙසත් ප්‍රදර්ශනය කිරීමට අවශ්‍ය ක්‍රමලේඛනයකදී භාවිතා කළ යුතු පාලන ව්‍යුහ වර්ගය සහ එහි නිවැරදි භාවිතය කුමක්ද?",
        options: [
            "නිහිත තේරීම් ව්‍යුහ (Nested Selection) – බහුවිධ කොන්දේසි පරීක්ෂා කිරීමට",
            "සරල තේරීම් ව්‍යුහ (Simple Selection) – එක් කොන්දේසියක් පමණක් පරීක්ෂා කිරීමට",
            "අනුක්‍රමික ව්‍යුහ (Sequential Structure) – පියවරෙන් පියවර ක්‍රියාත්මක වීමට",
            "පුනරාවෘත්ති ව්‍යුහ (Repetition Structure) – නැවත නැවත එකම ක්‍රියාව කිරීමට",
            "දත්ත ව්‍යුහ (Data Structure) – දත්ත ගබඩා කිරීමට"
        ],
        correctAnswerIndex: 0,
        explanation: "ලකුණු පරාස කිහිපයක් පරීක්ෂා කර විවිධ ප්‍රතිඵල ලබා දීමට අවශ්‍ය වන බැවින්, එක් 'if' ප්‍රකාශයක් තුළ තවත් 'if' ප්‍රකාශයක් අඩංගු වන 'නිහිත තේරීම් ව්‍යුහ' (Nested Selection) හෝ 'if-else if-else' දාමයක් භාවිතා කිරීම වඩාත් නිවැරදි හා කාර්යක්ෂම වේ. සරල තේරීමක් එක් කොන්දේසියකට පමණක් සීමා වන අතර, අනුක්‍රමික සහ පුනරාවෘත්ති ව්‍යුහ මෙම තත්වයට අදාළ නොවේ."
    },
    {
        questionText: "පාලන ව්‍යුහ පිළිබඳ පහත ප්‍රකාශයන්ගෙන් නිවැරදි නොවන ප්‍රකාශය කුමක්ද?",
        options: [
            "for ලූප් එකක් යනු තේරීම් ව්‍යුහයකට උදාහරණයකි.",
            "if-else ප්‍රකාශය තේරීම් ව්‍යුහයක් නියෝජනය කරයි.",
            "while ලූප් එකක් පුනරාවෘත්ති ව්‍යුහයක් ලෙස වර්ගීකරණය වේ.",
            "ක්‍රමලේඛයක් සැමවිටම අනුක්‍රමිකව ක්‍රියාත්මක වීමෙන් ආරම්භ වේ.",
            "switch-case ප්‍රකාශය බහුවිධ තේරීම් සඳහා භාවිතා කළ හැක."
        ],
        correctAnswerIndex: 0,
        explanation: "for ලූප් එකක් යනු 'පුනරාවෘත්ති' (Repetition) ව්‍යුහයකට උදාහරණයකි, එය තේරීම් ව්‍යුහයක් නොවේ. තේරීම් ව්‍යුහ මඟින් කොන්දේසියක් මත පදනම්ව එක් වරක් පමණක් කේත කොටසක් ක්‍රියාත්මක කිරීමට හෝ නොකිරීමට තීරණය කරයි. අනෙකුත් ප්‍රකාශ සියල්ල නිවැරදි වේ."
    },
    {
        questionText: "පහත දැක්වෙන කේත කොටසෙහි ප්‍රතිඵලය කුමක්ද? \n\n```javascript\nlet x = 10;\nif (x > 5) {\n    if (x < 15) {\n        console.log('තත්ව 1');\n    } else {\n        console.log('තත්ව 2');\n    }\n} else {\n    console.log('තත්ව 3');\n}\n```",
        options: [
            "තත්ව 1",
            "තත්ව 2",
            "තත්ව 3",
            "දෝෂයක් (Error)",
            "කිසිවක් ප්‍රදර්ශනය නොවේ"
        ],
        correctAnswerIndex: 0,
        explanation: "මෙහි x හි අගය 10 වේ. පළමු කොන්දේසිය වන x > 5 (10 > 5) සත්‍ය වන බැවින්, අභ්‍යන්තර if ප්‍රකාශය ක්‍රියාත්මක වේ. එහිදී x < 15 (10 < 15) ද සත්‍ය වන බැවින්, 'තත්ව 1' ලෙස console එකේ මුද්‍රණය වේ. මෙය නිහිත තේරීම් ව්‍යුහයක (nested selection) නිදසුනකි."
    },
    {
        questionText: "පහත දැක්වෙන ක්‍රමලේඛන තත්ත්වයන්ගෙන් කුමන අවස්ථාවක පුනරාවෘත්ති ව්‍යුහයක් (repetition structure) භාවිතා කිරීම වඩාත් කාර්යක්ෂම නොවේද?",
        options: [
            "දත්ත සමූහයක සෑම අයිතමයක්ම එක් වරක් පමණක් පරිශීලනය කිරීමට.",
            "නිශ්චිත වාර ගණනක් සඳහා ක්‍රියාවක් නැවත නැවත සිදු කිරීමට.",
            "යම් කොන්දේසියක් සත්‍ය වන තුරු ක්‍රියාවක් සිදු කිරීමට.",
            "අනන්ත පුනරාවෘත්තියක් (infinite loop) අවශ්‍ය වන විට.",
            "ක්‍රීඩාවක ප්‍රධාන ලූප් එක (game loop) ක්‍රියාත්මක කිරීමට."
        ],
        correctAnswerIndex: 0,
        explanation: "දත්ත සමූහයක සෑම අයිතමයක්ම 'එක් වරක් පමණක්' පරිශීලනය කිරීමට අවශ්‍ය විට, පුනරාවෘත්ති ව්‍යුහයක් අවශ්‍ය නොවනු ඇත. ඒ සඳහා සරල අනුක්‍රමික ප්‍රවේශයක් හෝ සෘජු දත්ත ප්‍රවේශයක් (උදා: array index මගින්) ප්‍රමාණවත් වේ. පුනරාවෘත්ති ව්‍යුහයන් වඩාත් කාර්යක්ෂම වන්නේ නැවත නැවත ක්‍රියා කිරීමට අවශ්‍ය අවස්ථාවලදීය."
    },
    {
        questionText: "ක්‍රමලේඛයක පාලන ව්‍යුහ නිවැරදිව භාවිත කිරීමේදී ලැබෙන ප්‍රධානතම වාසිය කුමක්ද?",
        options: [
            "කේතයේ කියවීමේ හැකියාව සහ නඩත්තුව පහසු කිරීම.",
            "ක්‍රමලේඛයේ ක්‍රියාත්මක වීමේ වේගය වැඩි කිරීම.",
            "දත්ත ගබඩා කිරීමේ කාර්යක්ෂමතාව වැඩි කිරීම.",
            "දත්ත සමුදායට සම්බන්ධ වීමේ පහසුව.",
            "පරිශීලක අතුරු මුහුණතේ සුන්දරත්වය වැඩි කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "පාලන ව්‍යුහ නිවැරදිව භාවිතා කිරීමෙන් කේතයේ තාර්කික ප්‍රවාහය (logical flow) පැහැදිලි වන අතර, එය කේතය කියවීමට (readability) සහ පසුව නඩත්තු කිරීමට (maintainability) බෙහෙවින් උපකාරී වේ. ක්‍රියාත්මක වීමේ වේගය, දත්ත ගබඩාව හෝ පරිශීලක අතුරු මුහුණත වැඩි දියුණු කිරීම පාලන ව්‍යුහවල සෘජු වාසි නොවේ."
    },

    // 9.9: ක්‍රමලේඛනයේ දී උප ක්‍රමලේඛ (subprograms) භාවිත කරයි. (Subprograms/Functions)
    {
        questionText: "ක්‍රමලේඛනයකදී ශ්‍රූතියක (function) ප්‍රධාන අරමුණ කුමක්ද?",
        options: [
            "නැවත භාවිත කළ හැකි (reusable) කේත කොටස් නිර්මාණය කිරීම.",
            "දත්ත ගබඩා කිරීම සඳහා ව්‍යුහයක් සැපයීම.",
            "ක්‍රමලේඛයේ ප්‍රධාන විධානයන් අනුපිළිවෙලට ක්‍රියාත්මක කිරීම.",
            "දත්ත සමුදායකට සම්බන්ධ වීම සඳහා.",
            "පරිශීලක අතුරු මුහුණත නිර්මාණය කිරීම සඳහා."
        ],
        correctAnswerIndex: 0,
        explanation: "ශ්‍රූතිවල ප්‍රධාන අරමුණ වන්නේ යම් නිශ්චිත කාර්යයක් ඉටු කරන, නැවත නැවත භාවිත කළ හැකි කේත කොටස් නිර්මාණය කිරීමයි. මෙය කේතය සංවිධානය කිරීමට, කේත පුනරාවර්තනය අඩු කිරීමට සහ ක්‍රමලේඛයේ නඩත්තුව පහසු කිරීමට උපකාරී වේ. අනෙකුත් විකල්ප ශ්‍රූතිවල සෘජු අරමුණට සම්බන්ධ නොවේ."
    },
    {
        questionText: "පහත ශ්‍රූති වර්ග දෙකෙන්, 'Math.sqrt()' වැනි ශ්‍රූතියක් කුමන වර්ගයට අයත් වන්නේද සහ එහි ලක්ෂණය කුමක්ද?",
        options: [
            "තූළබැඳි (Built-in) - ක්‍රමලේඛන භාෂාව සමඟම ලැබෙන, පූර්ව-නිර්වචනය කළ ශ්‍රූතියකි.",
            "පරිශීලක නිර්වාත (User-defined) - පරිශීලකයා විසින් තමන්ගේ අවශ්‍යතා සඳහා නිර්මාණය කරන ලද්දකි.",
            "ප්‍රතිආගමන (Return) - අගයක් ආපසු ලබා දෙන ශ්‍රූතියකි.",
            "පරාමිතික (Parametric) - පරාමිති ලබා ගන්නා ශ්‍රූතියකි.",
            "ගෝලීය (Global) - ඕනෑම තැනක සිට ප්‍රවේශ විය හැකි ශ්‍රූතියකි."
        ],
        correctAnswerIndex: 0,
        explanation: "Math.sqrt() යනු JavaScript වැනි ක්‍රමලේඛන භාෂා සමඟම පූර්ව-නිර්වචනය කර ලැබෙන 'තූළබැඳි' (Built-in) ශ්‍රූතියකි. පරිශීලක නිර්වාත ශ්‍රූති යනු ක්‍රමලේඛකයා විසින්ම නිර්මාණය කරන ඒවාය. අනෙකුත් විකල්ප ශ්‍රූතියක ක්‍රියාකාරීත්වයේ හෝ ප්‍රවේශයේ ස්වභාවය විස්තර කරනවා මිස එහි මූලික වර්ගීකරණයට අයත් නොවේ."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී ශ්‍රූතියකට (function) පරාමිති (parameters) යැවීමේ ප්‍රධාන වැදගත්කම කුමක්ද?",
        options: [
            "ශ්‍රූතියකට පිටතින් දත්ත ලබා ගැනීමට සහ විවිධ තත්වයන්ට අනුව එය ක්‍රියාත්මක කිරීමට.",
            "ශ්‍රූතියක් මගින් අගයක් ආපසු ලබා දීම සඳහා.",
            "ශ්‍රූතියක් ක්‍රියාත්මක කිරීමේ වේගය වැඩි කිරීමට.",
            "ශ්‍රූතියක නම අර්ථ දැක්වීම සඳහා.",
            "ශ්‍රූතියක් තුළ ගෝලීය විචල්‍යයන් නිර්මාණය කිරීම සඳහා."
        ],
        correctAnswerIndex: 0,
        explanation: "පරාමිති (parameters) යනු ශ්‍රූතියකට පිටතින් දත්ත යැවීමට භාවිතා කරන යාන්ත්‍රණයකි. මෙය ශ්‍රූතිය වඩාත් නම්‍යශීලී කරන අතර, විවිධ ආදාන දත්ත සමඟ එකම ශ්‍රූතිය නැවත නැවත භාවිත කිරීමට ඉඩ සලසයි. මෙය ශ්‍රූතියේ ප්‍රතිඵලය වෙනස් කිරීමට සෘජුවම බලපායි."
    },
    {
        questionText: "පහත ප්‍රකාශයන්ගෙන් විචල්‍ය පරාසය (scope of variables) සම්බන්ධයෙන් නිවැරදි ප්‍රකාශය කුමක්ද?",
        options: [
            "ශ්‍රූතියක් තුළ නිර්වචනය කරන ලද විචල්‍යයක් එහි පරාසය එම ශ්‍රූතියට පමණක් සීමා වේ.",
            "ගෝලීය විචල්‍යයන් ශ්‍රූතියක් තුළ පමණක් ප්‍රවේශ විය හැක.",
            "ස්ථානීය විචල්‍යයන් ක්‍රමලේඛයේ ඕනෑම තැනක සිට ප්‍රවේශ විය හැක.",
            "සියලුම විචල්‍යයන් ඒවා නිර්වචනය කළ වහාම ගෝලීය පරාසයක් ගනී.",
            "විචල්‍ය පරාසය තීරණය වන්නේ එහි දත්ත වර්ගය අනුවය."
        ],
        correctAnswerIndex: 0,
        explanation: "ශ්‍රූතියක් තුළ නිර්වචනය කරන ලද විචල්‍යයන් 'ස්ථානීය' (local) විචල්‍යයන් වන අතර, ඒවායේ පරාසය (scope) එම ශ්‍රූතියට පමණක් සීමා වේ. ශ්‍රූතියෙන් පිටත සිට ඒවාට ප්‍රවේශ විය නොහැක. ගෝලීය විචල්‍යයන් ක්‍රමලේඛයේ ඕනෑම තැනක සිට ප්‍රවේශ විය හැක. අනෙකුත් ප්‍රකාශ වැරදි වේ."
    },
    {
        questionText: "යම්කිසි ශ්‍රූතියක් (function) ක්‍රියාත්මක වීමෙන් පසු යම් අගයක් ආපසු (return) ලබා දීමේ අවශ්‍යතාවය පැන නගිනුයේ කුමන අවස්ථාවකදීද?",
        options: [
            "ශ්‍රූතියේ ගණනය කිරීම් හෝ සැකසීම්වල ප්‍රතිඵලය වෙනත් කේත කොටසකට භාවිතා කිරීමට අවශ්‍ය වූ විට.",
            "ශ්‍රූතිය තුළ ගෝලීය විචල්‍යයක් වෙනස් කිරීමට අවශ්‍ය වූ විට.",
            "ශ්‍රූතියකට පරාමිති යැවීමට අවශ්‍ය වූ විට.",
            "ශ්‍රූතියක් ස්වයංක්‍රීයව ක්‍රියාත්මක වීමට සලස්වන විට.",
            "ශ්‍රූතියක් තුළදී පමණක් තාවකාලික විචල්‍යයන් භාවිතා කිරීමට අවශ්‍ය වූ විට."
        ],
        correctAnswerIndex: 0,
        explanation: "'return' අගයක අවශ්‍යතාවය පැන නගින්නේ ශ්‍රූතියක් මගින් යම් ගණනය කිරීමක් හෝ සැකසීමක් සිදු කර එහි ප්‍රතිඵලය ශ්‍රූතිය කැඳවූ ස්ථානයට ආපසු ලබා දීමට අවශ්‍ය වූ විටයි. මෙය එම ප්‍රතිඵලය තවදුරටත් වෙනත් මෙහෙයුම් සඳහා භාවිතා කිරීමට ඉඩ සලසයි. අනෙකුත් විකල්ප 'return' අගයෙහි මූලික අරමුණ නොවේ."
    },
    {
        questionText: "පහත JavaScript කේතයෙහි ප්‍රතිදානය (output) කුමක්ද? \n\n```javascript\nlet globalVar = 5;\nfunction modifyVar(localVal) {\n    localVal = localVal + 10;\n    globalVar = globalVar + 1; \n    console.log('තුළත:', localVal);\n}\nmodifyVar(globalVar);\nconsole.log('පිටත:', globalVar);\n```",
        options: [
            "තුළත: 15\nපිටත: 6",
            "තුළත: 5\nපිටත: 5",
            "තුළත: 16\nපිටත: 16",
            "තුළත: 6\nපිටත: 6",
            "දෝෂයක් (Error) - localVal ශ්‍රූතියෙන් පිටත ප්‍රවේශ විය නොහැක."
        ],
        correctAnswerIndex: 0,
        explanation: "modifyVar ශ්‍රූතියට globalVar හි අගය (5) 'localVal' ලෙස පරාමිතියක් ලෙස යැවේ. ශ්‍රූතිය තුළ localVal (5) 10 කින් වැඩි වී 15 වේ. නමුත් මෙය පිටත ඇති globalVar ට බලපාන්නේ නැත. කෙසේ වෙතත්, globalVar 'ගෝලීය' විචල්‍යයක් වන බැවින්, ශ්‍රූතිය තුළ 'globalVar = globalVar + 1' මගින් එහි අගය 5 සිට 6 දක්වා වෙනස් වේ. එමනිසා, 'තුළත: 15' මුද්‍රණය වන අතර, ශ්‍රූතියෙන් පිටත 'පිටත: 6' ලෙස මුද්‍රණය වේ."
    },
    {
        questionText: "පහත ප්‍රකාශයන්ගෙන් ශ්‍රූතියක පෙරනිමි අගයන් (default values) භාවිතය පිළිබඳව වඩාත් නිවැරදි විස්තරය කුමක්ද?",
        options: [
            "පරාමිතියක් සඳහා අගයක් ලබා දී නොමැති විට එම පරාමිතියට ස්වයංක්‍රීයව අගයක් ලබා දීම.",
            "ශ්‍රූතියක් ක්‍රියාත්මක වීමට පෙර විචල්‍යයන්ට මූලික අගයන් ලබා දීම.",
            "ශ්‍රූතියක ප්‍රතිලාභ අගය (return value) සඳහා පෙරනිමි අගයක් සැපයීම.",
            "ශ්‍රූතියක් තුළ ගෝලීය විචල්‍යයන් නිර්මාණය කිරීම සඳහා.",
            "ශ්‍රූතියක දෝෂ පාලනය කිරීම සඳහා."
        ],
        correctAnswerIndex: 0,
        explanation: "ශ්‍රූතියක 'පෙරනිමි අගයන්' (default values) යනු, ශ්‍රූතිය කැඳවන විට යම් පරාමිතියක් (parameter) සඳහා අගයක් ලබා දී නොමැති නම්, එම පරාමිතියට ස්වයංක්‍රීයව පවරන අගයන්ය. මෙය ශ්‍රූති කැඳවීම වඩාත් නම්‍යශීලී කරන අතර, යම් පරාමිති අනිවාර්ය නොවන විට ප්‍රයෝජනවත් වේ."
    },

    // 9.10: ක්‍රමලේඛවල දී දත්ත ව්‍යුහ යොදා ගනී. (Data Structures)
    {
        questionText: "ශිෂ්‍යයෙකුගේ නම ('ප්‍රියන්ත') සහ ලකුණු ('85', '72', '90') වැනි විවිධ වර්ගවල දත්ත එකට කාර්යක්ෂමව ගබඩා කර හැසිරවීමට වඩාත් සුදුසු දත්ත ව්‍යුහය කුමක්ද?",
        options: [
            "ශබ්දකෝෂය (Dictionary)",
            "ලැයිස්තුව (List)",
            "තන්තු (String)",
            "ටියුප්ල (Tuple)",
            "අරේ (Array)"
        ],
        correctAnswerIndex: 0,
        explanation: "'ශබ්දකෝෂය' (Dictionary) යනු යතුරු-අගය යුගල (key-value pairs) ලෙස දත්ත ගබඩා කරන දත්ත ව්‍යුහයකි. මෙය ශිෂ්‍ය නම 'නම' යන යතුරටත්, ලකුණු 'ලකුණු' යන යතුරට අදාළ ලැයිස්තුවක් ලෙසත් ගබඩා කිරීමට ඉඩ සලසයි. මෙය විවිධ වර්ගවල දත්ත තේරුම් ගත හැකි ආකාරයට සම්බන්ධ කර ගබඩා කිරීමට වඩාත් සුදුසුය. ලැයිස්තු, තන්තු, ටියුප්ල යනු තනි අගයන් සමූහයක් ගබඩා කිරීමට භාවිතා වන අතර, අරේ යනු ලැයිස්තු වලට සමාන වේ."
    },
    {
        questionText: "පහත දත්ත ව්‍යුහයන්ගෙන් වෙනස් කළ නොහැකි (immutable) දත්ත ව්‍යුහයක් ලෙස සලකනු ලබන්නේ කුමක්ද?",
        options: [
            "ටියුප්ල (Tuple)",
            "ලැයිස්තුව (List)",
            "ශබ්දකෝෂය (Dictionary)",
            "තන්තු (String)",
            "අරේ (Array)"
        ],
        correctAnswerIndex: 0,
        explanation: "'ටියුප්ල' (Tuple) යනු නිර්මාණය කළ පසු එහි අඩංගු දත්ත වෙනස් කළ නොහැකි (immutable) දත්ත ව්‍යුහයකි. ලැයිස්තු (Lists) සහ ශබ්දකෝෂ (Dictionaries) වෙනස් කළ හැකි (mutable) වේ. තන්තු (Strings) ද වෙනස් කළ නොහැකි වුවද, ටියුප්ල විවිධ වර්ගවල දත්ත සමූහයක් ගබඩා කිරීමට බහුලව භාවිතා වේ. අරේ යනු ලැයිස්තු වලට සමාන වේ."
    },
    {
        questionText: "අකාරාදී පිළිවෙලට ගබඩා කර ඇති නම් ලැයිස්තුවක් (e.g., ['අනේරූ', 'බුද්ධික', 'චාමර']) නඩත්තු කිරීමට අවශ්‍ය නම්, දත්ත එකතු කිරීම, ඉවත් කිරීම සහ නවීකරණය කිරීම නිතර සිදුවන විට වඩාත් සුදුසු දත්ත ව්‍යුහය කුමක්ද?",
        options: [
            "ලැයිස්තුව (List)",
            "ටියුප්ල (Tuple)",
            "තන්තු (String)",
            "ශබ්දකෝෂය (Dictionary)",
            "සැකසීම (Set)"
        ],
        correctAnswerIndex: 0,
        explanation: "'ලැයිස්තුව' (List) යනු විවිධ වර්ගවල දත්ත අනුපිළිවෙලකට ගබඩා කළ හැකි සහ වෙනස් කළ හැකි (mutable) දත්ත ව්‍යුහයකි. දත්ත එකතු කිරීම, ඉවත් කිරීම, නවීකරණය කිරීම වැනි මෙහෙයුම් නිතර සිදුවන විට ලැයිස්තු ඉතා කාර්යක්ෂම වේ. ටියුප්ල වෙනස් කළ නොහැකි අතර, තන්තු එක් අගයක් පමණක් නියෝජනය කරයි. ශබ්දකෝෂය යතුරු-අගය යුගල සඳහා වඩාත් සුදුසුය."
    },
    {
        questionText: "පහත ප්‍රකාශයන්ගෙන් දත්ත ව්‍යුහ භාවිතය පිළිබඳව වඩාත් නිවැරදි නොවන ප්‍රකාශය කුමක්ද?",
        options: [
            "Strings යනු වෙනස් කළ නොහැකි අක්ෂර අනුපිළිවෙලකි.",
            "Lists තුළ විවිධ දත්ත වර්ගවල අයිතම අඩංගු විය හැක.",
            "Tuples, Lists වලට සමාන වුවද, ඒවායේ අන්තර්ගතය වෙනස් කළ හැක.",
            "Dictionaries, key-value යුගල ලෙස දත්ත ගබඩා කරයි.",
            "දත්ත ව්‍යුහයන් මගින් දත්ත කාර්යක්ෂමව සංවිධානය කිරීමට සහ ප්‍රවේශ වීමට උපකාරී වේ."
        ],
        correctAnswerIndex: 2,
        explanation: "Tuples, Lists වලට සමාන වුවද, ඒවායේ අන්තර්ගතය 'වෙනස් කළ නොහැක'. මෙය ඒවායේ ප්‍රධාන ලක්ෂණයකි. Lists යනු වෙනස් කළ හැකි දත්ත ව්‍යුහයකි. අනෙකුත් ප්‍රකාශ සියල්ල නිවැරදි වේ."
    },
    {
        questionText: "යම්කිසි භාණ්ඩයක නම, කේතය සහ මිල වැනි ගුණාංග සමූහයක් තනි ඒකකයක් ලෙස ගබඩා කිරීමට අවශ්‍ය නම්, එම භාණ්ඩය නිරූපණය කිරීමට වඩාත් සුදුසු දත්ත ව්‍යුහය කුමක්ද?",
        options: [
            "ශබ්දකෝෂය (Dictionary)",
            "ලැයිස්තුව (List)",
            "තන්තු (String)",
            "ටියුප්ල (Tuple)",
            "කට්ටල (Set)"
        ],
        correctAnswerIndex: 0,
        explanation: "යම් භාණ්ඩයක විවිධ ගුණාංග (නම, කේතය, මිල) ඒවායේ අර්ථවත් යතුරු (keys) සමඟ සම්බන්ධ කර ගබඩා කිරීමට 'ශබ්දකෝෂය' (Dictionary) වඩාත් සුදුසුය. උදාහරණයක් ලෙස: {'නම': 'පෑන', 'කේතය': 'P001', 'මිල': 50}. ලැයිස්තු සහ ටියුප්ල අනුපිළිවෙලක් මත පදනම් වන අතර, තන්තු තනි අක්ෂර අනුපිළිවෙලකි."
    },

    // 9.11: ක්‍රමලේඛවල දී ගොනු සහ දත්ත සමුදාය හසුරුවයි. (File Handling)
    {
        questionText: "ක්‍රමලේඛනයකදී ගොනුවක් 'කියවීම' (reading) සඳහා විවෘත කිරීමේදී සිදුවන ප්‍රධානතම දෙය කුමක්ද?",
        options: [
            "ගොනුවේ අන්තර්ගතය මතකයට (memory) පටවනු ලැබේ.",
            "ගොනුවට අලුතින් දත්ත ලිවීමට අවස්ථාව ලැබේ.",
            "පවතින ගොනුව මැකී යයි.",
            "නව ගොනුවක් එම නමින් නිර්මාණය වේ.",
            "ගොනුවට ප්‍රවේශ වීම සීමා වේ."
        ],
        correctAnswerIndex: 0,
        explanation: "ගොනුවක් කියවීම (read mode) සඳහා විවෘත කිරීමේදී, ගොනුවේ අන්තර්ගතය ක්‍රමලේඛයට ප්‍රවේශ වීමට හැකිවන පරිදි මතකයට පටවනු ලැබේ. මෙමගින් ගොනුවේ දත්ත පසුව සැකසීම සඳහා භාවිතා කළ හැක. ලිවීම, මැකීම හෝ නව ගොනු නිර්මාණය කිරීම 'කියවීමේ' මෙහෙයුමට අදාළ නොවේ."
    },
    {
        questionText: "ක්‍රමලේඛයක් මගින් 'text.txt' නම් ගොනුවකට දත්ත 'ලියවීමෙන්' (writing) පසු, එම දත්ත ස්ථිරවම ගොනුවේ සුරැකීමට අනිවාර්යයෙන්ම සිදු කළ යුතු මෙහෙයුම කුමක්ද?",
        options: [
            "ගොනුව වසා දැමීම (Closing the file)",
            "ගොනුව නැවත විවෘත කිරීම (Re-opening the file)",
            "ගොනුව කියවීම (Reading the file)",
            "ගොනුව මැකීම (Deleting the file)",
            "ගොනුවට තවදුරටත් දත්ත එකතු කිරීම (Appending data)"
        ],
        correctAnswerIndex: 0,
        explanation: "ගොනුවකට දත්ත ලිවීමෙන් පසු, 'ගොනුව වසා දැමීම' (Closing the file) අත්‍යවශ්‍ය වේ. මෙය සිදු නොකළහොත්, ලියන ලද දත්ත බෆරයේ (buffer) රැඳී සිටිය හැකි අතර, ගොනුවේ ස්ථිරවම සුරැකීම සිදු නොවිය හැක. ගොනුව වැසීමෙන්, සියලුම බෆරගත දත්ත ගොනුවට ලියවී සම්පත් නිදහස් වේ."
    },
    {
        questionText: "ක්‍රමලේඛයක් මගින් ගොනුවක් සමඟ වැඩ කරන විට, 'ගොනුව සොයා ගැනීමට නොහැකි වීම' හෝ 'ප්‍රවේශ අවසර නොමැති වීම' වැනි දෝෂ තත්වයන් කළමනාකරණය කිරීමට භාවිතා කළ හැකි ක්‍රමවේදය කුමක්ද?",
        options: [
            "දෝෂ කළමනාකරණය (Exception Handling - try-catch blocks)",
            "පාලන ව්‍යුහ (Control Structures)",
            "දත්ත ව්‍යුහ (Data Structures)",
            "උප ක්‍රමලේඛ (Subprograms)",
            "පුනරාවෘත්ති ව්‍යුහ (Repetition Structures)"
        ],
        correctAnswerIndex: 0,
        explanation: "ගොනු මෙහෙයුම් වලදී ඇතිවිය හැකි 'ගොනු සොයා ගැනීමට නොහැකි වීම' (file not found) හෝ 'ප්‍රවේශ අවසර නොමැති වීම' (permission denied) වැනි අනපේක්ෂිත දෝෂ තත්වයන් කළමනාකරණය කිරීම සඳහා 'දෝෂ කළමනාකරණය' (Exception Handling), එනම් try-catch blocks වැනි යාන්ත්‍රණ භාවිතා කෙරේ. මෙය ක්‍රමලේඛය බිඳ වැටීමකින් තොරව දෝෂ තත්වය සුමටව හැසිරවීමට ඉඩ සලසයි."
    },
    {
        questionText: "පහත ප්‍රකාශයන්ගෙන් ගොනු හැසිරවීම (File Handling) පිළිබඳව නිවැරදි නොවන ප්‍රකාශය කුමක්ද?",
        options: [
            "ගොනුවක් විවෘත කිරීමේදී එයට ලිවීමට හෝ කියවීමට අවශ්‍ය ආකාරය පැහැදිලි කළ යුතුය.",
            "ගොනුවක් වසා දැමීමෙන් පසු එයට ප්‍රවේශ විය නොහැක.",
            "පවතින ගොනුවක් 'ලියවීමේ' (write mode) ආකාරයෙන් විවෘත කළ විට එහි පෙර අන්තර්ගතය මැකී යයි.",
            "ගොනුවක අන්තර්ගතයට පිටුපසින් දත්ත එකතු කිරීමට 'read' ආකාරය භාවිතා කළ හැක.",
            "ගොනු මෙහෙයුම් වලදී I/O දෝෂ ඇතිවිය හැක."
        ],
        correctAnswerIndex: 3,
        explanation: "ගොනුවක අන්තර්ගතයට 'පිටුපසින්' දත්ත එකතු කිරීමට 'append' (එකතු කිරීමේ) ආකාරය භාවිතා කළ යුතු අතර, 'read' ආකාරය භාවිතා කළ නොහැක. 'read' ආකාරය භාවිතා කරන්නේ ගොනුවක අන්තර්ගතය කියවීමට පමණි. අනෙකුත් ප්‍රකාශ නිවැරදි වේ."
    },

    // 9.12: දත්ත සමුදායක දත්ත කළමනාකරණය කරයි. (Database Data Management)
    {
        questionText: "දත්ත සමුදායකට සම්බන්ධ වීමේදී (connecting to a database) ප්‍රධාන වශයෙන් අවශ්‍ය වන තොරතුරු අතරට අයත් නොවන කරුණ කුමක්ද?",
        options: [
            "දත්ත සමුදායේ නම (Database name)",
            "පරිශීලක අතුරු මුහුණතේ වර්ණය (User interface color scheme)",
            "සම්බන්ධතා සත්කාරකයේ IP ලිපිනය හෝ නම (Host IP address or name)",
            "පරිශීලක නාමය (Username)",
            "මුරපදය (Password)"
        ],
        correctAnswerIndex: 1,
        explanation: "දත්ත සමුදායකට සම්බන්ධ වීමේදී, දත්ත සමුදායේ නම, සත්කාරකයේ IP ලිපිනය/නම, පරිශීලක නාමය සහ මුරපදය අත්‍යවශ්‍ය තොරතුරු වේ. පරිශීලක අතුරු මුහුණතේ වර්ණය දත්ත සමුදා සම්බන්ධතාවයට සෘජුවම සම්බන්ධ නැත."
    },
    {
        questionText: "SQL ප්‍රකාශයක් භාවිතයෙන් දත්ත සමුදායකින් නිශ්චිත වාර්තා සමූහයක් (records) 'සොයා ගැනීම' හෝ 'ලබා ගැනීම' (retrieve) සඳහා භාවිතා කරන ප්‍රධාන විධානය කුමක්ද?",
        options: [
            "SELECT",
            "INSERT",
            "UPDATE",
            "DELETE",
            "CREATE"
        ],
        correctAnswerIndex: 0,
        explanation: "දත්ත සමුදායකින් දත්ත 'සොයා ගැනීමට' හෝ 'ලබා ගැනීමට' (retrieve) භාවිතා කරන ප්‍රධාන SQL විධානය 'SELECT' වේ. INSERT නව දත්ත එකතු කිරීමටත්, UPDATE පවතින දත්ත වෙනස් කිරීමටත්, DELETE දත්ත මැකීමටත්, CREATE දත්ත සමුදා වස්තු නිර්මාණය කිරීමටත් භාවිතා වේ."
    },
    {
        questionText: "දත්ත සමුදායක පවතින ශිෂ්‍යයෙකුගේ ලිපිනය 'ගාල්ල' සිට 'මාතර' ලෙස 'නවීකරණය' (modify) කිරීමට අවශ්‍ය නම්, ඒ සඳහා භාවිතා කළ යුතු SQL විධානය කුමක්ද?",
        options: [
            "UPDATE Students SET Address = 'මාතර' WHERE Name = 'ශිෂ්‍යයාගේ නම';",
            "INSERT INTO Students (Address) VALUES ('මාතර') WHERE Name = 'ශිෂ්‍යයාගේ නම';",
            "DELETE FROM Students WHERE Name = 'ශිෂ්‍යයාගේ නම';",
            "SELECT * FROM Students WHERE Name = 'ශිෂ්‍යයාගේ නම';",
            "ALTER TABLE Students ADD Address = 'මාතර';"
        ],
        correctAnswerIndex: 0,
        explanation: "දත්ත සමුදායක පවතින දත්ත 'නවීකරණය' (modify) කිරීම සඳහා 'UPDATE' SQL විධානය භාවිතා වේ. නිවැරදි වාර්තාව තෝරා ගැනීමට 'WHERE' කොන්දේසියක් අත්‍යවශ්‍ය වේ. INSERT නව දත්ත ඇතුළු කිරීමටත්, DELETE දත්ත මැකීමටත්, SELECT දත්ත ලබා ගැනීමටත් භාවිතා වේ. ALTER TABLE වගු වල ව්‍යුහය වෙනස් කිරීමට යොදා ගැනේ."
    },
    {
        questionText: "යම් දත්ත සමුදායකින් සියලුම දත්ත 'මැකීම' (delete) සඳහා භාවිතා කළ හැකි වඩාත් කාර්යක්ෂම සහ නිවැරදි SQL ප්‍රකාශය කුමක්ද, නමුත් වගුවේ ව්‍යුහය නොවෙනස්ව තබා ගත යුතුය?",
        options: [
            "DELETE FROM Students;",
            "DROP TABLE Students;",
            "REMOVE Students;",
            "TRUNCATE TABLE Students;",
            "ERASE Students;"
        ],
        correctAnswerIndex: 3,
        explanation: "දත්ත සමුදායක වගුවකින් සියලුම වාර්තා 'මැකීම' සඳහා 'TRUNCATE TABLE' විධානය වඩාත් කාර්යක්ෂම වේ, විශේෂයෙන් විශාල දත්ත ප්‍රමාණයක් ඇති විට. මෙය වගුවේ ව්‍යුහය (schema) නොවෙනස්ව තබා ගනිමින් සියලු දත්ත ඉක්මනින් ඉවත් කරයි. 'DELETE FROM Students;' මගින්ද සියලු දත්ත මැකේ, නමුත් එය TRUNCATE තරම් කාර්යක්ෂම නැත. 'DROP TABLE' මගින් වගුව සම්පූර්ණයෙන්ම මැකේ."
    },
    {
        questionText: "පහත ප්‍රකාශයන්ගෙන් දත්ත සමුදා කළමනාකරණය (Database Management) පිළිබඳව නිවැරදි නොවන ප්‍රකාශය කුමක්ද?",
        options: [
            "දත්ත සමුදා කළමනාකරණ පද්ධතියක් (DBMS) මඟින් දත්ත ගබඩා කිරීම, ප්‍රතිසාධනය සහ කළමනාකරණය සිදු කරයි.",
            "SQL යනු දත්ත සමුදායන් සමඟ අන්තර් ක්‍රියා කිරීම සඳහා භාවිතා කරන සම්මත භාෂාවකි.",
            "දත්ත සමුදායකට දත්ත එකතු කිරීමට 'DELETE' ප්‍රකාශය භාවිතා කරයි.",
            "දත්ත සමුදායක දත්ත යාවත්කාලීන කිරීම සඳහා 'UPDATE' ප්‍රකාශය භාවිතා කරයි.",
            "ක්‍රමලේඛන භාෂා මඟින් දත්ත සමුදායන්ට සම්බන්ධ වී දත්ත හැසිරවිය හැක."
        ],
        correctAnswerIndex: 2,
        explanation: "දත්ත සමුදායකට දත්ත 'එකතු කිරීමට' භාවිතා කරනුයේ 'INSERT' ප්‍රකාශය මිස 'DELETE' ප්‍රකාශය නොවේ. DELETE ප්‍රකාශය භාවිතා කරනුයේ දත්ත මැකීම සඳහාය. අනෙකුත් ප්‍රකාශ සියල්ල නිවැරදි වේ."
    },

    // 9.13: දත්ත සොයා තෝරයි (Searching and Sorting Data)
    {
        questionText: "නොපිළිවෙලට (unsorted) ඇති දත්ත සමූහයකින් නිශ්චිත අගයක් සොයා ගැනීමට වඩාත් සුදුසු සෙවුම් ශිල්ප ක්‍රමය කුමක්ද?",
        options: [
            "අනුක්‍රමික සෙවුම (Sequential Search)",
            "ද්විමය සෙවුම (Binary Search)",
            "කඩිනම් සෙවුම (Quick Search)",
            "දර්ශක සෙවුම (Index Search)",
            "හැෂිං සෙවුම (Hashing Search)"
        ],
        correctAnswerIndex: 0,
        explanation: "'අනුක්‍රමික සෙවුම' (Sequential Search) යනු නොපිළිවෙලට හෝ පිළිවෙලට ඇති දත්ත සමූහයක සෑම අයිතමයක්ම ආරම්භයේ සිට අවසානය දක්වා එකින් එක පරීක්ෂා කරමින්, අවශ්‍ය අගය සොයා ගන්නා තෙක් ඉදිරියට යන සෙවුම් ශිල්ප ක්‍රමයකි. දත්ත පිළිවෙලට නොමැති විට මෙය අනිවාර්යයෙන්ම භාවිතා කළ යුතුය. ද්විමය සෙවුම වැනි අනෙකුත් සෙවුම් ශිල්ප ක්‍රම සඳහා දත්ත පිළිවෙලට තිබීම අත්‍යවශ්‍ය වේ."
    },
    {
        questionText: "අනුක්‍රමික සෙවුම් ශිල්ප ක්‍රමය (Sequential Search) පිළිබඳ පහත ප්‍රකාශයන්ගෙන් නිවැරදි ප්‍රකාශය කුමක්ද?",
        options: [
            "මෙය ඕනෑම පිළිවෙලකට ඇති දත්ත සමූහයක් සඳහා යෙදිය හැක.",
            "මෙය ක්‍රියාත්මක වීමට දත්ත සමූහය අනිවාර්යයෙන්ම පිළිවෙලට තිබිය යුතුය.",
            "විශාල දත්ත සමූහයක් සඳහා මෙය ඉතා කාර්යක්ෂම සෙවුම් ක්‍රමයකි.",
            "මෙය සෑම විටම ද්විමය සෙවුමට වඩා වේගවත්ය.",
            "මෙය Hash table ව්‍යුහයන් මත පදනම් වේ."
        ],
        correctAnswerIndex: 0,
        explanation: "අනුක්‍රමික සෙවුම ඕනෑම පිළිවෙලකට (sorted or unsorted) ඇති දත්ත සමූහයක් සඳහා යෙදිය හැකි සරල සෙවුම් ශිල්ප ක්‍රමයකි. නමුත් විශාල දත්ත සමූහයක් සඳහා එය කාර්යක්ෂම නොවන අතර, දත්ත පිළිවෙලට ඇති විට ද්විමය සෙවුම වැනි ක්‍රම වඩා වේගවත් වේ."
    },
    {
        questionText: "සංඛ්‍යා සමූහයක් (e.g., [5, 2, 8, 1, 9]) කුඩාම අගයේ සිට විශාලතම අගය දක්වා (ආරෝහණ පිළිවෙලට - ascending order) 'තේරීම' (sorting) සඳහා භාවිතා කළ හැකි සරලම තේරීම් ශිල්ප ක්‍රමය කුමක්ද?",
        options: [
            "බුබුළු තේරීම (Bubble Sort)",
            "මර්ජ් තේරීම (Merge Sort)",
            "ඉන්සර්ෂන් තේරීම (Insertion Sort)",
            "ක්වික් තේරීම (Quick Sort)",
            "සිලෙක්ෂන් තේරීම (Selection Sort)"
        ],
        correctAnswerIndex: 0,
        explanation: "'බුබුළු තේරීම' (Bubble Sort) යනු සංඛ්‍යා සමූහයක් හෝ දත්ත සමූහයක් කුඩාම අගයේ සිට විශාලතම අගය දක්වා හෝ අනෙක් අතට තේරීම සඳහා භාවිතා කරන සරලම තේරීම් ශිල්ප ක්‍රමයකි. එහිදී යාබද අගයන් යුගල වශයෙන් සසඳා, අවශ්‍ය පරිදි මාරු කරමින් දත්ත ක්‍රමානුකූලව පෙළ ගස්වනු ලැබේ. මෙය තේරුම් ගැනීමට සහ ක්‍රියාත්මක කිරීමට පහසු වුවද, විශාල දත්ත සමූහ සඳහා එතරම් කාර්යක්ෂම නොවේ."
    },
    {
        questionText: "පහත ප්‍රකාශයන්ගෙන් බුබුළු තේරීම් ශිල්ප ක්‍රමය (Bubble Sort) පිළිබඳව නිවැරදි නොවන ප්‍රකාශය කුමක්ද?",
        options: [
            "මෙය දත්ත සමූහයක් වර්ගීකරණය කිරීමේදී ඉතා කාර්යක්ෂම ඇල්ගොරිතමයකි.",
            "මෙය යාබද අංග යුගල වශයෙන් සංසන්දනය කිරීමෙන් ක්‍රියා කරයි.",
            "කුඩා දත්ත සමූහ සඳහා මෙය යෝග්‍ය වේ.",
            "එක් පුනරාවර්තනයකදී (pass) විශාලතම අගය නිවැරදි ස්ථානයට ගමන් කරයි.",
            "මෙය ස්ථාවර (stable) වර්ගීකරණ ඇල්ගොරිතමයකි."
        ],
        correctAnswerIndex: 0,
        explanation: "බුබුළු තේරීම (Bubble Sort) යනු දත්ත සමූහයක් වර්ගීකරණය කිරීමේදී 'ඉතා කාර්යක්ෂම ඇල්ගොරිතමයක් නොවේ'. එහි සංකීර්ණතාවය O(n^2) වන අතර, එය විශාල දත්ත සමූහ සඳහා ඉතා සෙමින් ක්‍රියාත්මක වේ. අනෙකුත් ප්‍රකාශ නිවැරදි වේ."
    },
    {
        questionText: "ඔබට 1 සිට 100 දක්වා අංක ඇතුළත්, නමුත් කිසිදු නිශ්චිත අනුපිළිවෙලක නොමැති විශාල අරේ එකකින් '57' යන අගය සොයා ගැනීමට අවශ්‍ය නම්, ඔබ භාවිතා කරන සෙවුම් ඇල්ගොරිතමය කුමක්ද?",
        options: [
            "අනුක්‍රමික සෙවුම (Sequential Search)",
            "ද්විමය සෙවුම (Binary Search)",
            "ජම්ප් සෙවුම (Jump Search)",
            "ඉන්ටර්පොලේෂන් සෙවුම (Interpolation Search)",
            "එකක්වත් නොවේ"
        ],
        correctAnswerIndex: 0,
        explanation: "අරේ එක කිසිදු නිශ්චිත අනුපිළිවෙලක (unsorted) නොමැති බැවින්, 'අනුක්‍රමික සෙවුම' (Sequential Search) පමණක් මෙහිදී භාවිතා කළ හැකිය. ද්විමය සෙවුම වැනි අනෙකුත් කාර්යක්ෂම සෙවුම් ඇල්ගොරිතම සඳහා දත්ත අනිවාර්යයෙන්ම පිළිවෙලට (sorted) තිබිය යුතුය. අනුක්‍රමික සෙවුමේදී, අවශ්‍ය අගය සොයා ගන්නා තෙක් සෑම අංගයක්ම එකින් එක පරීක්ෂා කරනු ලැබේ."
    },
    {
        questionText: "පහත සංඛ්‍යා අරේ එක බුබුළු තේරීම් (Bubble Sort) ඇල්ගොරිතමය භාවිතයෙන් ආරෝහණ පිළිවෙලට (ascending order) වර්ගීකරණය කිරීමේදී, පළමු 'pass' එක අවසානයේ අරේ එකේ තත්වය කුමක්ද? \n\nOriginal Array: [5, 1, 4, 2, 8]",
        options: [
            "[1, 4, 2, 5, 8]",
            "[1, 2, 4, 5, 8]",
            "[5, 1, 4, 2, 8]",
            "[1, 5, 4, 2, 8]",
            "[8, 5, 4, 2, 1]"
        ],
        correctAnswerIndex: 0,
        explanation: "බුබුළු තේරීමේ පළමු 'pass' එක අවසානයේ, විශාලතම අගය (8) අරේ එකේ අවසාන ස්ථානයට ගමන් කරයි. අනෙක් අගයන් ද එක් සංසන්දන වටයක් ක්‍රියාත්මක වීමෙන් යම්තාක් දුරට පිළිවෙලට සකස් වුවද, සම්පූර්ණ පිළිවෙලක් නොලැබේ. \n\nපළමු pass: \n1. (5, 1) -> [1, 5, 4, 2, 8] \n2. (5, 4) -> [1, 4, 5, 2, 8] \n3. (5, 2) -> [1, 4, 2, 5, 8] \n4. (5, 8) -> [1, 4, 2, 5, 8] \n\nඑබැවින්, නිවැරදි පිළිතුර [1, 4, 2, 5, 8] වේ."
    },

    // Additional questions to reach 30, distributed across sections for balance and depth
    // Back to 9.8 Control Structures (Total 7 + 3 = 10)
    {
        questionText: "ක්‍රමලේඛයක් තුළ 'while' ලූප් එකක් (loop) භාවිතා කිරීමේදී, ලූප් එක අනන්තව ක්‍රියාත්මක වීම වැලැක්වීම සඳහා අත්‍යවශ්‍ය කරුණ කුමක්ද?",
        options: [
            "ලූප් කොන්දේසිය තුළ වෙනස් වීමක් සිදුවන බව සහතික කිරීම.",
            "ලූප් එක තුළ 'break' ප්‍රකාශයක් ඇතුළත් කිරීම.",
            "ලූප් එක තුළ 'continue' ප්‍රකාශයක් භාවිතා කිරීම.",
            "ලූප් එකට පෙර විචල්‍යයන් සියල්ල ප්‍රාරම්භ කිරීම.",
            "ලූප් එක අවසානයේ 'return' ප්‍රකාශයක් භාවිතා කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "while ලූප් එකක් අනන්තව (infinite loop) ක්‍රියාත්මක වීම වැලැක්වීමට, ලූප් කොන්දේසිය යම් අවස්ථාවක අසත්‍ය (false) වන පරිදි ලූප් ශරීරය තුළ වෙනස් වීමක් සිදුවන බව සහතික කිරීම අත්‍යවශ්‍ය වේ. එසේ නොමැති නම්, කොන්දේසිය සැමවිටම සත්‍යව පවතින අතර ලූප් එක කිසිවිටෙකත් අවසන් නොවේ. 'break' මගින් ලූප් එකෙන් පිටවිය හැකි වුවද, මූලික නිවැරදි භාවිතය වන්නේ කොන්දේසියේ වෙනසක් ඇති කිරීමයි."
    },
    {
        questionText: "පහත කුමන අවස්ථාවකදී 'for' ලූප් එකක් (loop) භාවිතා කිරීම වඩාත් සුදුසු නොවේද?",
        options: [
            "යම්කිසි කොන්දේසියක් සත්‍ය වන තුරු පුනරාවර්තන අවශ්‍ය වන විට, පුනරාවර්තන ගණන කලින් නොදන්නා විට.",
            "නිශ්චිත වාර ගණනක් සඳහා පුනරාවර්තන අවශ්‍ය වන විට.",
            "අරේ එකක හෝ ලැයිස්තුවක සෑම අංගයක්ම හරහා ගමන් කිරීමට.",
            "පූර්ව නිර්වචනය කළ ආරම්භක, අවසන් සහ පියවර අගයන් සහිත පුනරාවර්තන සඳහා.",
            "සෑම පුනරාවර්තනයක් සමඟම ලූප් විචල්‍යයක් (loop variable) වෙනස් කිරීමට අවශ්‍ය විට."
        ],
        correctAnswerIndex: 0,
        explanation: "'for' ලූප් එකක් වඩාත් සුදුසු වන්නේ පුනරාවර්තන ගණන 'කලින් දන්නා' හෝ දත්ත සමූහයක දිග වැනි නිශ්චිත අගයක් මත පදනම් වන විටය. යම්කිසි කොන්දේසියක් සත්‍ය වන තුරු පුනරාවර්තන අවශ්‍ය වන විට, පුනරාවර්තන ගණන කලින් නොදන්නා අවස්ථාවන් සඳහා 'while' ලූප් එකක් වඩාත් සුදුසු වේ."
    },
    {
        questionText: "ක්‍රමලේඛයක තේරීම් ව්‍යුහ (Selection Structures) භාවිත කිරීමේදී, විවිධ තත්වයන් (multiple conditions) මත පදනම්ව විවිධ ක්‍රියා සිදු කිරීමට භාවිතා කළ හැකි ක්‍රමවේදය කුමක්ද?",
        options: [
            "if-else if-else දාමය (Ladder)",
            "සරල if ප්‍රකාශය (Simple if statement)",
            "අනුක්‍රමික ප්‍රකාශ (Sequential statements)",
            "while ලූප් එක (while loop)",
            "for ලූප් එක (for loop)"
        ],
        correctAnswerIndex: 0,
        explanation: "විවිධ තත්වයන් මත පදනම්ව විවිධ ක්‍රියා සිදු කිරීමට 'if-else if-else දාමය' (ladder) හෝ 'switch-case' ප්‍රකාශ භාවිතා වේ. සරල 'if' ප්‍රකාශයක් එක් කොන්දේසියක් සඳහා පමණක් වන අතර, ලූප් (loops) පුනරාවර්තන සඳහා යොදා ගැනේ."
    },

    // Back to 9.9 Subprograms (Total 7 + 2 = 9)
    {
        questionText: "පහත JavaScript කේත කොටසෙහි ප්‍රතිදානය කුමක්ද? \n\n```javascript\nfunction calculate(a, b) {\n    return a + b;\n}\nlet result = calculate(5, 3);\nconsole.log(result);\n```",
        options: [
            "8",
            "calculate(5, 3)",
            "result",
            "Undefined",
            "දෝෂයක් (Error)"
        ],
        correctAnswerIndex: 0,
        explanation: "calculate ශ්‍රූතිය a සහ b යන පරාමිති දෙක ලබාගෙන ඒවායේ එකතුව ආපසු ලබා දෙයි. calculate(5, 3) කැඳවන විට, 5 සහ 3 හි එකතුව (8) return වේ. මෙම අගය result විචල්‍යයට පැවරෙන අතර, console.log(result) මගින් 8 මුද්‍රණය වේ."
    },
    {
        questionText: "පහත කේත කොටසෙහි 'x' විචල්‍යයේ පරාසය (scope) පිළිබඳව නිවැරදි ප්‍රකාශය කුමක්ද? \n\n```javascript\nlet x = 10; // Line 1\nfunction myFunction() {\n    let y = 20; // Line 3\n    console.log(x); // Line 4\n}\nmyFunction();\nconsole.log(y); // Line 6\n```",
        options: [
            "x යනු ගෝලීය විචල්‍යයකි, එය ක්‍රමලේඛයේ ඕනෑම තැනක සිට ප්‍රවේශ විය හැක.",
            "x යනු ස්ථානීය විචල්‍යයකි, එය myFunction ශ්‍රූතිය තුළ පමණක් ප්‍රවේශ විය හැක.",
            "x යනු ගෝලීය විචල්‍යයකි, නමුත් එය myFunction ශ්‍රූතිය තුළ ප්‍රවේශ විය නොහැක.",
            "x යනු myFunction ශ්‍රූතියට පෙර පමණක් ප්‍රවේශ විය හැක.",
            "x සහ y යන දෙකම ගෝලීය විචල්‍යයන් වේ."
        ],
        correctAnswerIndex: 0,
        explanation: "Line 1 හි නිර්වචනය කර ඇති 'x' විචල්‍යය ගෝලීය පරාසයක් (global scope) ඇත. එබැවින් එය 'myFunction' ශ්‍රූතිය තුළ සිට (Line 4) මෙන්ම ශ්‍රූතියෙන් පිටත සිටද ප්‍රවේශ විය හැක. 'y' විචල්‍යය ස්ථානීය (local) වන අතර, එය Line 6 හි ප්‍රවේශ වීමට උත්සාහ කළහොත් දෝෂයක් ඇති වේ."
    },

    // Back to 9.10 Data Structures (Total 5 + 2 = 7)
    {
        questionText: "JSON වස්තුවක් (JavaScript Object) දත්ත ව්‍යුහයක් ලෙස සලකන විට, එය කුමන දත්ත ව්‍යුහයට වඩාත් සමීප වන්නේද?",
        options: [
            "ශබ්දකෝෂය (Dictionary)",
            "ලැයිස්තුව (List)",
            "තන්තු (String)",
            "ටියුප්ල (Tuple)",
            "කට්ටල (Set)"
        ],
        correctAnswerIndex: 0,
        explanation: "JSON වස්තූන් (JavaScript Objects) යතුරු-අගය යුගල (key-value pairs) ලෙස දත්ත ගබඩා කරයි. මෙම ව්‍යුහය 'ශබ්දකෝෂය' (Dictionary) යන දත්ත ව්‍යුහයට වඩාත් සමීප වේ, එය Python හි dictionary හෝ Java හි HashMap වැනි දත්ත ව්‍යුහයන්ට සමාන වේ. මේවා මඟින් යතුරක් භාවිතයෙන් අගයකට සෘජුවම ප්‍රවේශ වීමට ඉඩ සලසයි."
    },
    {
        questionText: "පහත කේත කොටසෙහි, `myList` යනු කුමන දත්ත ව්‍යුහ වර්ගයකට අයත් වන්නේද සහ එහි ප්‍රධාන ලක්ෂණය කුමක්ද? \n\n```javascript\nlet myList = ['apple', 10, true, 'banana'];\n```",
        options: [
            "ලැයිස්තුව (List) - වෙනස් කළ හැකි, අනුපිළිවෙලක් ඇති, විවිධ දත්ත වර්ග දැරිය හැකි ව්‍යුහයකි.",
            "තන්තු (String) - වෙනස් කළ නොහැකි අක්ෂර අනුපිළිවෙලකි.",
            "ටියුප්ල (Tuple) - වෙනස් කළ නොහැකි, අනුපිළිවෙලක් ඇති ව්‍යුහයකි.",
            "ශබ්දකෝෂය (Dictionary) - යතුරු-අගය යුගල ලෙස දත්ත ගබඩා කරයි.",
            "අරේ (Array) - එකම දත්ත වර්ගයේ අයිතම පමණක් දැරිය හැකි ව්‍යුහයකි."
        ],
        correctAnswerIndex: 0,
        explanation: "`myList` යනු JavaScript හි Array එකක් වන අතර, එය අනෙකුත් ක්‍රමලේඛන භාෂාවල 'ලැයිස්තුව' (List) යන සංකල්පයට අනුරූප වේ. ලැයිස්තු වෙනස් කළ හැකි (mutable), අනුපිළිවෙලක් (ordered) ඇති අතර, විවිධ දත්ත වර්ගවල (mixed data types) අයිතම දැරිය හැක. Array යනු JavaScript හි List එකක් වන අතර, එයට විවිධ දත්ත වර්ග දැරිය හැක."
    },

    // Back to 9.11 File Handling (Total 4 + 2 = 6)
    {
        questionText: "ගොනුවක අන්තර්ගතය 'යාවත්කාලීන' (update) කිරීමට අවශ්‍ය නම්, වඩාත් සුදුසු ගොනු මෙහෙයුම් සංයෝජනය කුමක්ද?",
        options: [
            "ගොනුව කියවා, වෙනස්කම් සිදු කර, නැවත ගොනුවට ලිවීම.",
            "ගොනුව මැකීම සහ නව ගොනුවක් නිර්මාණය කිරීම.",
            "ගොනුවට පිටුපසින් දත්ත එකතු කිරීම පමණක්.",
            "ගොනුව කියවීම පමණක්.",
            "ගොනුව වසා දැමීම පමණක්."
        ],
        correctAnswerIndex: 0,
        explanation: "ගොනුවක අන්තර්ගතය යාවත්කාලීන කිරීමට, පළමුව ගොනුවේ අන්තර්ගතය කියවා මතකයට ගත යුතුය. ඉන්පසු අවශ්‍ය වෙනස්කම් සිදු කර, අවසානයේදී වෙනස් කරන ලද දත්ත මුළුමනින්ම ගොනුවට නැවත ලිවිය යුතුය (හෝ අවශ්‍ය නම්, කොටස් වශයෙන්). මෙය පවතින දත්ත වෙනස් කිරීමේ සම්මත ක්‍රමවේදයයි."
    },
    {
        questionText: "ක්‍රමලේඛනයකදී 'CSV' ගොනුවක් (Comma Separated Values) කියවීම සඳහා මූලික වශයෙන් භාවිතා වන ක්‍රමවේදය කුමක්ද?",
        options: [
            "ගොනුව පේළි කිහිපයකට කියවා, එක් එක් පේළිය 'කොමා' මඟින් බෙදා දත්ත ලබා ගැනීම.",
            "ගොනුව 'read binary' ආකාරයෙන් විවෘත කිරීම.",
            "ගොනුවේ අන්තර්ගතය 'JSON' ලෙස පාරිසරික විචල්‍යයකට පටවා ගැනීම.",
            "ගොනුව සෘජුවම දත්ත සමුදායකට සම්බන්ධ කිරීම.",
            "ගොනුව 'append' ආකාරයෙන් විවෘත කිරීම."
        ],
        correctAnswerIndex: 0,
        explanation: "CSV ගොනුවක් යනු දත්ත 'කොමා' මඟින් වෙන් කරන ලද, පේළි ලෙස සකස් කරන ලද පෙළ ගොනුවකි. එය කියවීමට, ගොනුව පේළි කිහිපයකට (line by line) කියවා, එක් එක් පේළිය 'කොමා' (delimiter) මඟින් බෙදා (split) දත්ත තීරු (columns) අනුව ලබා ගැනීම සම්මත ක්‍රමවේදයයි."
    },

    // Back to 9.12 Database Management (Total 5 + 2 = 7)
    {
        questionText: "දත්ත සමුදායකට දත්ත 'එකතු කිරීමේදී' (add) 'INSERT INTO' SQL ප්‍රකාශය භාවිතා කරන විට, අනිවාර්යයෙන්ම සඳහන් කළ යුතු ප්‍රධාන අංගය කුමක්ද?",
        options: [
            "දත්ත ඇතුළු කරන වගුවේ නම (Table Name) සහ ඇතුළු කරන අගයන් (Values).",
            "දත්ත සමුදායේ ප්‍රමාණය (Database Size).",
            "දත්ත සමුදායේ පිහිටීම (Database Location).",
            "දත්ත වල දත්ත වර්ග (Data Types of values).",
            "දත්ත වල දිනය සහ වේලාව (Date and Time of data)."
        ],
        correctAnswerIndex: 0,
        explanation: "'INSERT INTO' ප්‍රකාශය භාවිතා කරන විට, දත්ත ඇතුළු කරන 'වගුවේ නම' (Table Name) සහ එම වගුවේ තීරු වලට අනුරූපව ඇතුළු කරන 'අගයන්' (Values) අනිවාර්යයෙන්ම සඳහන් කළ යුතුය. උදා: `INSERT INTO Students (Name, Age) VALUES ('කමල්', 20);`"
    },
    {
        questionText: "පහත ප්‍රකාශයන්ගෙන් SQL ප්‍රකාශ ක්‍රමලේඛන භාෂාවකට ඇතුළත් කිරීමේදී සිදුවන ප්‍රධාන අන්තර්ක්‍රියාව පිළිබඳව නිවැරදි ප්‍රකාශය කුමක්ද?",
        options: [
            "ක්‍රමලේඛන භාෂාව මඟින් SQL ප්‍රකාශයන් දත්ත සමුදා කළමනාකරණ පද්ධතිය වෙත යවා ප්‍රතිඵල ලබා ගනී.",
            "SQL ප්‍රකාශයන් සෘජුවම ක්‍රමලේඛන භාෂාවේ විචල්‍යයන් ලෙස ක්‍රියා කරයි.",
            "SQL ප්‍රකාශයන් ක්‍රමලේඛන භාෂාවේ කේතය බවට පරිවර්තනය වේ.",
            "දත්ත සමුදාය, ක්‍රමලේඛන භාෂාවට අනුව ස්වයංක්‍රීයව වෙනස් වේ.",
            "ක්‍රමලේඛන භාෂාවට දත්ත සමුදාය තුළ ගබඩා විය හැක."
        ],
        correctAnswerIndex: 0,
        explanation: "ක්‍රමලේඛන භාෂාවක් මඟින් දත්ත සමුදායන් සමඟ අන්තර් ක්‍රියා කරන විට, එය SQL ප්‍රකාශයන් තන්තු (strings) ලෙස සකස් කර දත්ත සමුදා කළමනාකරණ පද්ධතිය (DBMS) වෙත යවයි. DBMS එම ප්‍රකාශයන් ක්‍රියාත්මක කර, ප්‍රතිඵල (data) නැවත ක්‍රමලේඛන භාෂාවට ලබා දේ. මෙය සේවාදායක-සර්වර් (client-server) ආකෘතියට සමාන වේ."
    },

    // Back to 9.13 Searching and Sorting (Total 4 + 2 = 6)
    {
        questionText: "පහත දැක්වෙන තත්වයන්ගෙන් කුමන අවස්ථාවක අනුක්‍රමික සෙවුමක් (Sequential Search) ද්විමය සෙවුමට (Binary Search) වඩා කාර්යක්ෂම විය හැකිද?",
        options: [
            "ඉතා කුඩා දත්ත සමූහයක් ඇති විට.",
            "දත්ත සමූහය ඉතා විශාල වන විට.",
            "සෙවීමට අවශ්‍ය අගය දත්ත සමූහයේ මැද පිහිටා ඇති විට.",
            "දත්ත සමූහය අනිවාර්යයෙන්ම ආරෝහණ පිළිවෙලට ඇති විට.",
            "සෙවුමෙන් පසු දත්ත වෙනස් කළ යුතු විට."
        ],
        correctAnswerIndex: 0,
        explanation: "අනුක්‍රමික සෙවුම, 'ඉතා කුඩා දත්ත සමූහයක්' ඇති විට, ද්විමය සෙවුමට වඩා කාර්යක්ෂම විය හැක. ඊට හේතුව, ද්විමය සෙවුමට දත්ත පිළිවෙලට සකස් කිරීමේ පූර්ව අවශ්‍යතාවය සහ එහි ක්‍රියාත්මක කිරීමේ අධිප්‍රමාණ වියදම (overhead) කුඩා දත්ත සමූහ සඳහා අනුක්‍රමික සෙවුමේ සරලත්වයට වඩා අවාසි සහගත විය හැකි බැවිනි. විශාල දත්ත සඳහා සහ පිළිවෙලට ඇති දත්ත සඳහා ද්විමය සෙවුම සෑම විටම පාහේ වඩා කාර්යක්ෂම වේ."
    },
    {
        questionText: "දත්ත සමූහයක් (Array) බුබුළු තේරීම් (Bubble Sort) ඇල්ගොරිතමය භාවිතයෙන් වර්ගීකරණය කිරීමේදී, 'pass' එකක් තුළ කිසිදු දත්ත හුවමාරුවක් (swap) සිදු නොවේ නම්, එහි තේරුම කුමක්ද?",
        options: [
            "දත්ත සමූහය දැනටමත් සම්පූර්ණයෙන්ම වර්ගීකරණය වී ඇති බව.",
            "ඇල්ගොරිතමයේ දෝෂයක් ඇති බව.",
            "වර්ගීකරණය කළ නොහැකි දත්ත අඩංගු බව.",
            "තවත් 'pass' කිහිපයක් අවශ්‍ය බව.",
            "දත්ත සමූහය හිස් බව."
        ],
        correctAnswerIndex: 0,
        explanation: "බුබුළු තේරීම් ඇල්ගොරිතමයේ 'pass' එකක් තුළ කිසිදු දත්ත හුවමාරුවක් (swap) සිදු නොවේ නම්, එයින් අදහස් වන්නේ දත්ත සමූහය 'දැනටමත් සම්පූර්ණයෙන්ම වර්ගීකරණය වී ඇති' බවයි. මෙම තත්වය වර්ගීකරණ ක්‍රියාවලිය නැවැත්වීමට (optimization) භාවිතා කළ හැක, මන්ද තවදුරටත් සංසන්දනය කිරීම් සහ හුවමාරුවීම් අවශ්‍ය නොවන බැවිනි."
    },

    // Final set of questions to reach 30, ensuring all sections have sufficient coverage.
    // 9.8 Control Structures (10 -> 12)
    {
        questionText: "ක්‍රමලේඛයක දත්ත ආදානය (input) ලබා ගන්නා විට, පරිශීලකයා නිවැරදි ආදානයක් ලබා දෙන තුරු නැවත නැවත ආදානය ඉල්ලීමට භාවිතා කළ හැකි පාලන ව්‍යුහය කුමක්ද?",
        options: [
            "while ලූප් (while loop)",
            "if-else ප්‍රකාශය (if-else statement)",
            "for ලූප් (for loop)",
            "switch-case ප්‍රකාශය (switch-case statement)",
            "අනුක්‍රමය (Sequence)"
        ],
        correctAnswerIndex: 0,
        explanation: "පරිශීලකයා නිවැරදි ආදානයක් ලබා දෙන තුරු 'නැවත නැවත' ආදානය ඉල්ලීමට, පුනරාවෘත්ති ව්‍යුහයක් අවශ්‍ය වේ. මෙහිදී පුනරාවර්තන ගණන කලින් නොදන්නා බැවින්, 'while' ලූප් එක (හෝ do-while) වඩාත් සුදුසු වේ. 'while' ලූප් එකක් කොන්දේසියක් සත්‍ය වන තුරු නැවත නැවත ක්‍රියාත්මක වේ."
    },
    {
        questionText: "පහත දැක්වෙන කේත කොටසෙහි ප්‍රතිඵලය කුමක්ද? \n\n```javascript\nfor (let i = 0; i < 3; i++) {\n    if (i === 1) {\n        continue;\n    }\n    console.log(i);\n}\n```",
        options: [
            "0\n2",
            "0\n1\n2",
            "1\n2",
            "0",
            "දෝෂයක් (Error)"
        ],
        correctAnswerIndex: 0,
        explanation: "මෙම for ලූප් එක i = 0, 1, 2 සඳහා ක්‍රියාත්මක වේ. i = 0 විට, if කොන්දේසිය (i === 1) අසත්‍ය බැවින් 0 මුද්‍රණය වේ. i = 1 විට, if කොන්දේසිය සත්‍ය බැවින් 'continue' ප්‍රකාශය ක්‍රියාත්මක වන අතර, ලූප් එකේ ඉතිරි කොටස මග හැරී ඊළඟ පුනරාවර්තනයට (i = 2) යයි. i = 2 විට, if කොන්දේසිය අසත්‍ය බැවින් 2 මුද්‍රණය වේ. එබැවින් ප්‍රතිඵලය 0 සහ 2 වේ."
    },

    // 9.9 Subprograms (9 -> 10)
    {
        questionText: "පහත JavaScript කේතයෙහි ප්‍රතිදානය කුමක්ද? \n\n```javascript\nlet value = 10;\nfunction process(val) {\n    val = val * 2;\n    return val;\n}\nvalue = process(value);\nconsole.log(value);\n```",
        options: [
            "20",
            "10",
            "Undefined",
            "process(value)",
            "දෝෂයක් (Error)"
        ],
        correctAnswerIndex: 0,
        explanation: "process ශ්‍රූතිය val පරාමිතිය ලබාගෙන එය 2න් ගුණ කර ආපසු ලබා දෙයි. value හි ආරම්භක අගය 10 වේ. process(value) කැඳවන විට, val හි අගය 10 වේ. එය 20 බවට පත් වී return වේ. මෙම 20 යන අගය නැවත value විචල්‍යයට පවරන බැවින්, console.log(value) මගින් 20 මුද්‍රණය වේ."
    },

    // 9.10 Data Structures (7 -> 9)
    {
        questionText: "පහත කේත කොටසෙහි, `studentData` යනු කුමන දත්ත ව්‍යුහ වර්ගයකට අයත් වන්නේද සහ එහි ප්‍රධාන ලක්ෂණය කුමක්ද? \n\n```javascript\nlet studentData = {\n    name: 'නිමාෂා',\n    age: 18,\n    grades: [85, 90, 78]\n};\n```",
        options: [
            "ශබ්දකෝෂය (Dictionary) - යතුරු-අගය යුගල ලෙස දත්ත ගබඩා කරන, අනුපිළිවෙලක් නොමැති ව්‍යුහයකි.",
            "ලැයිස්තුව (List) - අනුපිළිවෙලක් ඇති, වෙනස් කළ හැකි ව්‍යුහයකි.",
            "ටියුප්ල (Tuple) - වෙනස් කළ නොහැකි, අනුපිළිවෙලක් ඇති ව්‍යුහයකි.",
            "තන්තු (String) - අක්ෂර අනුපිළිවෙලකි.",
            "අරේ (Array) - එකම දත්ත වර්ගයේ අයිතම පමණක් දැරිය හැකි ව්‍යුහයකි."
        ],
        correctAnswerIndex: 0,
        explanation: "`studentData` යනු JavaScript Object එකක් වන අතර, එය අනෙකුත් ක්‍රමලේඛන භාෂාවල 'ශබ්දකෝෂය' (Dictionary) යන සංකල්පයට අනුරූප වේ. ශබ්දකෝෂ යනු යතුරු-අගය යුගල (key-value pairs) ලෙස දත්ත ගබඩා කරන, අනුපිළිවෙලක් (ordered) නොමැති (නව JavaScript අනුවාද වලදී පිළිවෙලක් ඇති වුවද, සංකල්පීය වශයෙන් නොමැති ලෙස සලකයි) ව්‍යුහයකි. මෙය විවිධ ගුණාංග සහිත සංකීර්ණ වස්තූන් නිරූපණය කිරීමට ඉතා සුදුසුය."
    },
    {
        questionText: "දත්ත ව්‍යුහයක් තෝරා ගැනීමේදී 'දත්ත වෙනස් කළ යුතු නැති' (data should not be modified) යන අවශ්‍යතාවය ප්‍රමුඛ නම්, කුමන දත්ත ව්‍යුහය තෝරා ගැනීම වඩාත් සුදුසුද?",
        options: [
            "ටියුප්ල (Tuple)",
            "ලැයිස්තුව (List)",
            "ශබ්දකෝෂය (Dictionary)",
            "අරේ (Array)",
            "වස්තුව (Object)"
        ],
        correctAnswerIndex: 0,
        explanation: "දත්ත නිර්මාණය කළ පසු ඒවා 'වෙනස් කළ යුතු නැති' (immutable) නම්, 'ටියුප්ල' (Tuple) භාවිතා කිරීම වඩාත් සුදුසුය. ලැයිස්තු, ශබ්දකෝෂ, අරේ සහ වස්තු යනු වෙනස් කළ හැකි (mutable) දත්ත ව්‍යුහ වේ."
    },

    // 9.11 File Handling (6 -> 7)
    {
        questionText: "ගොනුවක් 'කියවීමට' (read) සහ 'ලියවීමට' (write) යන දෙකටම විවෘත කිරීම සඳහා භාවිතා කළ හැකි ගොනු මෙහෙයුම් ආකාරය කුමක්ද?",
        options: [
            "r+ (read and write)",
            "w (write)",
            "r (read)",
            "a (append)",
            "x (exclusive creation)"
        ],
        correctAnswerIndex: 0,
        explanation: "බොහෝ ක්‍රමලේඛන භාෂා වල ගොනු මෙහෙයුම් වලදී 'r+' ආකාරය (mode) මගින් ගොනුවක් 'කියවීමට' සහ 'ලියවීමට' යන දෙකටම විවෘත කළ හැක. 'w' ලියවීම සඳහා පමණක් වන අතර පවතින අන්තර්ගතය මකා දමයි. 'r' කියවීම සඳහා පමණක් වන අතර, 'a' පවතින අන්තර්ගතයට එකතු කිරීමට භාවිතා වේ."
    },

    // 9.12 Database Management (7 -> 8)
    {
        questionText: "SQL ප්‍රකාශයක් භාවිතයෙන් දත්ත සමුදායකින් යම් කොන්දේසියකට අනුව දත්ත 'මැකීම' (delete) සඳහා භාවිතා කරන ප්‍රධාන විධානය කුමක්ද?",
        options: [
            "DELETE FROM TableName WHERE Condition;",
            "REMOVE FROM TableName WHERE Condition;",
            "ERASE FROM TableName WHERE Condition;",
            "DROP TableName WHERE Condition;",
            "CLEAR FROM TableName WHERE Condition;"
        ],
        correctAnswerIndex: 0,
        explanation: "දත්ත සමුදායකින් දත්ත 'මැකීම' (delete) සඳහා භාවිතා කරන SQL විධානය 'DELETE FROM' වේ. නිශ්චිත වාර්තා මැකීමට 'WHERE' කොන්දේසිය අත්‍යවශ්‍ය වේ. 'DROP' විධානය වගුවක් හෝ දත්ත සමුදායක් සම්පූර්ණයෙන් මැකීමට භාවිතා වේ."
    },

    // 9.13 Searching and Sorting (6 -> 8)
    {
        questionText: "සෙවුම් සහ තේරීම් ඇල්ගොරිතම ක්‍රමලේඛනයේදී භාවිතා කිරීමේ ප්‍රධාන අරමුණ කුමක්ද?",
        options: [
            "දත්ත කාර්යක්ෂමව සොයා ගැනීමට සහ සංවිධානය කිරීමට.",
            "ක්‍රමලේඛයේ ප්‍රමාණය අඩු කිරීමට.",
            "ක්‍රමලේඛයේ දෝෂ හඳුනා ගැනීමට.",
            "පරිශීලක අතුරු මුහුණතේ සුන්දරත්වය වැඩි කිරීමට.",
            "ගොනු හැසිරවීම පහසු කිරීමට."
        ],
        correctAnswerIndex: 0,
        explanation: "සෙවුම් සහ තේරීම් ඇල්ගොරිතමවල ප්‍රධාන අරමුණ වන්නේ දත්ත විශාල ප්‍රමාණයකින් අවශ්‍ය දත්ත 'කාර්යක්ෂමව සොයා ගැනීමට' (searching) සහ ඒවා යම් නිශ්චිත 'පිළිවෙලකට සංවිධානය කිරීමට' (sorting) උපකාර කිරීමයි. මෙය දත්ත සැකසීමේ කාර්යක්ෂමතාව සහ ක්‍රමලේඛයේ සමස්ත කාර්යසාධනය (performance) වැඩි දියුණු කරයි."
    },
    {
        questionText: "යම්කිසි නාම ලේඛනයක (ලැයිස්තුවක) නිශ්චිත නමක් සොයා ගැනීමට අවශ්‍ය නම්, එම ලැයිස්තුවේ නම් කිසිදු නිශ්චිත පිළිවෙලකට නොමැති විට, ඔබ භාවිතා කරන්නේ කුමන ආකාරයේ සෙවුම් ඇල්ගොරිතමයක්ද?",
        options: [
            "අනුක්‍රමික සෙවුම (Sequential Search)",
            "ද්විමය සෙවුම (Binary Search)",
            "Hash සෙවුම (Hash Search)",
            "ගැඹුරු පළමු සෙවුම (Depth-First Search)",
            "පළල පළමු සෙවුම (Breadth-First Search)"
        ],
        correctAnswerIndex: 0,
        explanation: "නම් කිසිදු නිශ්චිත පිළිවෙලකට (unsorted) නොමැති විට, 'අනුක්‍රමික සෙවුම' (Sequential Search) පමණක් භාවිතා කළ හැක. මෙම ක්‍රමය මඟින් ලැයිස්තුවේ ආරම්භයේ සිට අවසානය දක්වා සෑම නමක්ම එකින් එක පරීක්ෂා කරමින් අවශ්‍ය නම සොයා ගනී. ද්විමය සෙවුම සඳහා දත්ත පිළිවෙලට තිබීම අත්‍යවශ්‍ය වේ."
    }
];
